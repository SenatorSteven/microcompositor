/*!
	check for monitor change issues
*/

/*!
	make sure that, no matter what the monitor setup, no work is being done for something that lies outside what the user sees
*/

/*!
	maybe setup a picture or an equivalent to be drawn when rectangles of the root are viewable
*/

/*!
	rectangle splitting can create rectangles that can be combined into one (yikes)
*/

/*!
	consider force mapping the area behind a window when it unmaps
*/

/*!
	fix all kinds of issues that can be safely called basic and then move onto 32 bit window handling.



	basic includes faultless composition at idle-tier speeds where all windows are treated as 24 bit.
	then deal with how the wallpaper works and then deal with 32 bit windows.
*/

/*!
	consider not drawing anything outside the screen.
*/

/*!
	windows that move will leave a trail until the below window is updated.
*/

/*!
	treat root as a normal window and maybe always keep it as the starting window in the window order. also try extensions and selecting input on the root.
*/

/*!
	findClient() should be used only after a fastFindClient() is used.

	fastFindClient() should hold the n, say 5, last seen windows.
*/

/*!
	is there a way to draw all changes in a single call? multiple xcb_put_image() are bad for your health, swear!
*/

/*!
	consider getting up to n events from the loop and doing them at the same time
*/

/*!
	grab server when doing critical operation when the server starts

	ungrab afterwards
*/

/*!
	keep non-input-output windows?
*/



























/*! microcompositor.cold

MIT License

Copyright (C) 2023 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#include <stdint.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <xcb/composite.h>
	#include <xcb/damage.h>
	#include <xcb/randr.h>
	#include <xcb/render.h>
	#include <xcb/shape.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include "cold/cold.hold"
/*!}*/

/*!user_defines:{*/
	#define DefaultErrorStream /*-------------*/ (stderr)
/*!}*/

/*!defines:{*/
	#define DEBUG /*--------------------------*/ (true)

	#define _EMPTY_MACRO /*-------------------*/

	#define FINDCLIENT() /*-------------------*/ local Client *findClient(const xcb_window_t window)
	#define REMOVECLIENT() /*-----------------*/ local void    removeClient(Client *const client)
	#define UNMAPWINDOW() /*------------------*/ local void    unmapWindow(Client *const client)
	#define MAPWINDOW() /*--------------------*/ local void    mapWindow(Client *const client)
	#define ADDCLIENT() /*--------------------*/ local bool    addClient(const xcb_window_t window)
	#define QUERYTREE() /*--------------------*/ local void    queryTree(void)
	#define UPDATEORDER() /*------------------*/ local void    updateOrder(void)
	#define FINDINTERSECTINGRECTANGLE() /*----*/ local bool    findIntersectingRectangle(int leftX0, int topY0, int width0, int height0, int leftX1, int topY1, int width1, int height1, int *retX, int *retY, int *retWidth, int *retHeight)
	#define SPLITRECTANGLE() /*---------------*/ local void    splitRectangle(int x, int y, int w, int h, int interX, int interY, int interW, int interH, uint *size, uint *allocated, Rectangle **rectangle)
	#define CALCULATEVIEWABLEWINDOWSIZES() /*-*/ local void    calculateViewableWindowSizes(void)

	#define PRINTERROR() /*-------------------*/ local void    printError(const char *const string)
	#define OPENERRORSTREAM() /*--------------*/ local bool    openErrorStream(void)
	#define CLOSEERRORSTREAM() /*-------------*/ local void    closeErrorStream(void)
	#define PRINTCONNECTIONERROR() /*---------*/ local void    printConnectionError(void)
	#define PRINTXCBERROR() /*----------------*/ local void    printXCBError(void)

	#define xcb_wait_for_reply(a, b, c) /*----*/ (xcb_wait_for_reply(a, (b).sequence, c))

	#define LITERAL_LENGTH(l) /*--------------*/ (sizeof(l) - 1)

	#define _b(d, b) /*-----------------------*/ (d > (sizeof(#b) - 1)? 0 : ((*(#b + (sizeof(#b) - 1) - d) - 48) == 1) * ((uint64)1 << (d - 1)))

	#define b(b) /*---------------------------*/ ( \
		  _b( 1, b) + _b( 2, b) + _b( 3, b) + _b( 4, b) + _b( 5, b) + _b( 6, b) + _b( 7, b) + _b( 8, b) \
		+ _b( 9, b) + _b(10, b) + _b(11, b) + _b(12, b) + _b(13, b) + _b(14, b) + _b(15, b) + _b(16, b) \
		+ _b(17, b) + _b(18, b) + _b(19, b) + _b(20, b) + _b(21, b) + _b(22, b) + _b(23, b) + _b(24, b) \
		+ _b(25, b) + _b(26, b) + _b(27, b) + _b(28, b) + _b(29, b) + _b(30, b) + _b(31, b) + _b(32, b) \
		+ _b(33, b) + _b(34, b) + _b(35, b) + _b(36, b) + _b(37, b) + _b(38, b) + _b(39, b) + _b(40, b) \
		+ _b(41, b) + _b(42, b) + _b(43, b) + _b(44, b) + _b(45, b) + _b(46, b) + _b(47, b) + _b(48, b) \
		+ _b(49, b) + _b(50, b) + _b(51, b) + _b(52, b) + _b(53, b) + _b(54, b) + _b(55, b) + _b(56, b) \
		+ _b(57, b) + _b(58, b) + _b(59, b) + _b(60, b) + _b(61, b) + _b(62, b) + _b(63, b) + _b(64, b) \
	)

	#define RECTANGLE_BLOCK_SIZE /*-----------*/ (8)
	#define CLIENT_BLOCK_SIZE /*--------------*/ (128)
/*!}*/

/*!globals:{*/
	const char * /*----------*/ programName;
	const char * /*----------*/ errorPath;
	const char * /*----------*/ connectionName;
	const xcb_screen_t * /*--*/ screen;
	const char * /*----------*/ quitMessage;
	bool /*------------------*/ mustOpenErrorStream;
	FILE * /*----------------*/ errorStream;
	xcb_connection_t * /*----*/ connection;
	xcb_generic_error_t * /*-*/ genericError;
	xcb_generic_event_t * /*-*/ event0;
/*!}*/

/*!functions:{*/
	PRINTERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
	PRINTCONNECTIONERROR();
	PRINTXCBERROR();
/*!}*/

def struct{
	int32 /*-------------------*/ x;
	int32 /*-------------------*/ y;
	int32 /*-------------------*/ w;
	int32 /*-------------------*/ h;
} Rectangle;

def struct{
	Rectangle * /*-------------*/ rectangle;
	uint32 /*------------------*/ size;
	uint32 /*------------------*/ allocated;

	xcb_window_t /*------------*/ window;
	xcb_damage_damage_t /*-----*/ damage;
	xcb_visualid_t /*----------*/ visual;
	xcb_render_pictformat_t /*-*/ format;
	xcb_render_picture_t /*----*/ picture;

	int32 /*-------------------*/ x;
	int32 /*-------------------*/ y;
	int32 /*-------------------*/ w;
	int32 /*-------------------*/ h;

	bool /*--------------------*/ shaped;
	bool /*--------------------*/ mapped;

	uint8 /*-------------------*/ depth;
	uint8 /*-------------------*/ pad0[1];
} Client;

def struct{
	uint16 /*------------------*/ x;
	uint16 /*------------------*/ y;
	uint16 /*------------------*/ w;
	uint16 /*------------------*/ h;
} Monitor;

const uint32 windowValueList = XCB_EVENT_MASK_VISIBILITY_CHANGE | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_STRUCTURE_NOTIFY;
uint damageBaseEvent;
uint damageBaseError;
uint renderBaseEvent;
uint renderBaseError;
uint randrBaseEvent;
uint randrBaseError;



xcb_atom_t pixmapAtom;
xcb_atom_t rootPixmapAtom;
xcb_render_pictformat_t rootFormat;
xcb_pixmap_t wallpaperPixmap;
xcb_render_picture_t wallpaperPicture;
xcb_pixmap_t bufferPixmap;
xcb_render_picture_t bufferPicture;
xcb_render_picture_t rootPicture;



uint clientSize = CLIENT_BLOCK_SIZE;
uint clientAllocated = 0;
Client *clientStart;
Client *clientWall;



uint monitorAmount;
void *monitorData;
Monitor *monitorStart;
Monitor *monitorWall;



uint *orderedClientOffsetStart;
xcb_window_t overlayWindow;
uint visualAmount;
xcb_render_pictvisual_t *visualStart;
xcb_query_tree_reply_t *treeReply;



FINDCLIENT();
REMOVECLIENT();
UNMAPWINDOW();
MAPWINDOW();
ADDCLIENT();
QUERYTREE();
UPDATEORDER();
FINDINTERSECTINGRECTANGLE();
SPLITRECTANGLE();
CALCULATEVIEWABLEWINDOWSIZES();

int main(const int argumentAmount, const char *const *argument){
	(void)argumentAmount;
	jmp setPrimaryGlobals;
	setPrimaryGlobals:{
		programName /*---------*/ = *argument;
		errorPath /*-----------*/ = NULL;
		connectionName /*------*/ = NULL;
		mustOpenErrorStream /*-*/ = false;
		errorStream /*---------*/ = DefaultErrorStream;
		connection /*----------*/ = NULL;
		genericError /*--------*/ = NULL;
		event0 /*--------------*/ = NULL;
		quitMessage /*---------*/ = NULL;
		treeReply /*-----------*/ = NULL;
		wallpaperPixmap /*-----*/ = XCB_NONE;
		wallpaperPicture /*----*/ = XCB_NONE;
		jmp establishServerConnection;
	}
	establishServerConnection:{
		#define ESTABLISHSERVERCONNECTION_CONNECTION /*-----*/ connection
		#define ESTABLISHSERVERCONNECTION_CONNECTIONNAME /*-*/ connectionName
		#define ESTABLISHSERVERCONNECTION_SCREEN /*---------*/ screen
		#include "xcb/establishServerConnection.hold"
		switch xcb_connection_has_error(connection) over
			to XCB_NONE: /*------------*/ /*-----------------------------------------------------------------*/ brk;
			to XCB_CONN_CLOSED_PARSE_ERR: printError(connectionName? "invalid server name" : "no server name"); jmp mainEmergencyExit;
			off: /*--------------------*/ printConnectionError(); /*-----------------------------------------*/ jmp mainEmergencyExit;
		end
	}
	damageBaseEvent = 0;
	damageBaseError = 0;
	renderBaseEvent = 0;
	renderBaseError = 0;
	randrBaseEvent = 0;
	randrBaseError = 0;
	{
		const xcb_query_extension_cookie_t compositeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("Composite"), "Composite");
		const xcb_query_extension_cookie_t damageCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("DAMAGE"), "DAMAGE");
		const xcb_query_extension_cookie_t randrCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RANDR"), "RANDR");
		const xcb_query_extension_cookie_t renderCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RENDER"), "RENDER");
		const xcb_query_extension_cookie_t xfixesCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("XFIXES"), "XFIXES");
		const xcb_query_extension_cookie_t shapeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("SHAPE"), "SHAPE");
		xcb_query_extension_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_query_extension_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_query_extension_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_query_extension_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_query_extension_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_query_extension_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(!compositeReply or !(*compositeReply).present){
			fprintf(stdout, "composite extension not available\n");
		}else{
			free(compositeReply);
		}
		if(!damageReply or !(*damageReply).present){
			fprintf(stdout, "damage extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_damage_id);
			damageBaseEvent = 0;
			damageBaseError = 0;
			if(reply and (*reply).present){
				damageBaseEvent = (*reply).first_event;
				damageBaseError = (*reply).first_error;
			}
			free(damageReply);
		}
		if(!randrReply or !(*randrReply).present){
			fprintf(stdout, "randr extension not available\n");
		}else{
			free(randrReply);
		}
		if(!renderReply or !(*renderReply).present){
			fprintf(stdout, "render extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_render_id);
			renderBaseEvent = 0;
			renderBaseError = 0;
			if(reply and (*reply).present){
				renderBaseEvent = (*reply).first_event;
				renderBaseError = (*reply).first_error;
			}
			free(renderReply);
		}
		if(!xfixesReply or !(*xfixesReply).present){
			fprintf(stdout, "xfixes extension not available\n");
		}else{
			free(xfixesReply);
		}
		if(!shapeReply or !(*shapeReply).present){
			fprintf(stdout, "shape extension not available\n");
		}else{
			free(shapeReply);
		}
	}
	{
		xcb_damage_query_version_cookie_t compositeCookie = xcb_damage_query_version_unchecked(connection, XCB_COMPOSITE_MAJOR_VERSION, XCB_COMPOSITE_MINOR_VERSION);
		xcb_damage_query_version_cookie_t damageCookie = xcb_damage_query_version_unchecked(connection, XCB_DAMAGE_MAJOR_VERSION, XCB_DAMAGE_MINOR_VERSION);
		xcb_damage_query_version_cookie_t renderCookie = xcb_damage_query_version_unchecked(connection, XCB_RENDER_MAJOR_VERSION, XCB_RENDER_MINOR_VERSION);
		xcb_damage_query_version_cookie_t randrCookie = xcb_damage_query_version_unchecked(connection, XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
		xcb_xfixes_query_version_cookie_t xfixesCookie = xcb_xfixes_query_version_unchecked(connection, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION);
		xcb_xfixes_query_version_cookie_t shapeCookie = xcb_xfixes_query_version_unchecked(connection, XCB_SHAPE_MAJOR_VERSION, XCB_SHAPE_MINOR_VERSION);
		xcb_damage_query_version_reply_t *compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_damage_query_version_reply_t *damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_damage_query_version_reply_t *renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_damage_query_version_reply_t *randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_xfixes_query_version_reply_t *xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_xfixes_query_version_reply_t *shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(compositeReply){
			free(compositeReply);
		}else{
			fprintf(stdout, "%s: could not query composite extension\n", programName);
		}
		if(damageReply){
			free(damageReply);
		}else{
			fprintf(stdout, "%s: could not query damage extension\n", programName);
		}
		if(renderReply){
			free(renderReply);
		}else{
			fprintf(stdout, "%s: could not query render extension\n", programName);
		}
		if(randrReply){
			free(randrReply);
		}else{
			fprintf(stdout, "%s: could not query randr extension\n", programName);
		}
		if(xfixesReply){
			free(xfixesReply);
		}else{
			fprintf(stdout, "%s: could not query xfixes extension\n", programName);
		}
		if(shapeReply){
			free(shapeReply);
		}else{
			fprintf(stdout, "%s: could not query shape extension\n", programName);
		}
	}



	{
		xcb_composite_get_overlay_window_reply_t *overlay = xcb_wait_for_reply(connection, xcb_composite_get_overlay_window_unchecked(connection, (*screen).root), NULL);
		if(overlay){
			overlayWindow = (*overlay).overlay_win;
			free(overlay);
		}
	}
	{
		const uint32 valueList = XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_change_window_attributes(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		xcb_composite_redirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}



	{
		xcb_intern_atom_reply_t *reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("PIXMAP"), "PIXMAP"), NULL);
		pixmapAtom = XCB_NONE;
		if(reply){
			pixmapAtom = (*reply).atom;
			free(reply);
		}
	}
	{
		xcb_intern_atom_reply_t *reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("_XROOTPMAP_ID"), "_XROOTPMAP_ID"), NULL);
		rootPixmapAtom = XCB_NONE;
		if(reply){
			rootPixmapAtom = (*reply).atom;
			free(reply);
		}
	}



	jmp storeMonitors;
	storeMonitors:{
		void *reply;
		Monitor *monitorCurrent;
		xcb_randr_monitor_info_iterator_t iterator;
		if(!(reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL))){
			monitorAmount = 1;
			jmp storeMonitorsExit;
		}
		monitorAmount = (*(xcb_randr_get_monitors_reply_t *)reply).nMonitors;
		if(!(monitorData = malloc(monitorAmount * sizeof(Monitor)))){
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorStart = monitorData;
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAmount;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const uint x = (*data).x;
				const uint y = (*data).y;
				const uint w = (*data).width;
				const uint h = (*data).height;
				if(monitorCurrent > monitorStart){
					const Monitor *const wall = monitorCurrent;
					const Monitor *current = monitorStart;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).x == x and (*current).y == y and (*current).w == w and (*current).h == h){
								dec monitorAmount;
								dec monitorWall;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).x = x;
				(*monitorCurrent).y = y;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				xcb_randr_monitor_info_next(&iterator);
				inc monitorCurrent;
				jmp storeMonitorLoop;
			}
			jmp trimMonitorMemory;
		}
		trimMonitorMemory:{
			void *temp;
			if(!(temp = realloc(monitorData, monitorAmount * sizeof(Monitor)))){
				free(reply);
				jmp storeMonitorsExit;
			}
			monitorData = temp;
		}
		monitorStart = monitorData;
		monitorWall = monitorStart + monitorAmount;
		free(reply);
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{}



	clientStart = malloc(clientSize * sizeof(Client));
	if(!clientStart){
		fprintf(stdout, "no clientStart\n");
	}
	clientWall = clientStart + clientAllocated;
	orderedClientOffsetStart = malloc(clientSize * sizeof(uint));
	if(!orderedClientOffsetStart){
		fprintf(stdout, "no orderedClientOffsetStart\n");
	}



	{
		const uint32 stackMode = XCB_STACK_MODE_BELOW;
		xcb_configure_window(connection, overlayWindow, XCB_CONFIG_WINDOW_STACK_MODE, &stackMode);
	}









	/*! update this to only keep valid (visual, format) pairs */
	{
		xcb_render_pictvisual_t *current;
		xcb_render_pictvisual_t *wall;
		xcb_render_query_pict_formats_reply_t *formats = xcb_wait_for_reply(connection, xcb_render_query_pict_formats_unchecked(connection), NULL);



/*!
		xcb_render_pictforminfo_iterator_t pictformIterator = xcb_render_query_pict_formats_formats_iterator(formats);
		while(pictformIterator.rem){



			fprintf(stdout, "%u\n", (*pictformIterator.data).type);



			direct?



			xcb_render_pictforminfo_next(&pictformIterator);
		}
*/



		visualAmount = 0;
		{
			xcb_render_pictscreen_iterator_t pictscreenIterator = xcb_render_query_pict_formats_screens_iterator(formats);
			while(pictscreenIterator.rem){
				xcb_render_pictdepth_iterator_t pictdepth = xcb_render_pictscreen_depths_iterator(pictscreenIterator.data);
				while(pictdepth.rem){
					visualAmount += xcb_render_pictdepth_sizeof(pictdepth.data);
					xcb_render_pictdepth_next(&pictdepth);
				}
				xcb_render_pictscreen_next(&pictscreenIterator);
			}
		}
		visualStart = malloc(visualAmount * sizeof(xcb_render_pictvisual_t));
		current = visualStart;
		{
			xcb_render_pictscreen_iterator_t pictscreenIterator = xcb_render_query_pict_formats_screens_iterator(formats);
			while(pictscreenIterator.rem){
				xcb_render_pictdepth_iterator_t pictdepth = xcb_render_pictscreen_depths_iterator(pictscreenIterator.data);
				while(pictdepth.rem){
					xcb_render_pictvisual_t *pictvisual = xcb_render_pictdepth_visuals(pictdepth.data);
					uint length = xcb_render_pictdepth_sizeof(pictdepth.data);
					while(length){



						if((*pictvisual).visual != (*(current - 1)).visual or (*pictvisual).format != (*(current - 1)).format){
							*current = *pictvisual;
							inc current;
						}else{
							dec visualAmount;
						}



						dec length;
					}
					xcb_render_pictdepth_next(&pictdepth);
				}
				xcb_render_pictscreen_next(&pictscreenIterator);
			}
		}
		current = visualStart;
		wall = visualStart + visualAmount - 1;
		current = visualStart;
		while(current < wall){
			if(!(*current).visual or !(*current).format){
				const xcb_render_pictvisual_t pair = *wall;
				*wall = *current;
				*current = pair;
				dec wall;
				continue;
			}
			inc current;
		}
		free(formats);
	}



	{
		xcb_visualid_t visual = (*screen).root_visual;
		xcb_render_pictvisual_t *current = visualStart;
		xcb_render_pictvisual_t *wall = visualStart + visualAmount;
		rootFormat = XCB_NONE;
		while(current < wall){
			if((*current).visual == visual){
				rootFormat = (*current).format;
				brk;
			}
			inc current;
		}
	}



	{
		const uint32 valueList = XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS;
		bufferPixmap = xcb_generate_id(connection);
		rootPicture = xcb_generate_id(connection);
		bufferPicture = xcb_generate_id(connection);
		xcb_create_pixmap(connection, (*screen).root_depth, bufferPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_render_create_picture(connection, bufferPicture, bufferPixmap, rootFormat, XCB_RENDER_CP_SUBWINDOW_MODE, &valueList);
		xcb_render_create_picture(connection, rootPicture, overlayWindow, rootFormat, XCB_NONE, NULL);
	}



	if(rootPixmapAtom){
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL);
		if(reply){
			xcb_pixmap_t pixmap;
			if((*reply).type != pixmapAtom){
				fprintf(stdout, "%s: root pixmap is not of type pixmap\n", programName);
			}else{
				pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
				if(pixmap){
					const xcb_gcontext_t gc = xcb_generate_id(connection);
					const uint32 valueList = XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS;
					wallpaperPixmap = xcb_generate_id(connection);
					wallpaperPicture = xcb_generate_id(connection);
					xcb_create_gc(connection, gc, pixmap, XCB_NONE, NULL);
					xcb_create_pixmap(connection, (*screen).root_depth, wallpaperPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
					xcb_copy_area(connection, pixmap, wallpaperPixmap, gc, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
					xcb_free_gc(connection, gc);
					xcb_render_create_picture(connection, wallpaperPicture, wallpaperPixmap, rootFormat, XCB_RENDER_CP_SUBWINDOW_MODE, &valueList);
				}
			}
			free(reply);
		}
	}









	queryTree();
	if(treeReply){
		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
		uint *orderedClientOffsetCurrent = orderedClientOffsetStart;



		/*! good idea if we calculate it's viewable area? */

		/*! if(addClient((*screen).root)){
			*orderedClientOffsetCurrent = orderedClientOffsetCurrent - orderedClientOffsetStart;
			inc orderedClientOffsetCurrent;
		} */



		addExistingClientLoop:{
			if(addClient(*windowCurrent)){
				*orderedClientOffsetCurrent = orderedClientOffsetCurrent - orderedClientOffsetStart;
				inc orderedClientOffsetCurrent;
			}
			if(inc windowCurrent < windowWall){
				jmp addExistingClientLoop;
			}
		}
	}
	clientWall = clientStart + clientAllocated;
	calculateViewableWindowSizes();









	/*! draw everything once here */









	eventLoop:{
		xcb_flush(connection);
		free(event0);
		event0 = NULL;
		jmp waitForEventLoop;
	}
	waitForEventLoop:{
		if((event0 = xcb_wait_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		jmp eventLoop;
	}
	switchEvents:{
		#define XCB_ONE /*-*/ (1)
		switch (*event0).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unexpectedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp unexpectedEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp unexpectedEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp unexpectedEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp unexpectedEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp unexpectedEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	extensionEvent:{
		if(((*event0).response_type & ~b(10000000)) == damageBaseEvent + XCB_DAMAGE_NOTIFY){
			jmp damageNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseEvent + XCB_RANDR_SCREEN_CHANGE_NOTIFY){
			jmp randrNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == damageBaseError + XCB_DAMAGE_BAD_DAMAGE){
			jmp badDamageError;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseError){
			jmp randrNotifyError;
		}
		jmp unexpectedEvent;
	}
	visibilityNotifyEvent: fprintf(stdout, "visibility notify\n"); {
		#define event0 /*-*/ ((xcb_visibility_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			if((*event0).state == XCB_VISIBILITY_FULLY_OBSCURED){
				unmapWindow(client);
			}else{
				mapWindow(client);
			}
			calculateViewableWindowSizes();
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	createNotifyEvent: fprintf(stdout, "create notify\n"); {
		#define event0 /*-*/ ((xcb_create_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		queryTree();
		if(!client){
			if(addClient((*event0).window)){
				updateOrder();
				calculateViewableWindowSizes();
			}
		}
		jmp eventLoop;
		#undef  event0
	}
	destroyNotifyEvent: fprintf(stdout, "destroy notify\n"); {
		#define event0 /*-*/ ((xcb_destroy_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		queryTree();
		if(client){
			removeClient(client);
			updateOrder();
			calculateViewableWindowSizes();
		}
		jmp eventLoop;
		#undef  event0
	}
	unmapNotifyEvent: fprintf(stdout, "unmap notify\n"); {
		#define event0 /*-*/ ((xcb_unmap_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			unmapWindow(client);
			calculateViewableWindowSizes();

			/*!
				draw again here
			*/

		}
		jmp drawRegion;
		#undef  event0
	}
	mapNotifyEvent: fprintf(stdout, "map notify\n"); {
		#define event0 /*-*/ ((xcb_map_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			mapWindow(client);
			calculateViewableWindowSizes();

			/*!
				draw again here?
			*/

		}
		jmp eventLoop;
		#undef  event0
	}
	reparentNotifyEvent: fprintf(stdout, "reparent notify\n"); {
		#define event0 /*-*/ ((xcb_reparent_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		queryTree();
		if((*event0).parent == (*screen).root){
			if(!client){
				if(addClient((*event0).window)){
					updateOrder();
					calculateViewableWindowSizes();
				}
			}
			jmp eventLoop;
		}
		if(client){
			removeClient(client);
			updateOrder();
			calculateViewableWindowSizes();
		}
		jmp eventLoop;
		#undef  event0
	}
	configureNotifyEvent: fprintf(stdout, "configure notify\n"); {
		#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(!client){
			jmp eventLoop;
		}



		/*! check rectangle intersection with other windows to draw them when there is movement */



		/*! maybe update this later */



		removeClient(client);
		addClient((*event0).window);

		updateOrder();
		calculateViewableWindowSizes();
		jmp eventLoop;
		#undef  event0
	}
	circulateNotifyEvent: fprintf(stdout, "---------------circulate notify\n"); {
		#define event0 /*-*/ ((xcb_circulate_notify_event_t *)event0)
		queryTree();
		updateOrder();
		calculateViewableWindowSizes();
		jmp eventLoop;
		#undef  event0
	}
	propertyNotifyEvent:{
		#define event0 /*-*/ ((xcb_property_notify_event_t *)event0)
		if((*event0).atom == rootPixmapAtom and rootPixmapAtom){



			/*! update pixmap here */



		}
		jmp eventLoop;
		#undef  event0
	}
	damageNotifyEvent:{
		#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
		const xcb_window_t window = (*event0).drawable;
		Client *const client = findClient(window);
		xcb_rectangle_t *geometry;
		int eventX;
		int eventY;
		int eventW;
		int eventH;
		if(window == (*screen).root){
			fprintf(stdout, "root damaged\n");
		}
		if(window == overlayWindow){
			fprintf(stdout, "overlay damaged\n");
		}
		if(!client or !(*client).mapped){
			jmp eventLoop;
		}
		if((*client).x + (*client).w < 1 or (*client).x >= (*screen).width_in_pixels or (*client).y + (*client).h < 1 or (*client).y >= (*screen).height_in_pixels){
			jmp eventLoop;
		}



		geometry = &(*event0).geometry;
		eventX = (*geometry).x;
		eventY = (*geometry).y;
		eventW = (*geometry).width;
		eventH = (*geometry).height;
		{
			xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region(connection, region, 1, geometry);
			xcb_damage_subtract(connection, (*client).damage, XCB_NONE, XCB_NONE);
			/*! xcb_damage_subtract(connection, (*client).damage, XCB_NONE, region); */
			xcb_xfixes_destroy_region(connection, region);
		}



		if(!(*client).format){
			const xcb_visualid_t visual = (*client).visual;
			xcb_render_pictvisual_t *current = visualStart;
			xcb_render_pictvisual_t *wall = visualStart + visualAmount;
			while(current < wall){
				if((*current).visual == visual){
					(*client).format = (*current).format;
					brk;
				}
				inc current;
			}
			/*! fprintf(stdout, "out looking for visual\n"); */
		}



		{
			xcb_rectangle_t *rectangleStart = malloc(100 * sizeof(xcb_rectangle_t));
			xcb_rectangle_t *rectangleCurrent = rectangleStart;
			uint amount = 0;



			const Rectangle *rectangle = (*client).rectangle;
			const Rectangle *const wall = rectangle + (*client).allocated;
			int x;
			int y;
			int w;
			int h;



			if(!rectangleStart){
				jmp eventLoop;
			}
			while(rectangle < wall){
				if(findIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).w, (*rectangle).h, eventX, eventY, eventW, eventH, &x, &y, &w, &h)){
					(*rectangleCurrent).x = x;
					(*rectangleCurrent).y = y;
					(*rectangleCurrent).width = w;
					(*rectangleCurrent).height = h;
					inc rectangleCurrent;
					inc amount;
				}
				inc rectangle;
			}
			if(amount){
				const uint32 valueList = XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS;
				xcb_xfixes_region_t region = xcb_generate_id(connection);
				xcb_xfixes_create_region(connection, region, amount, rectangleStart);
				{
					xcb_render_picture_t picture = xcb_generate_id(connection);
					xcb_render_create_picture(connection, picture, window, (*client).format, XCB_RENDER_CP_SUBWINDOW_MODE, &valueList);
					{
						xcb_xfixes_set_picture_clip_region(connection, picture, region, 0, 0);
						xcb_render_composite(connection, XCB_RENDER_PICT_OP_OVER, picture, XCB_NONE, rootPicture, 0, 0, 0, 0, eventX, eventY, eventW, eventH);
					}
					xcb_render_free_picture(connection, picture);
				}
				xcb_xfixes_destroy_region(connection, region);
			}
			free(rectangleStart);
		}









		jmp drawRegion;
		#undef  event0
	}
	drawRegion:{



		/*!*/



		jmp eventLoop;
	}



























	errorEvent:{
		genericError = (void *)event0;
		printXCBError();
		genericError = NULL;
		jmp eventLoop;
	}
	unexpectedEvent:{
		jmp eventLoop;
	}
	badDamageError:{
		fprintf(stdout, "%s: bad damage error\n", programName);
		jmp eventLoop;
	}
	randrNotifyEvent:{
		const uint32 valueList = XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS;
		fprintf(stdout, "%s: randr notify event\n", programName);



		/*! update root buffer pixmap and picture here */

		xcb_render_free_picture(connection, rootPicture);
		xcb_render_free_picture(connection, bufferPicture);
		xcb_free_pixmap(connection, bufferPixmap);
		bufferPixmap = xcb_generate_id(connection);
		bufferPicture = xcb_generate_id(connection);
		rootPicture = xcb_generate_id(connection);
		xcb_create_pixmap(connection, (*screen).root_depth, bufferPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_render_create_picture(connection, bufferPicture, bufferPixmap, rootFormat, XCB_RENDER_CP_SUBWINDOW_MODE, &valueList);
		xcb_render_create_picture(connection, rootPicture, overlayWindow, rootFormat, XCB_NONE, NULL);



		jmp eventLoop;
	}
	randrNotifyError:{
		fprintf(stdout, "%s: randr notify event\n", programName);



		/*! update root buffer pixmap and picture here */



		jmp eventLoop;
	}
	eventLoopExit:{
		free(event0);
		event0 = NULL;
		jmp mainEmergencyExit;
	}
	mainEmergencyExit:{
		xcb_disconnect(connection);
		connection = NULL;
		ret 0;
	}
}



























FINDINTERSECTINGRECTANGLE(){
	int  rightX0 = leftX0 +  width0;
	int  rightX1 = leftX1 +  width1;
	int bottomY0 =  topY0 + height0;
	int bottomY1 =  topY1 + height1;
	if(leftX1 < rightX0 and rightX1 > leftX0 and topY1 < bottomY0 and bottomY1 > topY0){
		*retX      =    leftX0 >   leftX1?   leftX0 :   leftX1;
		*retY      =     topY0 >    topY1?    topY0 :    topY1;
		*retWidth  = ( rightX0 <  rightX1?  rightX0 :  rightX1) - *retX;
		*retHeight = (bottomY0 < bottomY1? bottomY0 : bottomY1) - *retY;
		ret true;
	}
	ret false;
}
SPLITRECTANGLE(){
	Rectangle *current;
	if(*allocated + 4 >= *size){
		void *temp;
		*size += RECTANGLE_BLOCK_SIZE;
		if(!(temp = realloc(*rectangle, *size * sizeof(Rectangle)))){
			jmp emergencyExit;
		}
		*rectangle = temp;
	}
	current = *rectangle + *allocated;
	if(interY > y){
		(*current).x = x;
		(*current).y = y;
		(*current).w = w;
		(*current).h = interY - y;
		inc current;
	}
	if(interY + interH < y + h){
		(*current).x = x;
		(*current).y = interY + interH;
		(*current).w = w;
		(*current).h = y + h - interY - interH;
		inc current;
	}
	if(interX > x){
		(*current).x = x;
		(*current).y = interY;
		(*current).w = interX - x;
		(*current).h = interH;
		inc current;
	}
	if(interX + interW < x + w){
		(*current).x = interX + interW;
		(*current).y = interY;
		(*current).w = x + w - interX - interW;
		(*current).h = interH;
		inc current;
	}
	*allocated = current - *rectangle;
	ret;
	emergencyExit:{



		/*! realloc will eventually fail. what do? */



		*size = RECTANGLE_BLOCK_SIZE;
		*allocated = 0;
		free(*rectangle);
		*rectangle = NULL;
		ret;
	}
}
CALCULATEVIEWABLEWINDOWSIZES(){
	uint *belowCurrent = orderedClientOffsetStart - 1;
	uint *offsetWall = orderedClientOffsetStart + clientAllocated;
	jmp resetClientRectangle;
	resetClientRectangle:{
		Client *client = clientStart;
		jmp resetClientRectangleLoop;
		resetClientRectangleLoop:{
			if(client < clientWall){
				Rectangle *rectangle = (*client).rectangle;
				if(rectangle){
					(*rectangle).x = (*client).x;
					(*rectangle).y = (*client).y;
					(*rectangle).w = (*client).w;
					(*rectangle).h = (*client).h;
					(*client).allocated = 1;
				}
				inc client;
				jmp resetClientRectangleLoop;
			}
		}
		jmp belowClientLoop;
	}
	belowClientLoop:{
		if(inc belowCurrent < offsetWall){
			Client *const below = clientStart + *belowCurrent;
			uint *aboveCurrent;



			/*! fprintf(stdout, "%i\n", *belowCurrent); */



			if(*belowCurrent == (uint)-1 or !(*below).mapped){
				jmp belowClientLoop;
			}
			aboveCurrent = belowCurrent;
			jmp aboveClientLoop;
			aboveClientLoop:{
				if(inc aboveCurrent < offsetWall){
					Client *const above = clientStart + *aboveCurrent;
					int x;
					int y;
					int w;
					int h;
					if(*aboveCurrent == (uint)-1 or !(*above).mapped){
						jmp aboveClientLoop;
					}
					if(findIntersectingRectangle((*above).x, (*above).y, (*above).w, (*above).h, (*below).x, (*below).y, (*below).w, (*below).h, &x, &y, &w, &h)){
						Rectangle *rectangle = (*below).rectangle;
						if(rectangle){
							Rectangle *rectangleWall = rectangle + (*below).allocated;
							uint size = RECTANGLE_BLOCK_SIZE;
							uint allocated = 0;
							Rectangle *newRectangle = malloc(size * sizeof(Rectangle));
							if(!newRectangle){
								fprintf(stdout, "\n\n\nproblem1\n\n\n\n");
							}
							jmp splitRectanglesLoop;
							splitRectanglesLoop:{
								if(rectangle < rectangleWall){
									if(findIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).w, (*rectangle).h, (*above).x, (*above).y, (*above).w, (*above).h, &x, &y, &w, &h)){
										splitRectangle((*rectangle).x, (*rectangle).y, (*rectangle).w, (*rectangle).h, x, y, w, h, &size, &allocated, &newRectangle);
									}else{
										if(allocated == size){
											void *temp;
											size += RECTANGLE_BLOCK_SIZE;
											if(!(temp = realloc(newRectangle, size * sizeof(Rectangle)))){
												fprintf(stdout, "\n\n\nproblem2\n\n\n\n");
											}
											newRectangle = temp;
										}
										*(newRectangle + allocated) = *rectangle;
										inc allocated;
									}
									inc rectangle;
									jmp splitRectanglesLoop;
								}
							}
							free((*below).rectangle);
							(*below).size = size;
							(*below).allocated = allocated;
							(*below).rectangle = newRectangle;
						}
					}
					jmp aboveClientLoop;
				}
			}
			jmp belowClientLoop;
		}
	}









	/*!{
		uint *current = orderedClientOffsetStart;
		uint *wall = orderedClientOffsetStart + clientAllocated;
		uint i = 0;
		while(current < wall){
			if(*current != -1){
				Client *client = clientStart + *current;
				if((*client).mapped){
					Rectangle *rectangle = (*client).rectangle;
					Rectangle *wall = (*client).rectangle + (*client).allocated;
					fprintf(stdout, "\tclient %u:\n", i);
					inc i;
					while(rectangle < wall){
						fprintf(stdout, "\t\t%i %i %i %i\n", (*rectangle).x, (*rectangle).y, (*rectangle).w, (*rectangle).h);
						inc rectangle;
					}
				}
			}
			inc current;
		}
		fprintf(stdout, "\n\n\n");
	}*/



	ret;
}
ADDCLIENT(){
	xcb_get_window_attributes_cookie_t attributesCookie;
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_get_window_attributes_reply_t *attributesReply;
	xcb_get_geometry_reply_t *geometryReply;
	Client *client;



	if(window == overlayWindow){
		ret false;
	}
	attributesCookie = xcb_get_window_attributes_unchecked(connection, window);
	geometryCookie = xcb_get_geometry_unchecked(connection, window);
	attributesReply = xcb_wait_for_reply(connection, attributesCookie, NULL);
	geometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
	if(!attributesReply or !geometryReply /*! or (*attributesReply)._class != XCB_WINDOW_CLASS_INPUT_OUTPUT */ ){
		jmp emergencyExit;
	}



	if(clientAllocated == clientSize){
		void *temp;
		void *temp1;
		clientSize += CLIENT_BLOCK_SIZE;
		if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
			jmp emergencyExit;
		}
		clientStart = temp;
		if(!(temp1 = realloc(orderedClientOffsetStart, clientSize * sizeof(uint)))){
			jmp emergencyExit;
		}
		orderedClientOffsetStart = temp1;
	}
	client = clientStart + clientAllocated;



	if(geometryReply){
		(*client).x = (*geometryReply).x;
		(*client).y = (*geometryReply).y;
		(*client).w = (*geometryReply).width;
		(*client).h = (*geometryReply).height;
	}else{
		(*client).x = (*screen).width_in_pixels;
		(*client).y = (*screen).height_in_pixels;
		(*client).w = 0;
		(*client).h = 0;
	}



	(*client).window = window;
	(*client).damage = XCB_NONE;
	(*client).visual = (*attributesReply).visual;
	(*client).format = XCB_NONE;
	(*client).picture = XCB_NONE;

	/*! maybe note that the window is mapped, unmapped or just unviewable */

	(*client).mapped = (*attributesReply).map_state == XCB_MAP_STATE_VIEWABLE;



	(*client).size = RECTANGLE_BLOCK_SIZE;
	(*client).allocated = 0;
	(*client).rectangle = malloc((*client).size * sizeof(Rectangle));



	xcb_change_window_attributes(connection, window, XCB_CW_EVENT_MASK, &windowValueList);



	if((*attributesReply)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
		(*client).damage = xcb_generate_id(connection);
		xcb_damage_create(connection, (*client).damage, window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
	}



	free(attributesReply);
	free(geometryReply);



	inc clientAllocated;
	inc clientWall;
	ret true;



	emergencyExit:{
		free(attributesReply);
		free(geometryReply);
		ret false;
	}
}
QUERYTREE(){
	const xcb_query_tree_cookie_t cookie = xcb_query_tree_unchecked(connection, (*screen).root);
	if(treeReply){
		free(treeReply);
	}
	treeReply = xcb_wait_for_reply(connection, cookie, NULL);
	ret;
}
UPDATEORDER(){
	/*! what if treeReply == NULL */
/*!
	if(treeReply){
		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
		uint *orderedClientOffsetCurrent = orderedClientOffsetStart;
		findClientWindowLoop:{
			xcb_get_window_attributes_reply_t *attributesReply = xcb_wait_for_reply(connection, xcb_get_window_attributes_unchecked(connection, *windowCurrent), NULL);
			if(!attributesReply or (*attributesReply)._class != XCB_WINDOW_CLASS_INPUT_OUTPUT){
				Client *const client = findClient(*windowCurrent);
				if(client){
					*orderedClientOffsetCurrent = client - clientStart;
				}else{
					*orderedClientOffsetCurrent = -1;
					fprintf(stdout, "window not found in update order\n");
				}
			}
			if(inc windowCurrent < windowWall){
				inc orderedClientOffsetCurrent;
				jmp findClientWindowLoop;
			}
		}
	}
*/
	if(treeReply){
		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
		uint *orderedClientOffsetCurrent = orderedClientOffsetStart;
		findClientWindowLoop:{
			Client *const client = findClient(*windowCurrent);
			if(client){
				*orderedClientOffsetCurrent = client - clientStart;
			}else{
				*orderedClientOffsetCurrent = -1;
				/*! fprintf(stdout, "window not found in update order\n"); */
			}
			if(inc windowCurrent < windowWall){
				inc orderedClientOffsetCurrent;
				jmp findClientWindowLoop;
			}
		}
	}
	ret;
}
UNMAPWINDOW(){
	(*client).mapped = false;
	ret;
}
MAPWINDOW(){
	(*client).mapped = true;
	ret;
}



























FINDCLIENT(){
	const uint8 *current = (void *)&(*clientStart).window;
	jmp findClientLoop;
	findClientLoop:{
		if(*(xcb_window_t *)current == window){
			ret (void *)(current - ((uint8 *)&(*clientStart).window - (uint8 *)clientStart));
		}
		if((current += sizeof(Client)) < (uint8 *)clientWall){
			jmp findClientLoop;
		}
		ret NULL;
	}
}
REMOVECLIENT(){
	xcb_damage_destroy(connection, (*client).damage);
	if((*client).picture){
		xcb_render_free_picture(connection, (*client).picture);
	}
	*client = *(clientWall - 1);
	dec clientAllocated;
	dec clientWall;
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		fprintf(errorStream, "%s: %s\n", programName, string);
		closeErrorStream();
	}
	ret;
}
OPENERRORSTREAM(){
	ret !mustOpenErrorStream or (errorStream = fopen(errorPath, "a"));
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		errorStream = NULL;
	}
	ret;
}
PRINTCONNECTIONERROR(){
	if(openErrorStream()){
		#define PRINTCONNECTIONERROR_ERROR /*--*/ xcb_connection_has_error(connection)
		#define PRINTCONNECTIONERROR_STREAM /*-*/ errorStream
		#include "xcb/printConnectionError.hold"
		closeErrorStream();
	}
	ret;
}
PRINTXCBERROR(){
	if(openErrorStream()){
		#define PRINTXCBERROR_ERROR /*--*/ genericError
		#define PRINTXCBERROR_STREAM /*-*/ errorStream
		#include "xcb/printXCBError.hold"
		closeErrorStream();
	}
	ret;
}
