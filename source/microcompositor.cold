/*!
	understand how shapes work.

	vivaldi is shaped, thankfully.
*/

/*!
	check for monitor change issues
*/

/*!
	rectangle splitting can create rectangles that can be combined into one.

	completely ignore it.
*/

/*!
	continue looking for all kinds of possible optimizations
*/

/*!
	update memory management on program close
*/

/*!
	drawBelowClient() is an issue to deal with, but it could be merged with drawCompositeClient() to draw everything in one go to the rootPicture
*/



























/*! microcompositor.cold

MIT License

Copyright (C) 2023 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#include <stdint.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <xcb/composite.h>
	#include <xcb/damage.h>
	#include <xcb/randr.h>
	#include <xcb/render.h>
	#include <xcb/shape.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include "cold/cold.hold"
/*!}*/

/*!user_defines:{*/
	#define DefaultErrorStream /*-------------*/ (stderr)
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------*/ (true)

	#define _EMPTY_MACRO /*----------------------*/

	#define FINDCLIENT() /*----------------------*/ local Client                  *findClient(const xcb_window_t window)
	#define FINDMAPPEDCLIENT() /*----------------*/ local Client                  *findMappedClient(const xcb_window_t window)
	#define UNMAPCLIENT() /*---------------------*/ local void                     unmapClient(Client *const client)
	#define MAPWINDOW() /*-----------------------*/ local void                     mapClient(Client *const client)
	#define ADDCLIENT() /*-----------------------*/ local void                     addClient(const xcb_window_t window)
	#define CONFIGURECLIENT() /*-----------------*/ local void                     configureClient(Client *const client)
	#define SHAPECLIENT() /*---------------------*/ local void                     shapeClient(Client *const client)
	#define QUERYTREE() /*-----------------------*/ local void                     queryTree(void)
	#define UPDATEORDER() /*---------------------*/ local void                     updateOrder(void)
	#define GETINTERSECTINGRECTANGLE() /*--------*/ local bool                     getIntersectingRectangle(int leftX0, int topY0, int width0, int height0, int leftX1, int topY1, int width1, int height1, int *retX, int *retY, int *retW, int *retH)
	#define CALCULATEVIEWABLEWINDOWSIZES() /*----*/ local void                     calculateViewableWindowSizes(void)
	#define SETWALLPAPER() /*--------------------*/ local void                     setWallpaper(void)
	#define CREATEWALLPAPER() /*-----------------*/ local void                     createWallpaper(void)
	#define FINDFORMAT() /*----------------------*/ local xcb_render_pictformat_t  findFormat(const xcb_visualid_t visual, const uint8 depth)
	#define GETCLIENTINTERSECTINGRECTANGLES() /*-*/ local uint                     getClientIntersectingRectangles(const Client *const client, const int leftX0, const int topY0, const int rightX0, const int bottomY0)
	#define DESTROYCLIENT() /*-------------------*/ local void                     destroyClient(Client *const client)
	#define CIRCULATECLIENTS() /*----------------*/ local void                     circulateClients(void)
	#define DAMAGECLIENT() /*--------------------*/ local void                     damageClient(Client *const client)
	#define CREATEROOTPICTURE() /*---------------*/ local void                     createRootPicture(void)
	#define DRAWBELOWCLIENT() /*-----------------*/ local void                     drawBelowClient(const Client *const client, const int eventX, const int eventY, const int eventW, const int eventH)
	#define DRAWALLCLIENTS() /*------------------*/ local void                     drawAllClients(void)
	#define DRAWCOMPOSITECLIENT() /*-------------*/ local void                     drawCompositeClient(const Client *const client, const bool drawBelow, const bool drawAbove, const int x, const int y, const int w, const int h)



	#define PRINTERROR() /*----------------------*/ local void                     printError(const char *const string)
	#define OPENERRORSTREAM() /*-----------------*/ local bool                     openErrorStream(void)
	#define CLOSEERRORSTREAM() /*----------------*/ local void                     closeErrorStream(void)
	#define PRINTCONNECTIONERROR() /*------------*/ local void                     printConnectionError(void)
	#define PRINTXCBERROR() /*-------------------*/ local void                     printXCBError(void)

	#define xcb_wait_for_reply(a, b, c) /*-------*/ (xcb_wait_for_reply(a, (b).sequence, c))

	#define LITERAL_LENGTH(l) /*-----------------*/ (sizeof(l) - 1)

	#define _b(d, b) /*--------------------------*/ (d > (sizeof(#b) - 1)? 0 : ((*(#b + (sizeof(#b) - 1) - d) - 48) == 1) * ((uint64)1 << (d - 1)))

	#define b(b) /*------------------------------*/ ( \
		  _b( 1, b) + _b( 2, b) + _b( 3, b) + _b( 4, b) + _b( 5, b) + _b( 6, b) + _b( 7, b) + _b( 8, b) \
		+ _b( 9, b) + _b(10, b) + _b(11, b) + _b(12, b) + _b(13, b) + _b(14, b) + _b(15, b) + _b(16, b) \
		+ _b(17, b) + _b(18, b) + _b(19, b) + _b(20, b) + _b(21, b) + _b(22, b) + _b(23, b) + _b(24, b) \
		+ _b(25, b) + _b(26, b) + _b(27, b) + _b(28, b) + _b(29, b) + _b(30, b) + _b(31, b) + _b(32, b) \
		+ _b(33, b) + _b(34, b) + _b(35, b) + _b(36, b) + _b(37, b) + _b(38, b) + _b(39, b) + _b(40, b) \
		+ _b(41, b) + _b(42, b) + _b(43, b) + _b(44, b) + _b(45, b) + _b(46, b) + _b(47, b) + _b(48, b) \
		+ _b(49, b) + _b(50, b) + _b(51, b) + _b(52, b) + _b(53, b) + _b(54, b) + _b(55, b) + _b(56, b) \
		+ _b(57, b) + _b(58, b) + _b(59, b) + _b(60, b) + _b(61, b) + _b(62, b) + _b(63, b) + _b(64, b) \
	)

	#define VISUAL_FORMAT_PAIR_BLOCK_SIZE /*-----*/ (4)
	#define RECTANGLE_BLOCK_SIZE /*--------------*/ (8)
	#define CLIENT_BLOCK_SIZE /*-----------------*/ (128)
	#define ABOVE_CLIENT_BLOCK_SIZE /*-----------*/ (8)
	#define BELOW_CLIENT_BLOCK_SIZE /*-----------*/ (8)

	#define NONE_MAP_INFO /*---------------------*/ (0)
	#define MAPPED_MAP_INFO /*-------------------*/ (1 << 0)
	#define VIEWABLE_MAP_INFO /*-----------------*/ (1 << 1)
/*!}*/

/*!defs:{*/
	def struct Client Client;

	struct Client{
		uint32 /*------------------*/ size;
		uint32 /*------------------*/ allocated;
		xcb_rectangle_t * /*-------*/ rectangle;

		xcb_window_t /*------------*/ window;
		xcb_damage_damage_t /*-----*/ damage;
		xcb_render_pictformat_t /*-*/ format;
		xcb_render_picture_t /*----*/ picture;

		uint32 /*------------------*/ aboveClientSize;
		uint32 /*------------------*/ aboveClientAllocated;
		Client ** /*---------------*/ aboveClientStart;

		uint32 /*------------------*/ belowClientSize;
		uint32 /*------------------*/ belowClientAllocated;
		Client ** /*---------------*/ belowClientStart;

		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		int32 /*-------------------*/ w;
		int32 /*-------------------*/ h;
		int32 /*-------------------*/ rightX;
		int32 /*-------------------*/ bottomY;

		bool /*--------------------*/ shaped;
		uint8 /*-------------------*/ mapInfo;
		uint8 /*-------------------*/ pictureOperation;
		bool /*--------------------*/ useSpecialEffect;
	};

	def struct{
		uint16 /*------------------*/ x;
		uint16 /*------------------*/ y;
		uint16 /*------------------*/ w;
		uint16 /*------------------*/ h;
	} Monitor;
/*!}*/

/*!globals:{*/
	const char * /*----------*/ programName;
	const char * /*----------*/ errorPath;
	const char * /*----------*/ connectionName;
	const xcb_screen_t * /*--*/ screen;
	const char * /*----------*/ quitMessage;
	bool /*------------------*/ mustOpenErrorStream;
	FILE * /*----------------*/ errorStream;
	xcb_connection_t * /*----*/ connection;
	xcb_generic_error_t * /*-*/ genericError;
	xcb_generic_event_t * /*-*/ event0;



	const uint32 windowValueList = XCB_EVENT_MASK_VISIBILITY_CHANGE;
	uint compositeBaseEvent;
	uint compositeBaseError;
	uint damageBaseEvent;
	uint damageBaseError;
	uint renderBaseEvent;
	uint renderBaseError;
	uint randrBaseEvent;
	uint randrBaseError;
	uint xfixesBaseEvent;
	uint xfixesBaseError;
	uint shapeBaseEvent;
	uint shapeBaseError;



	xcb_atom_t              pixmapAtom;
	xcb_atom_t              rootPixmapAtom;
	xcb_pixmap_t            wallpaperPixmap;
	xcb_render_picture_t    wallpaperPicture;
	xcb_render_picture_t    rootPicture;



	xcb_pixmap_t            bufferPixmap;
	xcb_render_picture_t    bufferPicture;



	uint visualSize;
	uint visualAllocated;
	xcb_render_pictvisual_t *visualStart;
	xcb_render_pictvisual_t *visualWall;
	xcb_render_pictformat_t defaultOpaqueFormat;
	xcb_render_pictformat_t defaultTransparentFormat;



	uint clientSize;
	uint clientAllocated;
	uint orderedMappedClientAllocated;
	Client *clientStart;
	Client *clientWall;
	Client *lastClient;
	uint *orderedMappedClientOffsetStart;
	uint *orderedMappedClientOffsetWall;



	uint monitorAmount;
	void *monitorData;
	Monitor *monitorStart;
	Monitor *monitorWall;



	xcb_window_t overlayWindow;
	xcb_rectangle_t *rectangleStart;
	xcb_rectangle_t *rectangleStart1;
	xcb_query_tree_reply_t *treeReply;
/*!}*/

/*!functions:{*/
	FINDCLIENT();
	FINDMAPPEDCLIENT();
	UNMAPCLIENT();
	DRAWBELOWCLIENT();
	MAPWINDOW();
	ADDCLIENT();
	QUERYTREE();
	UPDATEORDER();
	GETINTERSECTINGRECTANGLE();
	CALCULATEVIEWABLEWINDOWSIZES();
	SETWALLPAPER();
	CREATEWALLPAPER();
	FINDFORMAT();
	CONFIGURECLIENT();
	SHAPECLIENT();
	GETCLIENTINTERSECTINGRECTANGLES();
	DRAWALLCLIENTS();
	DESTROYCLIENT();
	CIRCULATECLIENTS();
	DAMAGECLIENT();
	CREATEROOTPICTURE();
	DRAWCOMPOSITECLIENT();

	PRINTERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
	PRINTCONNECTIONERROR();
	PRINTXCBERROR();
/*!}*/

int main(const int argumentAmount, const char *const *argument){
	(void)argumentAmount;
	jmp setPrimaryGlobals;
	setPrimaryGlobals:{
		programName /*-----------*/ = *argument;
		errorPath /*-------------*/ = NULL;
		connectionName /*--------*/ = NULL;
		mustOpenErrorStream /*---*/ = false;
		errorStream /*-----------*/ = DefaultErrorStream;
		connection /*------------*/ = NULL;
		genericError /*----------*/ = NULL;
		event0 /*----------------*/ = NULL;
		quitMessage /*-----------*/ = NULL;
		treeReply /*-------------*/ = NULL;

		rectangleStart /*--------*/ = NULL;
		clientSize /*------------*/ = CLIENT_BLOCK_SIZE;
		clientAllocated /*-------*/ = 0;
		orderedMappedClientAllocated /*-*/ = 0;

		rootPicture /*-----------*/ = XCB_NONE;

		wallpaperPixmap /*-------*/ = XCB_NONE;
		wallpaperPicture /*------*/ = XCB_NONE;

		bufferPixmap /*----------*/ = XCB_NONE;
		bufferPicture /*---------*/ = XCB_NONE;

		jmp establishServerConnection;
	}
	establishServerConnection:{
		#define ESTABLISHSERVERCONNECTION_CONNECTION /*-----*/ connection
		#define ESTABLISHSERVERCONNECTION_CONNECTIONNAME /*-*/ connectionName
		#define ESTABLISHSERVERCONNECTION_SCREEN /*---------*/ screen
		#include "xcb/establishServerConnection.hold"
		switch xcb_connection_has_error(connection) over
			to XCB_NONE: /*------------*/ /*-----------------------------------------------------------------*/ brk;
			to XCB_CONN_CLOSED_PARSE_ERR: printError(connectionName? "invalid server name" : "no server name"); jmp mainEmergencyExit;
			off: /*--------------------*/ printConnectionError(); /*-----------------------------------------*/ jmp mainEmergencyExit;
		end
	}



	{
		xcb_grab_server(connection);
	}



	compositeBaseEvent = 0;
	compositeBaseError = 0;
	damageBaseEvent = 0;
	damageBaseError = 0;
	renderBaseEvent = 0;
	renderBaseError = 0;
	randrBaseEvent = 0;
	randrBaseError = 0;
	xfixesBaseEvent = 0;
	xfixesBaseError = 0;
	shapeBaseEvent = 0;
	shapeBaseError = 0;
	{
		const xcb_query_extension_cookie_t compositeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("Composite"), "Composite");
		const xcb_query_extension_cookie_t damageCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("DAMAGE"), "DAMAGE");
		const xcb_query_extension_cookie_t randrCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RANDR"), "RANDR");
		const xcb_query_extension_cookie_t renderCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RENDER"), "RENDER");
		const xcb_query_extension_cookie_t xfixesCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("XFIXES"), "XFIXES");
		const xcb_query_extension_cookie_t shapeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("SHAPE"), "SHAPE");
		xcb_query_extension_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_query_extension_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_query_extension_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_query_extension_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_query_extension_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_query_extension_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(!compositeReply or !(*compositeReply).present){
			fprintf(stdout, "composite extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_composite_id);
			if(reply and (*reply).present){
				compositeBaseEvent = (*reply).first_event;
				compositeBaseError = (*reply).first_error;
			}
			free(compositeReply);
		}
		if(!damageReply or !(*damageReply).present){
			fprintf(stdout, "damage extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_damage_id);
			if(reply and (*reply).present){
				damageBaseEvent = (*reply).first_event;
				damageBaseError = (*reply).first_error;
			}
			free(damageReply);
		}
		if(!randrReply or !(*randrReply).present){
			fprintf(stdout, "randr extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_randr_id);
			if(reply and (*reply).present){
				randrBaseEvent = (*reply).first_event;
				randrBaseError = (*reply).first_error;
			}
			free(randrReply);
		}
		if(!renderReply or !(*renderReply).present){
			fprintf(stdout, "render extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_render_id);
			if(reply and (*reply).present){
				renderBaseEvent = (*reply).first_event;
				renderBaseError = (*reply).first_error;
			}
			free(renderReply);
		}
		if(!xfixesReply or !(*xfixesReply).present){
			fprintf(stdout, "xfixes extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_xfixes_id);
			if(reply and (*reply).present){
				xfixesBaseEvent = (*reply).first_event;
				xfixesBaseError = (*reply).first_error;
			}
			free(xfixesReply);
		}
		if(!shapeReply or !(*shapeReply).present){
			fprintf(stdout, "shape extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_shape_id);
			if(reply and (*reply).present){
				shapeBaseEvent = (*reply).first_event;
				shapeBaseError = (*reply).first_error;
			}
			free(shapeReply);
		}
	}
	{
		const xcb_damage_query_version_cookie_t compositeCookie = xcb_damage_query_version_unchecked(connection, XCB_COMPOSITE_MAJOR_VERSION, XCB_COMPOSITE_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t damageCookie = xcb_damage_query_version_unchecked(connection, XCB_DAMAGE_MAJOR_VERSION, XCB_DAMAGE_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t renderCookie = xcb_damage_query_version_unchecked(connection, XCB_RENDER_MAJOR_VERSION, XCB_RENDER_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t randrCookie = xcb_damage_query_version_unchecked(connection, XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
		const xcb_xfixes_query_version_cookie_t xfixesCookie = xcb_xfixes_query_version_unchecked(connection, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION);
		const xcb_xfixes_query_version_cookie_t shapeCookie = xcb_xfixes_query_version_unchecked(connection, XCB_SHAPE_MAJOR_VERSION, XCB_SHAPE_MINOR_VERSION);
		xcb_damage_query_version_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_damage_query_version_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_damage_query_version_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_damage_query_version_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_xfixes_query_version_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_xfixes_query_version_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(compositeReply){
			free(compositeReply);
		}else{
			fprintf(stdout, "%s: could not query composite extension\n", programName);
		}
		if(damageReply){
			free(damageReply);
		}else{
			fprintf(stdout, "%s: could not query damage extension\n", programName);
		}
		if(renderReply){
			free(renderReply);
		}else{
			fprintf(stdout, "%s: could not query render extension\n", programName);
		}
		if(randrReply){
			free(randrReply);
		}else{
			fprintf(stdout, "%s: could not query randr extension\n", programName);
		}
		if(xfixesReply){
			free(xfixesReply);
		}else{
			fprintf(stdout, "%s: could not query xfixes extension\n", programName);
		}
		if(shapeReply){
			free(shapeReply);
		}else{
			fprintf(stdout, "%s: could not query shape extension\n", programName);
		}
	}



	{
		const uint32 stackMode = XCB_STACK_MODE_BELOW;
		xcb_composite_get_overlay_window_reply_t *const overlay = xcb_wait_for_reply(connection, xcb_composite_get_overlay_window_unchecked(connection, (*screen).root), NULL);
		if(overlay){
			overlayWindow = (*overlay).overlay_win;
			free(overlay);
		}
		xcb_configure_window(connection, overlayWindow, XCB_CONFIG_WINDOW_STACK_MODE, &stackMode);
	}



	{
		xcb_intern_atom_reply_t *reply;
		pixmapAtom = XCB_NONE;
		if((reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("PIXMAP"), "PIXMAP"), NULL))){
			pixmapAtom = (*reply).atom;
			free(reply);
		}
		rootPixmapAtom = XCB_NONE;
		if((reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("_XROOTPMAP_ID"), "_XROOTPMAP_ID"), NULL))){
			rootPixmapAtom = (*reply).atom;
			free(reply);
		}
	}



	{
		xcb_composite_redirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}



	jmp storeMonitors;
	storeMonitors:{
		void *reply;
		Monitor *monitorCurrent;
		xcb_randr_monitor_info_iterator_t iterator;
		if(!(reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL))){
			monitorAmount = 1;
			jmp storeMonitorsExit;
		}
		monitorAmount = (*(xcb_randr_get_monitors_reply_t *)reply).nMonitors;
		if(!(monitorData = malloc(monitorAmount * sizeof(Monitor)))){
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorStart = monitorData;
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAmount;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const uint x = (*data).x;
				const uint y = (*data).y;
				const uint w = (*data).width;
				const uint h = (*data).height;
				if(monitorCurrent > monitorStart){
					const Monitor *const wall = monitorCurrent;
					const Monitor *current = monitorStart;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).x == x and (*current).y == y and (*current).w == w and (*current).h == h){
								dec monitorAmount;
								dec monitorWall;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).x = x;
				(*monitorCurrent).y = y;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				xcb_randr_monitor_info_next(&iterator);
				inc monitorCurrent;
				jmp storeMonitorLoop;
			}
			jmp trimMonitorMemory;
		}
		trimMonitorMemory:{
			void *temp;
			if(!(temp = realloc(monitorData, monitorAmount * sizeof(Monitor)))){
				free(reply);
				jmp storeMonitorsExit;
			}
			monitorData = temp;
		}
		monitorStart = monitorData;
		monitorWall = monitorStart + monitorAmount;
		free(reply);
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{}



	{
		if(!(clientStart = malloc(clientSize * sizeof(Client)))){
			fprintf(stdout, "no clientStart\n");
		}
		clientWall = clientStart + clientAllocated;



		if(!(orderedMappedClientOffsetStart = malloc(clientSize * sizeof(uint)))){
			fprintf(stdout, "no orderedMappedClientOffsetStart\n");
		}
		orderedMappedClientOffsetWall = orderedMappedClientOffsetStart + orderedMappedClientAllocated;



		/*! gotta fix this, for real */

		if(!(rectangleStart = malloc(1024 * sizeof(xcb_rectangle_t)))){
			fprintf(stdout, "no rectangleStart\n");
		}
		if(!(rectangleStart1 = malloc(1024 * sizeof(xcb_rectangle_t)))){
			fprintf(stdout, "no rectangleStart1\n");
		}



		visualSize = VISUAL_FORMAT_PAIR_BLOCK_SIZE;
		visualAllocated = 0;
		if(!(visualStart = malloc(visualSize * sizeof(xcb_render_pictvisual_t)))){
			fprintf(stdout, "no visualStart\n");
			visualSize = 0;
		}
		defaultOpaqueFormat = XCB_NONE;
		defaultTransparentFormat = XCB_NONE;
		jmp matchVisualFormat;
	}
	matchVisualFormat:{
		xcb_render_query_pict_formats_reply_t *const formats = xcb_wait_for_reply(connection, xcb_render_query_pict_formats_unchecked(connection), NULL);
		if(formats){
			xcb_render_pictscreen_iterator_t pictscreenIterator = xcb_render_query_pict_formats_screens_iterator(formats);
			xcb_render_pictvisual_t *visualCurrent = visualStart;
			jmp iterateScreensLoop;
			iterateScreensLoop:{
				if(pictscreenIterator.rem){
					xcb_render_pictdepth_iterator_t pictdepth = xcb_render_pictscreen_depths_iterator(pictscreenIterator.data);
					jmp iterateDepthsLoop;
					iterateDepthsLoop:{
						if(pictdepth.rem){
							xcb_render_pictvisual_t *const pictvisual = xcb_render_pictdepth_visuals(pictdepth.data);
							if(visualAllocated == visualSize){
								void *temp;
								visualSize += VISUAL_FORMAT_PAIR_BLOCK_SIZE;
								if(!(temp = realloc(visualStart, visualSize * sizeof(xcb_rectangle_t)))){
									jmp matchVisualFormatExit;
								}
								visualStart = temp;
							}
							if((*pictvisual).visual and (*pictvisual).format){
								*visualCurrent = *pictvisual;
								switch (*pictdepth.data).depth over
									to 24:{
										if(!defaultOpaqueFormat){
											defaultOpaqueFormat = (*visualCurrent).format;
										}
										brk;
									}
									to 32:{
										if(!defaultTransparentFormat){
											defaultTransparentFormat = (*visualCurrent).format;
										}
										brk;
									}
									off:{
										brk;
									}
								end
								inc visualCurrent;
								inc visualAllocated;
							}
							xcb_render_pictdepth_next(&pictdepth);
							jmp iterateDepthsLoop;
						}
					}
					xcb_render_pictscreen_next(&pictscreenIterator);
					jmp iterateScreensLoop;
				}
			}
			free(formats);
		}
		jmp matchVisualFormatExit;
	}
	matchVisualFormatExit:{
		visualWall = visualStart + visualAllocated;
	}



	{
		const uint32 valueList = XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_change_window_attributes(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		xcb_shape_select_input(connection, (*screen).root, true);
	}



	{
		lastClient = NULL;
		queryTree();
		if(treeReply){
			const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
			const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
			addClient((*screen).root);
			addExistingClientLoop:{
				addClient(*windowCurrent);
				if(inc windowCurrent < windowWall){
					jmp addExistingClientLoop;
				}
			}
		}
		calculateViewableWindowSizes();
	}



	{
		createRootPicture();
		createWallpaper();
		setWallpaper();
	}



	{
		drawAllClients();
	}


	{
		xcb_ungrab_server(connection);
	}









	eventLoop:{
		xcb_flush(connection);
		free(event0);
		event0 = NULL;
		jmp waitForEventLoop;
	}
	waitForEventLoop:{
		if((event0 = xcb_wait_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		jmp eventLoop;
	}
	switchEvents:{
		#define XCB_ONE /*-*/ (1)
		switch (*event0).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unexpectedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp unexpectedEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp unexpectedEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp unexpectedEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp unexpectedEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;

			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
#ifdef a
			to XCB_VISIBILITY_NOTIFY: /*-*/ fprintf(stdout, "visibility notify\n"); jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ fprintf(stdout, "create notify\n"); jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ fprintf(stdout, "destroy notify\n"); jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ fprintf(stdout, "unmap notify\n"); jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ fprintf(stdout, "map notify\n"); jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ fprintf(stdout, "reparent notify\n"); jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ fprintf(stdout, "configure notify\n"); jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ fprintf(stdout, "circulate notify\n"); jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ fprintf(stdout, "property notify\n"); jmp propertyNotifyEvent;
#endif
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp unexpectedEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	extensionEvent:{
		if(((*event0).response_type & ~b(10000000)) == damageBaseEvent + XCB_DAMAGE_NOTIFY){
			jmp damageNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseEvent + XCB_RANDR_SCREEN_CHANGE_NOTIFY){
			jmp randrNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == shapeBaseEvent + XCB_SHAPE_NOTIFY){
			jmp shapeNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == damageBaseError + XCB_DAMAGE_BAD_DAMAGE){
			jmp damageNotifyError;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseError){
			jmp randrNotifyError;
		}
		if(((*event0).response_type & ~b(10000000)) == shapeBaseError){
			jmp shapeNotifyError;
		}
		jmp unexpectedEvent;
	}
	visibilityNotifyEvent:{
		#define event0 /*-*/ ((xcb_visibility_notify_event_t *)event0)
		Client *client;
		if((client = findClient((*event0).window))){
			if((*event0).state != XCB_VISIBILITY_FULLY_OBSCURED){
				mapClient(client);
				jmp eventLoop;
			}
			unmapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	createNotifyEvent:{
		#define event0 /*-*/ ((xcb_create_notify_event_t *)event0)
		Client *client;
		queryTree();
		if(!(client = findClient((*event0).window))){
			addClient((*event0).window);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	destroyNotifyEvent:{
		#define event0 /*-*/ ((xcb_destroy_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((client = findClient((*event0).window))){
			destroyClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	unmapNotifyEvent:{
		#define event0 /*-*/ ((xcb_unmap_notify_event_t *)event0)
		Client *client;
		if((client = findMappedClient((*event0).window))){
			unmapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	mapNotifyEvent:{
		#define event0 /*-*/ ((xcb_map_notify_event_t *)event0)
		Client *client;
		if((client = findClient((*event0).window))){
			mapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	reparentNotifyEvent:{
		#define event0 /*-*/ ((xcb_reparent_notify_event_t *)event0)
		Client *client;
		queryTree();
		client = findClient((*event0).window);
		if((*event0).parent == (*screen).root){
			if(!client){
				addClient((*event0).window);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(client){
			destroyClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	configureNotifyEvent:{
		#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((client = findMappedClient((*event0).window))){
			configureClient(client);
			jmp eventLoop;
		}
		if((client = findClient((*event0).window))){
			configureClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	circulateNotifyEvent:{
		#define event0 /*-*/ ((xcb_circulate_notify_event_t *)event0)
		queryTree();
		circulateClients();
		jmp eventLoop;
		#undef  event0
	}
	propertyNotifyEvent:{
		#define event0 /*-*/ ((xcb_property_notify_event_t *)event0)
		if((*event0).atom == rootPixmapAtom and rootPixmapAtom){
			setWallpaper();
			drawCompositeClient(clientStart, (*clientStart).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, (*clientStart).x, (*clientStart).y, (*clientStart).w, (*clientStart).h);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	damageNotifyEvent:{
		#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
		Client *client;
		if((client = findMappedClient((*event0).drawable))){
			damageClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	randrNotifyEvent:{
		fprintf(stdout, "%s: randr notify event\n", programName);
		(*clientStart).w = (*screen).width_in_pixels;
		(*clientStart).h = (*screen).height_in_pixels;
		(*clientStart).rightX = (*clientStart).x + (*clientStart).w;
		(*clientStart).bottomY = (*clientStart).y + (*clientStart).h;
		calculateViewableWindowSizes();
		createRootPicture();
		createWallpaper();
		setWallpaper();
		drawCompositeClient(clientStart, (*clientStart).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, (*clientStart).x, (*clientStart).y, (*clientStart).w, (*clientStart).h);
		jmp eventLoop;
	}
	shapeNotifyEvent:{
		#define event0 /*-*/ ((xcb_shape_notify_event_t *)event0)
		Client *client;
		if((client = findClient((*event0).affected_window))){
			shapeClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	damageNotifyError:{
		fprintf(stdout, "%s: bad damage error\n", programName);
		jmp eventLoop;
	}
	randrNotifyError:{
		fprintf(stdout, "%s: randr notify error\n", programName);
		jmp eventLoop;
	}
	shapeNotifyError:{
		fprintf(stdout, "%s: shape notify error\n", programName);
		jmp eventLoop;
	}
	errorEvent:{
		genericError = (void *)event0;
		printXCBError();
		genericError = NULL;
		jmp eventLoop;
	}
	unexpectedEvent:{
		jmp eventLoop;
	}
	eventLoopExit:{
		free(event0);
		event0 = NULL;
		jmp mainEmergencyExit;
	}
	mainEmergencyExit:{



		free(visualStart);
		free(clientStart);

		xcb_render_free_picture(connection, wallpaperPicture);
		xcb_free_pixmap(connection, wallpaperPixmap);

		xcb_render_free_picture(connection, rootPicture);
		xcb_render_free_picture(connection, bufferPicture);
		xcb_free_pixmap(connection, bufferPixmap);

		xcb_composite_unredirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);



		xcb_disconnect(connection);
		ret 0;
	}
}
MAPWINDOW(){
	(*client).mapInfo |= MAPPED_MAP_INFO;
	if(!(*client).picture){
		(*client).picture = xcb_generate_id(connection);
		xcb_render_create_picture_checked(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL); /*! annoying on discord tray window create, match error */
	}
	updateOrder();
	calculateViewableWindowSizes();
	drawCompositeClient(client, (*client).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, (*client).x, (*client).y, (*client).w, (*client).h);
	ret;
}
UNMAPCLIENT(){
	if((*client).mapInfo & MAPPED_MAP_INFO){
		(*client).mapInfo &= ~MAPPED_MAP_INFO;
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on discord tray icon window delete */
			(*client).picture = XCB_NONE;
		}
		updateOrder();
		calculateViewableWindowSizes();
		drawBelowClient(client, (*client).x, (*client).y, (*client).w, (*client).h);



		/*!
			this was supposed to, in a very cheaty-feeling manner, keep the clients we must draw above and below and then drawn them, as the only thing that realistically has to be done here is that,
			using the unchanged x, y, w, h values for everything.
		*/

		/*!
			{
				Client temp = *client;
				{
					xcb_rectangle_t *rectangle = malloc(temp.size * sizeof(xcb_rectangle_t));
					xcb_rectangle_t *rectangleCurrent1 = (*client).rectangle;
					xcb_rectangle_t *rectangleCurrent = rectangle;
					xcb_rectangle_t *rectangleWall = rectangle + temp.allocated;
					while(rectangleCurrent < rectangleWall){
						*rectangleCurrent = *rectangleCurrent1;
						inc rectangleCurrent;
						inc rectangleCurrent1;
					}
					temp.rectangle = rectangle;
				}
				{
					Client **belowClientStart = malloc(temp.belowClientSize * sizeof(Client *));
					Client **belowClientCurrent1 = (*client).belowClientStart;
					Client **belowClientCurrent = belowClientStart;
					Client **belowClientWall = belowClientStart + temp.belowClientAllocated;
					while(belowClientCurrent < belowClientWall){
						*belowClientCurrent = *belowClientCurrent1;
						inc belowClientCurrent;
						inc belowClientCurrent1;
					}
					temp.belowClientStart = belowClientStart;
				}
				{
					Client **aboveClientStart = malloc(temp.aboveClientSize * sizeof(Client *));
					Client **aboveClientCurrent1 = (*client).aboveClientStart;
					Client **aboveClientCurrent = aboveClientStart;
					Client **aboveClientWall = aboveClientStart + temp.aboveClientAllocated;
					while(aboveClientCurrent < aboveClientWall){
						*aboveClientCurrent = *aboveClientCurrent1;
						inc aboveClientCurrent;
						inc aboveClientCurrent1;
					}
					temp.aboveClientStart = aboveClientStart;
				}



				updateOrder();
				calculateViewableWindowSizes();



				drawCompositeClient(&temp, temp.pictureOperation != XCB_RENDER_PICT_OP_SRC, true, temp.x, temp.y, temp.w, temp.h);



				free(temp.rectangle);
				free(temp.belowClientStart);
				free(temp.aboveClientStart);
			}
		*/



		/*!
			the root window doesn't properly get its picture composited when drawCompositeClient() is used.
		*/

		/*! drawCompositeClient(client, (*client).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, (*client).x, (*client).y, (*client).w, (*client).h); */
	}
	ret;
}



























ADDCLIENT(){
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_get_window_attributes_cookie_t attributesCookie;
	xcb_get_geometry_reply_t *geometryReply;
	xcb_get_window_attributes_reply_t *attributesReply;
	Client *client;
	uint8 depth;
	if(window == overlayWindow){
		ret;
	}
	geometryReply = NULL;
	attributesReply = NULL;



	/*! update this hole-of-the-earth-looking piece of work */



	if(window != (*screen).root){
		attributesCookie = xcb_get_window_attributes_unchecked(connection, window);
		geometryCookie = xcb_get_geometry_unchecked(connection, window);
	}

	if(clientAllocated == clientSize){
		void *temp;
		void *temp1;
		clientSize += CLIENT_BLOCK_SIZE;
		if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
			jmp emergencyExit;
		}
		clientStart = temp;
		lastClient = NULL;
		if(!(temp1 = realloc(orderedMappedClientOffsetStart, clientSize * sizeof(uint)))){
			jmp emergencyExit;
		}
		orderedMappedClientOffsetStart = temp1;
	}
	clientWall = clientStart + clientAllocated;
	orderedMappedClientOffsetWall = orderedMappedClientOffsetStart + orderedMappedClientAllocated;

	client = clientWall;



	if(window == (*screen).root){
		(*client).size = RECTANGLE_BLOCK_SIZE;
		(*client).allocated = 0;
		(*client).rectangle = malloc((*client).size * sizeof(xcb_rectangle_t));
		if(!(*client).rectangle){
			(*client).size = 0;
		}

		(*client).aboveClientSize = ABOVE_CLIENT_BLOCK_SIZE;
		(*client).aboveClientAllocated = 0;
		(*client).aboveClientStart = malloc((*client).aboveClientSize * sizeof(Client *));
		if(!(*client).aboveClientStart){
			(*client).aboveClientSize = 0;
		}

		(*client).belowClientSize = BELOW_CLIENT_BLOCK_SIZE;
		(*client).belowClientAllocated = 0;
		(*client).belowClientStart = malloc((*client).belowClientSize * sizeof(Client *));
		if(!(*client).belowClientStart){
			(*client).belowClientSize = 0;
		}

		(*client).window = (*screen).root;
		(*client).damage = XCB_NONE;
		(*client).format = findFormat((*screen).root_visual, (*screen).root_depth);
		(*client).picture = wallpaperPicture;

		(*client).x = 0;
		(*client).y = 0;
		(*client).w = (*screen).width_in_pixels;
		(*client).h = (*screen).height_in_pixels;
		(*client).rightX = (*client).x + (*client).w;
		(*client).bottomY = (*client).y + (*client).h;

		(*client).shaped = false;
		(*client).mapInfo = MAPPED_MAP_INFO | VIEWABLE_MAP_INFO;
		depth = (*screen).root_depth;
		(*client).pictureOperation = depth == 24? XCB_RENDER_PICT_OP_SRC : XCB_RENDER_PICT_OP_OVER;
		(*client).useSpecialEffect = false;

		*orderedMappedClientOffsetWall = client - clientStart;
		inc orderedMappedClientAllocated;
		inc orderedMappedClientOffsetWall;

		jmp emergencyExit;
	}



	(*client).size = RECTANGLE_BLOCK_SIZE;
	(*client).allocated = 0;
	(*client).rectangle = malloc((*client).size * sizeof(xcb_rectangle_t));
	if(!(*client).rectangle){
		(*client).size = 0;
	}

	(*client).aboveClientSize = ABOVE_CLIENT_BLOCK_SIZE;
	(*client).aboveClientAllocated = 0;
	(*client).aboveClientStart = malloc((*client).aboveClientSize * sizeof(Client *));
	if(!(*client).aboveClientStart){
		(*client).aboveClientSize = 0;
	}

	(*client).belowClientSize = BELOW_CLIENT_BLOCK_SIZE;
	(*client).belowClientAllocated = 0;
	(*client).belowClientStart = malloc((*client).belowClientSize * sizeof(Client *));
	if(!(*client).belowClientStart){
		(*client).belowClientSize = 0;
	}

	(*client).window = window;
	(*client).damage = XCB_NONE;
	(*client).picture = XCB_NONE;

	geometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
	attributesReply = xcb_wait_for_reply(connection, attributesCookie, NULL);

	if(geometryReply){
		if(attributesReply){
			(*client).format = findFormat((*attributesReply).visual, (*geometryReply).depth);
		}else{
			(*client).format = defaultOpaqueFormat;
		}

		(*client).x = (*geometryReply).x;
		(*client).y = (*geometryReply).y;
		(*client).w = (*geometryReply).width + 2 * (*geometryReply).border_width;
		(*client).h = (*geometryReply).height + 2 * (*geometryReply).border_width;

		depth = (*geometryReply).depth;
	}else{
		if(attributesReply){
			(*client).format = findFormat((*attributesReply).visual, (*geometryReply).depth);
		}else{
			(*client).format = defaultOpaqueFormat;
		}

		(*client).x = (*screen).width_in_pixels;
		(*client).y = (*screen).height_in_pixels;
		(*client).w = 0;
		(*client).h = 0;

		depth = 24;
	}
	(*client).rightX = (*client).x + (*client).w;
	(*client).bottomY = (*client).y + (*client).h;

	(*client).shaped = false;
	(*client).mapInfo = NONE_MAP_INFO;
	(*client).pictureOperation = depth == 24? XCB_RENDER_PICT_OP_SRC : XCB_RENDER_PICT_OP_OVER;
	(*client).useSpecialEffect = false;



	if(!((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels)){
		(*client).mapInfo |= VIEWABLE_MAP_INFO;
	}
	if(attributesReply){
		if((*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED){
			(*client).mapInfo |= MAPPED_MAP_INFO;
			*orderedMappedClientOffsetWall = client - clientStart;
			inc orderedMappedClientAllocated;
			inc orderedMappedClientOffsetWall;
		}
		if((*attributesReply)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
			xcb_change_window_attributes(connection, window, XCB_CW_EVENT_MASK, &windowValueList);
			xcb_shape_select_input(connection, window, true);
			(*client).damage = xcb_generate_id(connection);
			xcb_damage_create(connection, (*client).damage, window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
			if((*client).mapInfo & MAPPED_MAP_INFO){
				(*client).picture = xcb_generate_id(connection);
				xcb_render_create_picture(connection, (*client).picture, window, (*client).format, XCB_NONE, NULL);
			}
		}
	}



	jmp emergencyExit;
	emergencyExit:{
		inc clientAllocated;
		clientWall = clientStart + clientAllocated;
		orderedMappedClientOffsetWall = orderedMappedClientOffsetStart + orderedMappedClientAllocated;
		free(geometryReply);
		free(attributesReply);
		ret;
	}
}
DESTROYCLIENT(){
	unmapClient(client);
	{
		if(client == lastClient){
			lastClient = NULL;
		}
		if((*client).damage){
			xcb_damage_destroy_checked(connection, (*client).damage); /*! annoying on window deleting */
		}
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on window deleting */
		}
		*client = *(dec clientWall);
		dec clientAllocated;
	}
	updateOrder();
	ret;
}
CONFIGURECLIENT(){
	#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
	const int x = (*client).x;
	const int y = (*client).y;
	const int w = (*client).w;
	const int h = (*client).h;
	jmp configureClient;
	configureClient:{
		(*client).x = (*event0).x;
		(*client).y = (*event0).y;
		(*client).w = (*event0).width + 2 * (*event0).border_width;
		(*client).h = (*event0).height + 2 * (*event0).border_width;
		(*client).rightX = (*client).x + (*client).w;
		(*client).bottomY = (*client).y + (*client).h;
		(*client).mapInfo &= ~VIEWABLE_MAP_INFO;
		if(!((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels)){
			(*client).mapInfo |= VIEWABLE_MAP_INFO;
		}
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on window delete */
			(*client).picture = xcb_generate_id(connection);
			xcb_render_create_picture_checked(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL); /*! annoying on window delete */
		}
	}
	updateOrder();
	if((*client).mapInfo & MAPPED_MAP_INFO){
		calculateViewableWindowSizes();



		drawBelowClient(client, x, y, w, h);



		/*! what do here to fix problem? */



		/*! drawCompositeClient(client, (*client).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, x, y, w, h); */



		drawCompositeClient(client, (*client).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, (*client).x, (*client).y, (*client).w, (*client).h);
	}
	ret;
	#undef  event0
}
CIRCULATECLIENTS(){
	updateOrder();
	calculateViewableWindowSizes();
	drawAllClients();
	ret;
}
DAMAGECLIENT(){
	#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
	xcb_damage_subtract(connection, (*client).damage, XCB_NONE, XCB_NONE);
	if((*client).mapInfo & VIEWABLE_MAP_INFO and (*client).allocated){
		const xcb_rectangle_t *const geometry = &(*event0).geometry;
		drawCompositeClient(client, (*client).pictureOperation != XCB_RENDER_PICT_OP_SRC, true, (*geometry).x, (*geometry).y, (*geometry).width, (*geometry).height);
	}
	ret;
	#undef  event0
}
SHAPECLIENT(){
	#define event0 /*-*/ ((xcb_shape_notify_event_t *)event0)
	(void)client;



	fprintf(stdout, "shaped\n");



	switch (*event0).shape_kind over
		to XCB_SHAPE_SK_BOUNDING:
		to XCB_SHAPE_SK_CLIP:{

			/*!
				def struct{
					xcb_window_t     affected_window;
					int16_t          extents_x;
					int16_t          extents_y;
					uint16_t         extents_width;
					uint16_t         extents_height;
					xcb_timestamp_t  server_time;
					uint8_t          shaped;
				} xcb_shape_notify_event_t;
			*/



			/*!*/



			ret;
		}
		off:{
			ret;
		}
	end
	#undef  event0
}



























DRAWBELOWCLIENT(){



	/*!
		drawCompositeClient() is not exactly a drop-in replacement.

		this goes through all windows below a given client, it doesn't go through all the ones that are known to intersect with the given client.

		maybe draw below client differently -- change the order of operations wherever this is used.
	*/



	const uint *offsetCurrent = orderedMappedClientOffsetStart;
	jmp drawBelowClientLoop;
	drawBelowClientLoop:{
		if(offsetCurrent < orderedMappedClientOffsetWall){
			const Client *const current = clientStart + *offsetCurrent;
			int x;
			int y;
			int w;
			int h;
			if(current == client){
				jmp drawBelowClientLoopExit;
			}
			if((*current).mapInfo & VIEWABLE_MAP_INFO and (*current).allocated and getIntersectingRectangle((*current).x, (*current).y, (*current).w, (*current).h, eventX, eventY, eventW, eventH, &x, &y, &w, &h)){
				const uint amount = getClientIntersectingRectangles(current, x, y, x + w, y + h);
				if(amount){
					const xcb_xfixes_region_t region = xcb_generate_id(connection);
					xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
					xcb_xfixes_set_picture_clip_region_checked(connection, (*current).picture, region, 0, 0);
					xcb_render_composite_checked(connection, (*client).pictureOperation, (*current).picture, XCB_NONE, rootPicture, x - (*current).x, y - (*current).y, 0, 0, x, y, w, h);
					xcb_xfixes_destroy_region_checked(connection, region);
				}
			}
			inc offsetCurrent;
			jmp drawBelowClientLoop;
		}
	}
	drawBelowClientLoopExit:{}



	ret;
}



























#define DRAWCOMPOSITEABOVEBELOWCLIENT() /*-*/ local void drawCompositeAboveBelowClient(const Client *const client, const uint amount, const int x, const int y, const int w, const int h, const uint8 operation)

DRAWCOMPOSITEABOVEBELOWCLIENT();

DRAWCOMPOSITECLIENT(){
	#define NONE_CLIENTS_OPERATION /*--*/ (0)
	#define BELOW_CLIENTS_OPERATION /*-*/ (1)
	#define ABOVE_CLIENTS_OPERATION /*-*/ (2)
	const uint amount = getClientIntersectingRectangles(client, x, y, x + w, y + h);
	if(amount){
		const xcb_xfixes_region_t region = xcb_generate_id(connection);
		xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
		xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
		xcb_xfixes_set_picture_clip_region_checked(connection, bufferPicture, region, 0, 0);
		if(drawBelow){
			drawCompositeAboveBelowClient(client, amount, x, y, w, h, BELOW_CLIENTS_OPERATION);
		}
		if((*client).mapInfo & MAPPED_MAP_INFO){ /*! remove if drawBelowClient() problem is not adequately fixed */
			xcb_render_composite_checked(connection, (*client).pictureOperation, (*client).picture, XCB_NONE, bufferPicture, x - (*client).x, y - (*client).y, 0, 0, x, y, w, h);
		}
		if(drawAbove){
			drawCompositeAboveBelowClient(client, amount, x, y, w, h, ABOVE_CLIENTS_OPERATION);
		}
		xcb_render_composite_checked(connection, (*client).pictureOperation, bufferPicture, XCB_NONE, rootPicture, x, y, 0, 0, x, y, w, h);
		xcb_xfixes_destroy_region_checked(connection, region);
	}
	ret;
}
DRAWCOMPOSITEABOVEBELOWCLIENT(){
	Client *const *clientCurrent;
	Client *const *clientWall;
	switch operation over
		to BELOW_CLIENTS_OPERATION:{
			clientCurrent = (*client).belowClientStart;
			clientWall = clientCurrent + (*client).belowClientAllocated;
			jmp clientLoop;
		}
		to ABOVE_CLIENTS_OPERATION:{
			clientCurrent = (*client).aboveClientStart;
			clientWall = clientCurrent + (*client).aboveClientAllocated;
			jmp clientLoop;
		}
		off:{
			ret;
		}
	end
	clientLoop:{
		if(clientCurrent < clientWall){
			const Client *const client = *clientCurrent;
			if(operation == BELOW_CLIENTS_OPERATION or (operation == ABOVE_CLIENTS_OPERATION and (*client).pictureOperation == XCB_RENDER_PICT_OP_OVER)){
				const xcb_rectangle_t *rectangleCurrent = rectangleStart;
				const xcb_rectangle_t *const rectangleWall = rectangleStart + amount;
				uint rectangleAmount = 0;
				xcb_rectangle_t *const rectangleStartCopy = rectangleStart;
				rectangleStart = rectangleStart1;
				jmp getIntersectingRectanglesLoop;
				getIntersectingRectanglesLoop:{
					if(rectangleCurrent < rectangleWall){
						rectangleAmount += getClientIntersectingRectangles(client, (*rectangleCurrent).x, (*rectangleCurrent).y, (*rectangleCurrent).x + (*rectangleCurrent).width, (*rectangleCurrent).y + (*rectangleCurrent).height);
						inc rectangleCurrent;
						jmp getIntersectingRectanglesLoop;
					}
				}
				rectangleStart = rectangleStartCopy;
				if(rectangleAmount){
					const xcb_xfixes_region_t region = xcb_generate_id(connection);
					xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
					xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
					xcb_render_composite_checked(connection, (*client).pictureOperation, (*client).picture, XCB_NONE, bufferPicture, x - (*client).x, y - (*client).y, 0, 0, x, y, w, h);
					xcb_xfixes_destroy_region_checked(connection, region);
				}
			}
			inc clientCurrent;
			jmp clientLoop;
		}
	}
	ret;
	#undef  ABOVE_CLIENTS_OPERATION
	#undef  BELOW_CLIENTS_OPERATION
	#undef  NONE_CLIENTS_OPERATION
}
DRAWALLCLIENTS(){
	const uint *offsetCurrent = orderedMappedClientOffsetStart;
	jmp drawClientLoop;
	drawClientLoop:{
		Client *const client = clientStart + *offsetCurrent;
		if((*client).mapInfo & VIEWABLE_MAP_INFO and (*client).allocated){
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region_checked(connection, region, (*client).allocated, (*client).rectangle);
			xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
			xcb_render_composite_checked(connection, (*client).pictureOperation, (*client).picture, XCB_NONE, bufferPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).w, (*client).h);
			xcb_xfixes_destroy_region_checked(connection, region);
		}
		if(inc offsetCurrent < orderedMappedClientOffsetWall){
			jmp drawClientLoop;
		}
	}
	xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
	ret;
}



























CALCULATEVIEWABLEWINDOWSIZES(){
	const uint *belowCurrent = orderedMappedClientOffsetStart;
	jmp resetClientRectangle;
	resetClientRectangle:{
		Client *client = clientStart;
		jmp resetClientRectangleLoop;
		resetClientRectangleLoop:{
			if(client < clientWall){
				xcb_rectangle_t *rectangle = (*client).rectangle;
				if(rectangle){
					(*rectangle).x = (*client).x;
					(*rectangle).y = (*client).y;
					(*rectangle).width = (*client).w;
					(*rectangle).height = (*client).h;
					(*client).allocated = 1;
				}
				(*client).aboveClientAllocated = 0;
				(*client).belowClientAllocated = 0;
				inc client;
				jmp resetClientRectangleLoop;
			}
		}
		jmp belowClientLoop;
	}
	belowClientLoop:{
		if(belowCurrent < orderedMappedClientOffsetWall){
			const uint *aboveCurrent = belowCurrent + 1;
			Client *const below = clientStart + *belowCurrent;
			if(!((*below).mapInfo & VIEWABLE_MAP_INFO) or !(*below).allocated){
				inc belowCurrent;
				jmp belowClientLoop;
			}
			jmp aboveClientLoop;
			aboveClientLoop:{
				if(aboveCurrent < orderedMappedClientOffsetWall){
					Client *const above = clientStart + *aboveCurrent;
					if((*above).mapInfo & VIEWABLE_MAP_INFO){
						const int aboveX = (*above).x;
						const int aboveY = (*above).y;
						const int aboveW = (*above).w;
						const int aboveH = (*above).h;
						int x;
						int y;
						int w;
						int h;
						bool boolean = getIntersectingRectangle(aboveX, aboveY, aboveW, aboveH, (*below).x, (*below).y, (*below).w, (*below).h, &x, &y, &w, &h);
						if(boolean){
							if((*below).aboveClientAllocated == (*below).aboveClientSize){
								void *temp;
								(*below).aboveClientSize += ABOVE_CLIENT_BLOCK_SIZE;
								if(!(temp = realloc((*below).aboveClientStart, (*below).aboveClientSize * sizeof(Client *)))){
									ret;
								}
								(*below).aboveClientStart = temp;
							}
							*((*below).aboveClientStart + (*below).aboveClientAllocated) = above;
							inc (*below).aboveClientAllocated;
							if((*above).belowClientAllocated == (*above).belowClientSize){
								void *temp;
								(*above).belowClientSize += BELOW_CLIENT_BLOCK_SIZE;
								if(!(temp = realloc((*above).belowClientStart, (*above).belowClientSize * sizeof(Client *)))){
									ret;
								}
								(*above).belowClientStart = temp;
							}
							*((*above).belowClientStart + (*above).belowClientAllocated) = below;
							inc (*above).belowClientAllocated;
						}
						if(boolean and (*above).pictureOperation == XCB_RENDER_PICT_OP_SRC){
							xcb_rectangle_t *rectangle = (*below).rectangle;
							xcb_rectangle_t *const rectangleWall = rectangle + (*below).allocated;
							uint size = RECTANGLE_BLOCK_SIZE;
							uint allocated = 0;
							xcb_rectangle_t *newRectangle = malloc(size * sizeof(xcb_rectangle_t));
							if(!newRectangle){
								ret;
							}
							jmp splitRectangleLoop;
							splitRectangleLoop:{
								if(rectangle < rectangleWall){
									const int rectangleX = (*rectangle).x;
									const int rectangleY = (*rectangle).y;
									const int rectangleW = (*rectangle).width;
									const int rectangleH = (*rectangle).height;
									if(getIntersectingRectangle(rectangleX, rectangleY, rectangleW, rectangleH, aboveX, aboveY, aboveW, aboveH, &x, &y, &w, &h)){
										xcb_rectangle_t *current;
										if(allocated + 4 >= size){
											void *temp;
											size += RECTANGLE_BLOCK_SIZE;
											if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){



												/*! realloc will rectangleually fail. what do? */



												size = RECTANGLE_BLOCK_SIZE;
												allocated = 0;
												free(newRectangle);
												ret;
											}
											newRectangle = temp;
										}
										current = newRectangle + allocated;
										if(y > rectangleY){
											(*current).x = rectangleX;
											(*current).y = rectangleY;
											(*current).width = rectangleW;
											(*current).height = y - rectangleY;
											inc current;
										}
										if(y + h < rectangleY + rectangleH){
											(*current).x = rectangleX;
											(*current).y = y + h;
											(*current).width = rectangleW;
											(*current).height = rectangleY + rectangleH - y - h;
											inc current;
										}
										if(x > rectangleX){
											(*current).x = rectangleX;
											(*current).y = y;
											(*current).width = x - rectangleX;
											(*current).height = h;
											inc current;
										}
										if(x + w < rectangleX + rectangleW){
											(*current).x = x + w;
											(*current).y = y;
											(*current).width = rectangleX + rectangleW - x - w;
											(*current).height = h;
											inc current;
										}
										allocated = current - newRectangle;
									}else{
										if(allocated == size){
											void *temp;
											size += RECTANGLE_BLOCK_SIZE;
											if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){
												ret;
											}
											newRectangle = temp;
										}
										*(newRectangle + allocated) = *rectangle;
										inc allocated;
									}
									inc rectangle;
									jmp splitRectangleLoop;
								}
							}
							free((*below).rectangle);
							(*below).size = size;
							(*below).allocated = allocated;
							(*below).rectangle = newRectangle;
						}
					}
					inc aboveCurrent;
					jmp aboveClientLoop;
				}
			}
			inc belowCurrent;
			jmp belowClientLoop;
		}
		ret;
	}
}



























GETCLIENTINTERSECTINGRECTANGLES(){
	const xcb_rectangle_t *rectangle = (*client).rectangle;
	const xcb_rectangle_t *const wall = rectangle + (*client).allocated;
	xcb_rectangle_t *rectangleCurrent = rectangleStart;
	if(!rectangleStart){
		ret 0;
	}
	jmp getIntersectingRectangleLoop;
	getIntersectingRectangleLoop:{
		if(rectangle < wall){
			const int leftX1 = (*rectangle).x;
			const int topY1 = (*rectangle).y;
			const int rightX1 = leftX1 + (*rectangle).width;
			const int bottomY1 = topY1 + (*rectangle).height;
			if(leftX0 < rightX1 and rightX0 > leftX1 and topY0 < bottomY1 and bottomY0 > topY1){
				(*rectangleCurrent).x      =    leftX1 >   leftX0?   leftX1 :   leftX0;
				(*rectangleCurrent).y      =     topY1 >    topY0?    topY1 :    topY0;
				(*rectangleCurrent).width  = ( rightX1 <  rightX0?  rightX1 :  rightX0) - (*rectangleCurrent).x;
				(*rectangleCurrent).height = (bottomY1 < bottomY0? bottomY1 : bottomY0) - (*rectangleCurrent).y;
				inc rectangleCurrent;
			}
			inc rectangle;
			jmp getIntersectingRectangleLoop;
		}
		ret rectangleCurrent - rectangleStart;
	}
}
GETINTERSECTINGRECTANGLE(){
	const int  rightX0 = leftX0 +  width0;
	const int  rightX1 = leftX1 +  width1;
	const int bottomY0 =  topY0 + height0;
	const int bottomY1 =  topY1 + height1;
	if(leftX1 < rightX0 and rightX1 > leftX0 and topY1 < bottomY0 and bottomY1 > topY0){
		*retX =    leftX0 >   leftX1?   leftX0 :   leftX1;
		*retY =     topY0 >    topY1?    topY0 :    topY1;
		*retW = ( rightX0 <  rightX1?  rightX0 :  rightX1) - *retX;
		*retH = (bottomY0 < bottomY1? bottomY0 : bottomY1) - *retY;
		ret true;
	}
	ret false;
}

















































































CREATEROOTPICTURE(){
	if(rootPicture){
		xcb_render_free_picture(connection, rootPicture);
	}
	if(bufferPicture){
		xcb_render_free_picture(connection, bufferPicture);
	}
	if(bufferPixmap){
		xcb_free_pixmap(connection, bufferPixmap);
	}
	bufferPixmap = xcb_generate_id(connection);
	bufferPicture = xcb_generate_id(connection);
	rootPicture = xcb_generate_id(connection);
	xcb_create_pixmap(connection, (*screen).root_depth, bufferPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
	xcb_render_create_picture(connection, bufferPicture, bufferPixmap, (*clientStart).format, XCB_NONE, NULL);
	xcb_render_create_picture(connection, rootPicture, overlayWindow, (*clientStart).format, XCB_NONE, NULL);
	ret;
}
CREATEWALLPAPER(){
	if(wallpaperPicture){
		xcb_render_free_picture(connection, wallpaperPicture);
	}
	if(wallpaperPixmap){
		xcb_free_pixmap(connection, wallpaperPixmap);
	}
	wallpaperPixmap = xcb_generate_id(connection);
	wallpaperPicture = xcb_generate_id(connection);
	xcb_create_pixmap(connection, (*screen).root_depth, wallpaperPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
	xcb_render_create_picture(connection, wallpaperPicture, wallpaperPixmap, (*clientStart).format, XCB_NONE, NULL);
	(*clientStart).picture = wallpaperPicture;
	ret;
}
SETWALLPAPER(){
	jmp setWallpaperBackgroundColor;
	setWallpaperBackgroundColor:{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		const uint32 valueList = 0xFF000000;
		xcb_rectangle_t rectangle;
		rectangle.x = 0;
		rectangle.y = 0;
		rectangle.width = (*screen).width_in_pixels;
		rectangle.height = (*screen).height_in_pixels;
		xcb_create_gc(connection, gc, wallpaperPixmap, XCB_GC_FOREGROUND, &valueList);
		xcb_poly_fill_rectangle(connection, wallpaperPixmap, gc, 1, &rectangle);
		xcb_free_gc(connection, gc);
		jmp setWallpaperPixmap;
	}
	setWallpaperPixmap:{
		xcb_get_property_reply_t *reply;
		if(!rootPixmapAtom or !pixmapAtom or !(reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL))){
			ret;
		}
		if((*reply).type != pixmapAtom){
			fprintf(stdout, "%s: root pixmap is not of type pixmap\n", programName);
			ret;
		}
		{
			const xcb_pixmap_t pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
			const xcb_get_geometry_cookie_t cookie = xcb_get_geometry_unchecked(connection, pixmap);
			const xcb_gcontext_t gc = xcb_generate_id(connection);
			xcb_get_geometry_reply_t *geometryReply;
			uint width = (*screen).width_in_pixels;
			uint height = (*screen).height_in_pixels;
			xcb_create_gc(connection, gc, pixmap, XCB_NONE, NULL);
			if((geometryReply = xcb_wait_for_reply(connection, cookie, NULL))){
				width = (*geometryReply).width;
				height = (*geometryReply).height;
				free(geometryReply);
			}
			xcb_copy_area(connection, pixmap, wallpaperPixmap, gc, 0, 0, 0, 0, width, height);
			xcb_free_gc(connection, gc);
		}
		free(reply);
		ret;
	}
}
FINDFORMAT(){
	const xcb_render_pictvisual_t *current = visualStart;
	jmp findVisualLoop;
	findVisualLoop:{
		if(current < visualWall){
			if((*current).visual == visual){
				ret (*current).format;
			}
			inc current;
			jmp findVisualLoop;
		}
		if(depth == 24){
			ret defaultOpaqueFormat;
		}
		ret defaultTransparentFormat;
	}
}
QUERYTREE(){
	const xcb_query_tree_cookie_t cookie = xcb_query_tree_unchecked(connection, (*screen).root);
	if(treeReply){
		free(treeReply);
	}
	treeReply = xcb_wait_for_reply(connection, cookie, NULL);
	ret;
}
FINDCLIENT(){
	const uint8 *firstWindow;
	const uint8 *current;
	jmp checkLastClient;
	checkLastClient:{
		if(lastClient and (*lastClient).window == window){
			ret lastClient;
		}
		firstWindow = (void *)&(*clientStart).window;
		current = firstWindow;
		jmp findClientLoop;
	}
	findClientLoop:{
		if(*(xcb_window_t *)current == window){
			lastClient = (void *)(current - (firstWindow - (uint8 *)clientStart));
			ret lastClient;
		}
		if((current += sizeof(Client)) < (uint8 *)clientWall){
			jmp findClientLoop;
		}
		ret NULL;
	}
}
FINDMAPPEDCLIENT(){
	const uint *offsetCurrent;
	jmp checkLastClient;
	checkLastClient:{
		if(lastClient and (*lastClient).window == window and (*lastClient).mapInfo & MAPPED_MAP_INFO){
			ret lastClient;
		}
		offsetCurrent = orderedMappedClientOffsetStart + 1;
		jmp findMappedClientLoop;
	}
	findMappedClientLoop:{
		if(offsetCurrent < orderedMappedClientOffsetWall){
			Client *const current = clientStart + *offsetCurrent;
			if((*current).window == window){
				lastClient = current;
				ret lastClient;
			}
			inc offsetCurrent;
			jmp findMappedClientLoop;
		}
		ret NULL;
	}
}
UPDATEORDER(){
	if(treeReply){
		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
		const uint8 *const firstClientStartWindow = (void *)&(*clientStart).window;
		Client *startingClient = clientStart;
		uint *orderedMappedClientOffsetCurrent = orderedMappedClientOffsetStart + 1;
		jmp findClientWindow1Loop;
		findClientWindow1Loop:{
			const uint8 *const firstWindow = (void *)&(*startingClient).window;
			const uint8 *current = firstWindow;
			const xcb_window_t window = *windowCurrent;
			Client *client;
			jmp findClient1Loop;
			findClient1Loop:{
				if(*(xcb_window_t *)current == window){
					client = (void *)(current - (firstClientStartWindow - (uint8 *)clientStart));
					if((*client).mapInfo & MAPPED_MAP_INFO){
						*orderedMappedClientOffsetCurrent = client - clientStart;
						inc orderedMappedClientOffsetCurrent;
					}
					if(client == startingClient){
						inc startingClient;
					}
				}
				if((current += sizeof(Client)) < (uint8 *)clientWall){
					jmp findClient1Loop;
				}
			}
			if(inc windowCurrent < windowWall){
				jmp findClientWindow1Loop;
			}
		}
		orderedMappedClientAllocated = orderedMappedClientOffsetCurrent - orderedMappedClientOffsetStart;
		orderedMappedClientOffsetWall = orderedMappedClientOffsetCurrent;
	}
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		fprintf(errorStream, "%s: %s\n", programName, string);
		closeErrorStream();
	}
	ret;
}
OPENERRORSTREAM(){
	ret !mustOpenErrorStream or (errorStream = fopen(errorPath, "a"));
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		errorStream = NULL;
	}
	ret;
}
PRINTCONNECTIONERROR(){
	if(openErrorStream()){
		#define PRINTCONNECTIONERROR_ERROR /*--*/ xcb_connection_has_error(connection)
		#define PRINTCONNECTIONERROR_STREAM /*-*/ errorStream
		#include "xcb/printConnectionError.hold"
		closeErrorStream();
	}
	ret;
}
PRINTXCBERROR(){
	if(openErrorStream()){
		#define PRINTXCBERROR_ERROR /*--*/ genericError
		#define PRINTXCBERROR_STREAM /*-*/ errorStream
		#include "xcb/printXCBError.hold"
		closeErrorStream();
	}
	ret;
}
