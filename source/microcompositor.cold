/*!
	check for monitor change issues
*/

/*!
	rectangle splitting can create rectangles that can be combined into one (yikes)
*/

/*!
	fix all kinds of issues that can be safely called basic and then move onto 32 bit window handling.



	basic includes faultless composition at idle-tier speeds where all windows are treated as 24 bit.
	then deal with how the wallpaper works and then deal with 32 bit windows.
*/

/*!
	add border width to width and height...
*/

/*!
	windows that move will leave a trail until the below window is updated.
*/

/*!
	findClient() should be used only after a fastFindClient() is used.

	fastFindClient() should hold the n, say 5, last seen windows.
*/

/*!
	consider getting up to n events from the loop and doing them at the same time
*/

/*!
	grab server when doing critical operation when the server starts

	ungrab afterwards
*/

/*!
	keep non-input-output windows?
*/

/*!
	store windows each client is intersecting with?
*/

/*!
	something that is actively moving, namely the i3 bar between windows, will prevent drawing everything else
*/

/*!
	some bug causes endless unrecognized errors with no more drawing on screen, at least for the window the bug happens on.
*/

/*!
	windows spawned via tray icons cause only errors.

	discord specifically, steam doesn't.
*/

/*!
	creating a new window over the vivaldi popup will hide the vivaldi popup, and it's only a visual problem, basically exactly like the discord tray.
*/

/*!
	gnome screenshot dragging the window to take a custom size screenshot is not appearing at all when it should just be a black box and causing errors
*/

/*!
	on creating a window and mapping it we get a flash on the monitor that shouldn't be there
*/



#ifdef a
xcb_window_t fastFindWindowList[5] = {
	  XCB_NONE
	, XCB_NONE
	, XCB_NONE
	, XCB_NONE
	, XCB_NONE
};

uint startWindowOffset = 0;
uint endWindowOffset = 0;

local void fastFindWindow(const xcb_window_t window){
	uint currentOffset = startWindowOffset;
	while(currentOffset < endWindowOffset)



		a



	}
	ret;
}
#endif



























/*! microcompositor.cold

MIT License

Copyright (C) 2023 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#include <stdint.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <xcb/composite.h>
	#include <xcb/damage.h>
	#include <xcb/randr.h>
	#include <xcb/render.h>
	#include <xcb/shape.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include "cold/cold.hold"
/*!}*/

/*!user_defines:{*/
	#define DefaultErrorStream /*-------------*/ (stderr)
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------*/ (true)

	#define _EMPTY_MACRO /*----------------------*/

	#define FINDCLIENT() /*----------------------*/ local Client                  *findClient(const xcb_window_t window)
	#define REMOVECLIENT() /*--------------------*/ local void                     removeClient(Client *const client)
	#define UNMAPWINDOW() /*---------------------*/ local void                     unmapWindow(Client *const client)
	#define DRAWBELOWCLIENT() /*-----------------*/ local void                     drawBelowClient(const Client *const client)
	#define MAPWINDOW() /*-----------------------*/ local void                     mapWindow(Client *const client)
	#define ADDCLIENT() /*-----------------------*/ local bool                     addClient(const xcb_window_t window, const void *const event)
	#define CONFIGURECLIENT() /*-----------------*/ local void                     configureClient(Client *const client)
	#define QUERYTREE() /*-----------------------*/ local void                     queryTree(void)
	#define UPDATEORDER() /*---------------------*/ local void                     updateOrder(void)
	#define CREATEINTERSECTINGRECTANGLE() /*-----*/ local bool                     createIntersectingRectangle(int leftX0, int topY0, int width0, int height0, int leftX1, int topY1, int width1, int height1, int *retX, int *retY, int *retW, int *retH)
	#define SPLITRECTANGLE() /*------------------*/ local void                     splitRectangle(const int x, const int y, const int w, const int h, int interX, int interY, int interW, int interH, uint *size, uint *allocated, xcb_rectangle_t **rectangle)
	#define CALCULATEVIEWABLEWINDOWSIZES() /*----*/ local void                     calculateViewableWindowSizes(void)
	#define CREATEWALLPAPER() /*-----------------*/ local void                     createWallpaper(void)
	#define DRAWWALLPAPER() /*-------------------*/ local void                     drawWallpaper(void)
	#define FINDFORMAT() /*----------------------*/ local xcb_render_pictformat_t  findFormat(const xcb_visualid_t visual)
	#define COPYTOBUFFER() /*--------------------*/ local void                     copyToBuffer(const xcb_xfixes_region_t region, const xcb_render_picture_t picture)
	#define GETCLIENTINTERSECTINGRECTANGLES() /*-*/ local uint                     getClientIntersectingRectangles(const Client *const client, const int eventLeftX, const int eventTopY, const int eventRightX, const int eventBottomY)
	#define DRAWALLCLIENTS() /*------------------*/ local void                     drawAllClients(void)



	#define PRINTERROR() /*----------------------*/ local void    printError(const char *const string)
	#define OPENERRORSTREAM() /*-----------------*/ local bool    openErrorStream(void)
	#define CLOSEERRORSTREAM() /*----------------*/ local void    closeErrorStream(void)
	#define PRINTCONNECTIONERROR() /*------------*/ local void    printConnectionError(void)
	#define PRINTXCBERROR() /*-------------------*/ local void    printXCBError(void)

	#define xcb_wait_for_reply(a, b, c) /*-------*/ (xcb_wait_for_reply(a, (b).sequence, c))

	#define LITERAL_LENGTH(l) /*-----------------*/ (sizeof(l) - 1)

	#define _b(d, b) /*--------------------------*/ (d > (sizeof(#b) - 1)? 0 : ((*(#b + (sizeof(#b) - 1) - d) - 48) == 1) * ((uint64)1 << (d - 1)))

	#define b(b) /*------------------------------*/ ( \
		  _b( 1, b) + _b( 2, b) + _b( 3, b) + _b( 4, b) + _b( 5, b) + _b( 6, b) + _b( 7, b) + _b( 8, b) \
		+ _b( 9, b) + _b(10, b) + _b(11, b) + _b(12, b) + _b(13, b) + _b(14, b) + _b(15, b) + _b(16, b) \
		+ _b(17, b) + _b(18, b) + _b(19, b) + _b(20, b) + _b(21, b) + _b(22, b) + _b(23, b) + _b(24, b) \
		+ _b(25, b) + _b(26, b) + _b(27, b) + _b(28, b) + _b(29, b) + _b(30, b) + _b(31, b) + _b(32, b) \
		+ _b(33, b) + _b(34, b) + _b(35, b) + _b(36, b) + _b(37, b) + _b(38, b) + _b(39, b) + _b(40, b) \
		+ _b(41, b) + _b(42, b) + _b(43, b) + _b(44, b) + _b(45, b) + _b(46, b) + _b(47, b) + _b(48, b) \
		+ _b(49, b) + _b(50, b) + _b(51, b) + _b(52, b) + _b(53, b) + _b(54, b) + _b(55, b) + _b(56, b) \
		+ _b(57, b) + _b(58, b) + _b(59, b) + _b(60, b) + _b(61, b) + _b(62, b) + _b(63, b) + _b(64, b) \
	)

	#define VISUAL_FORMAT_PAIR_BLOCK_SIZE /*-----*/ (4)
	#define RECTANGLE_BLOCK_SIZE /*--------------*/ (8)
	#define CLIENT_BLOCK_SIZE /*-----------------*/ (128)
/*!}*/

/*!defs:{*/
	def struct{
		uint32 /*------------------*/ size;
		uint32 /*------------------*/ allocated;
		xcb_rectangle_t * /*-------*/ rectangle;

		xcb_window_t /*------------*/ window;
		xcb_damage_damage_t /*-----*/ damage;
		xcb_visualid_t /*----------*/ visual;
		xcb_render_pictformat_t /*-*/ format;
		xcb_render_picture_t /*----*/ picture;

		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		int32 /*-------------------*/ w;
		int32 /*-------------------*/ h;
		int32 /*-------------------*/ rightX;
		int32 /*-------------------*/ bottomY;

		bool /*--------------------*/ shaped;
		bool /*--------------------*/ mapped;

		uint8 /*-------------------*/ depth;
		bool /*--------------------*/ viewable;

		bool /*--------------------*/ useSpecialEffect;

		uint8 /*-------------------*/ pad[3];
	} Client;

	def struct{
		uint16 /*------------------*/ x;
		uint16 /*------------------*/ y;
		uint16 /*------------------*/ w;
		uint16 /*------------------*/ h;
	} Monitor;
/*!}*/

/*!globals:{*/
	const char * /*----------*/ programName;
	const char * /*----------*/ errorPath;
	const char * /*----------*/ connectionName;
	const xcb_screen_t * /*--*/ screen;
	const char * /*----------*/ quitMessage;
	bool /*------------------*/ mustOpenErrorStream;
	FILE * /*----------------*/ errorStream;
	xcb_connection_t * /*----*/ connection;
	xcb_generic_error_t * /*-*/ genericError;
	xcb_generic_event_t * /*-*/ event0;



	const uint32 windowValueList = XCB_EVENT_MASK_VISIBILITY_CHANGE | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_STRUCTURE_NOTIFY;
	uint damageBaseEvent;
	uint damageBaseError;
	uint renderBaseEvent;
	uint renderBaseError;
	uint randrBaseEvent;
	uint randrBaseError;



	Client rootClient;
	xcb_atom_t pixmapAtom;
	xcb_atom_t rootPixmapAtom;
	xcb_render_pictformat_t rootFormat;
	xcb_pixmap_t wallpaperPixmap;
	xcb_render_picture_t wallpaperPicture;
	xcb_pixmap_t bufferPixmap;
	xcb_render_picture_t bufferPicture;
	xcb_render_picture_t rootPicture;



	xcb_xfixes_region_t bufferRegion;



	uint visualSize;
	uint visualAllocated;
	xcb_render_pictvisual_t *visualStart;
	xcb_render_pictvisual_t *visualWall;



	uint clientSize;
	uint clientAllocated;
	Client *clientStart;
	Client *clientWall;



	uint monitorAmount;
	void *monitorData;
	Monitor *monitorStart;
	Monitor *monitorWall;



	uint *orderedClientOffsetStart;
	xcb_window_t overlayWindow;
	xcb_rectangle_t *rectangleStart;
	xcb_query_tree_reply_t *treeReply;
/*!}*/

/*!functions:{*/
	FINDCLIENT();
	REMOVECLIENT();
	UNMAPWINDOW();
	DRAWBELOWCLIENT();
	MAPWINDOW();
	ADDCLIENT();
	QUERYTREE();
	UPDATEORDER();
	CREATEINTERSECTINGRECTANGLE();
	SPLITRECTANGLE();
	CALCULATEVIEWABLEWINDOWSIZES();
	CREATEWALLPAPER();
	FINDFORMAT();
	CONFIGURECLIENT();
	COPYTOBUFFER();
	GETCLIENTINTERSECTINGRECTANGLES();
	DRAWWALLPAPER();
	DRAWALLCLIENTS();

	PRINTERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
	PRINTCONNECTIONERROR();
	PRINTXCBERROR();
/*!}*/

int main(const int argumentAmount, const char *const *argument){
	(void)argumentAmount;
	jmp setPrimaryGlobals;
	setPrimaryGlobals:{
		programName /*----------*/ = *argument;
		errorPath /*------------*/ = NULL;
		connectionName /*-------*/ = NULL;
		mustOpenErrorStream /*--*/ = false;
		errorStream /*----------*/ = DefaultErrorStream;
		connection /*-----------*/ = NULL;
		genericError /*---------*/ = NULL;
		event0 /*---------------*/ = NULL;
		quitMessage /*----------*/ = NULL;
		treeReply /*------------*/ = NULL;



		rootClient.rectangle /*-*/ = NULL;
		bufferRegion /*---------*/ = XCB_NONE;
		rectangleStart /*-------*/ = NULL;
		clientSize /*-----------*/ = CLIENT_BLOCK_SIZE;
		clientAllocated /*------*/ = 0;



		jmp establishServerConnection;
	}
	establishServerConnection:{
		#define ESTABLISHSERVERCONNECTION_CONNECTION /*-----*/ connection
		#define ESTABLISHSERVERCONNECTION_CONNECTIONNAME /*-*/ connectionName
		#define ESTABLISHSERVERCONNECTION_SCREEN /*---------*/ screen
		#include "xcb/establishServerConnection.hold"
		switch xcb_connection_has_error(connection) over
			to XCB_NONE: /*------------*/ /*-----------------------------------------------------------------*/ brk;
			to XCB_CONN_CLOSED_PARSE_ERR: printError(connectionName? "invalid server name" : "no server name"); jmp mainEmergencyExit;
			off: /*--------------------*/ printConnectionError(); /*-----------------------------------------*/ jmp mainEmergencyExit;
		end
	}
	damageBaseEvent = 0;
	damageBaseError = 0;
	renderBaseEvent = 0;
	renderBaseError = 0;
	randrBaseEvent = 0;
	randrBaseError = 0;
	{
		const xcb_query_extension_cookie_t compositeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("Composite"), "Composite");
		const xcb_query_extension_cookie_t damageCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("DAMAGE"), "DAMAGE");
		const xcb_query_extension_cookie_t randrCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RANDR"), "RANDR");
		const xcb_query_extension_cookie_t renderCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RENDER"), "RENDER");
		const xcb_query_extension_cookie_t xfixesCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("XFIXES"), "XFIXES");
		const xcb_query_extension_cookie_t shapeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("SHAPE"), "SHAPE");
		xcb_query_extension_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_query_extension_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_query_extension_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_query_extension_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_query_extension_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_query_extension_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(!compositeReply or !(*compositeReply).present){
			fprintf(stdout, "composite extension not available\n");
		}else{
			free(compositeReply);
		}
		if(!damageReply or !(*damageReply).present){
			fprintf(stdout, "damage extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_damage_id);
			if(reply and (*reply).present){
				damageBaseEvent = (*reply).first_event;
				damageBaseError = (*reply).first_error;
			}
			free(damageReply);
		}
		if(!randrReply or !(*randrReply).present){
			fprintf(stdout, "randr extension not available\n");
		}else{
			free(randrReply);
		}
		if(!renderReply or !(*renderReply).present){
			fprintf(stdout, "render extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_render_id);
			if(reply and (*reply).present){
				renderBaseEvent = (*reply).first_event;
				renderBaseError = (*reply).first_error;
			}
			free(renderReply);
		}
		if(!xfixesReply or !(*xfixesReply).present){
			fprintf(stdout, "xfixes extension not available\n");
		}else{
			free(xfixesReply);
		}
		if(!shapeReply or !(*shapeReply).present){
			fprintf(stdout, "shape extension not available\n");
		}else{
			free(shapeReply);
		}
	}
	{
		xcb_damage_query_version_cookie_t compositeCookie = xcb_damage_query_version_unchecked(connection, XCB_COMPOSITE_MAJOR_VERSION, XCB_COMPOSITE_MINOR_VERSION);
		xcb_damage_query_version_cookie_t damageCookie = xcb_damage_query_version_unchecked(connection, XCB_DAMAGE_MAJOR_VERSION, XCB_DAMAGE_MINOR_VERSION);
		xcb_damage_query_version_cookie_t renderCookie = xcb_damage_query_version_unchecked(connection, XCB_RENDER_MAJOR_VERSION, XCB_RENDER_MINOR_VERSION);
		xcb_damage_query_version_cookie_t randrCookie = xcb_damage_query_version_unchecked(connection, XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
		xcb_xfixes_query_version_cookie_t xfixesCookie = xcb_xfixes_query_version_unchecked(connection, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION);
		xcb_xfixes_query_version_cookie_t shapeCookie = xcb_xfixes_query_version_unchecked(connection, XCB_SHAPE_MAJOR_VERSION, XCB_SHAPE_MINOR_VERSION);
		xcb_damage_query_version_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_damage_query_version_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_damage_query_version_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_damage_query_version_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_xfixes_query_version_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_xfixes_query_version_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(compositeReply){
			free(compositeReply);
		}else{
			fprintf(stdout, "%s: could not query composite extension\n", programName);
		}
		if(damageReply){
			free(damageReply);
		}else{
			fprintf(stdout, "%s: could not query damage extension\n", programName);
		}
		if(renderReply){
			free(renderReply);
		}else{
			fprintf(stdout, "%s: could not query render extension\n", programName);
		}
		if(randrReply){
			free(randrReply);
		}else{
			fprintf(stdout, "%s: could not query randr extension\n", programName);
		}
		if(xfixesReply){
			free(xfixesReply);
		}else{
			fprintf(stdout, "%s: could not query xfixes extension\n", programName);
		}
		if(shapeReply){
			free(shapeReply);
		}else{
			fprintf(stdout, "%s: could not query shape extension\n", programName);
		}
	}



	{
		const uint32 stackMode = XCB_STACK_MODE_BELOW;
		xcb_composite_get_overlay_window_reply_t *const overlay = xcb_wait_for_reply(connection, xcb_composite_get_overlay_window_unchecked(connection, (*screen).root), NULL);
		if(overlay){
			overlayWindow = (*overlay).overlay_win;
			free(overlay);
		}
		xcb_configure_window(connection, overlayWindow, XCB_CONFIG_WINDOW_STACK_MODE, &stackMode);
	}



	{
		xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("PIXMAP"), "PIXMAP"), NULL);
		pixmapAtom = XCB_NONE;
		if(reply){
			pixmapAtom = (*reply).atom;
			free(reply);
		}
	}



	{
		xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("_XROOTPMAP_ID"), "_XROOTPMAP_ID"), NULL);
		rootPixmapAtom = XCB_NONE;
		if(reply){
			rootPixmapAtom = (*reply).atom;
			free(reply);
		}
	}



	{
		xcb_composite_redirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}



	jmp storeMonitors;
	storeMonitors:{
		void *reply;
		Monitor *monitorCurrent;
		xcb_randr_monitor_info_iterator_t iterator;
		if(!(reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL))){
			monitorAmount = 1;
			jmp storeMonitorsExit;
		}
		monitorAmount = (*(xcb_randr_get_monitors_reply_t *)reply).nMonitors;
		if(!(monitorData = malloc(monitorAmount * sizeof(Monitor)))){
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorStart = monitorData;
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAmount;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const uint x = (*data).x;
				const uint y = (*data).y;
				const uint w = (*data).width;
				const uint h = (*data).height;
				if(monitorCurrent > monitorStart){
					const Monitor *const wall = monitorCurrent;
					const Monitor *current = monitorStart;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).x == x and (*current).y == y and (*current).w == w and (*current).h == h){
								dec monitorAmount;
								dec monitorWall;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).x = x;
				(*monitorCurrent).y = y;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				xcb_randr_monitor_info_next(&iterator);
				inc monitorCurrent;
				jmp storeMonitorLoop;
			}
			jmp trimMonitorMemory;
		}
		trimMonitorMemory:{
			void *temp;
			if(!(temp = realloc(monitorData, monitorAmount * sizeof(Monitor)))){
				free(reply);
				jmp storeMonitorsExit;
			}
			monitorData = temp;
		}
		monitorStart = monitorData;
		monitorWall = monitorStart + monitorAmount;
		free(reply);
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{}



	{
		if(!(clientStart = malloc(clientSize * sizeof(Client)))){
			fprintf(stdout, "no clientStart\n");
		}
		clientWall = clientStart + clientAllocated;



		if(!(orderedClientOffsetStart = malloc(clientSize * sizeof(uint)))){
			fprintf(stdout, "no orderedClientOffsetStart\n");
		}



		if(!(rectangleStart = malloc(128 * sizeof(xcb_rectangle_t)))){
			fprintf(stdout, "no rectangleStart\n");
		}



		visualSize = VISUAL_FORMAT_PAIR_BLOCK_SIZE;
		visualAllocated = 0;
		if(!(visualStart = malloc(visualSize * sizeof(xcb_render_pictvisual_t)))){
			fprintf(stdout, "no visualStart\n");
			visualSize = 0;
		}
	}



	jmp matchVisualFormat;
	matchVisualFormat:{
		xcb_render_query_pict_formats_reply_t *const formats = xcb_wait_for_reply(connection, xcb_render_query_pict_formats_unchecked(connection), NULL);
		if(formats){
			xcb_render_pictscreen_iterator_t pictscreenIterator = xcb_render_query_pict_formats_screens_iterator(formats);
			xcb_render_pictvisual_t *current = visualStart;
			while(pictscreenIterator.rem){
				xcb_render_pictdepth_iterator_t pictdepth = xcb_render_pictscreen_depths_iterator(pictscreenIterator.data);
				while(pictdepth.rem){
					xcb_render_pictvisual_t *const pictvisual = xcb_render_pictdepth_visuals(pictdepth.data);
					if(visualAllocated == visualSize){
						void *temp;
						visualSize += VISUAL_FORMAT_PAIR_BLOCK_SIZE;
						if(!(temp = realloc(visualStart, visualSize * sizeof(xcb_rectangle_t)))){
							jmp matchVisualFormatExit;
						}
						visualStart = temp;
					}
					if((*pictvisual).visual and (*pictvisual).format){
						*current = *pictvisual;
						inc current;
						inc visualAllocated;
					}
					xcb_render_pictdepth_next(&pictdepth);
				}
				xcb_render_pictscreen_next(&pictscreenIterator);
			}
			free(formats);
		}
	}
	matchVisualFormatExit:{}



	{
		visualWall = visualStart + visualAllocated;
	}



	{
		bufferPixmap = xcb_generate_id(connection);
		rootPicture = xcb_generate_id(connection);
		bufferPicture = xcb_generate_id(connection);
		rootFormat = findFormat((*screen).root_visual);
		xcb_create_pixmap(connection, (*screen).root_depth, bufferPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_render_create_picture(connection, bufferPicture, bufferPixmap, rootFormat, XCB_NONE, NULL);
		xcb_render_create_picture(connection, rootPicture, overlayWindow, rootFormat, XCB_NONE, NULL);
	}



	{
		wallpaperPixmap = xcb_generate_id(connection);
		wallpaperPicture = xcb_generate_id(connection);
		xcb_create_pixmap(connection, (*screen).root_depth, wallpaperPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_render_create_picture(connection, wallpaperPicture, wallpaperPixmap, rootFormat, XCB_NONE, NULL);
		createWallpaper();
	}



	{
		const uint32 valueList = XCB_EVENT_MASK_VISIBILITY_CHANGE | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_change_window_attributes(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
	}



	{
		queryTree();
		if(treeReply){
			const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
			const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
			uint *orderedClientOffsetCurrent = orderedClientOffsetStart;
			addExistingClientLoop:{
				if(addClient(*windowCurrent, NULL)){
					*orderedClientOffsetCurrent = orderedClientOffsetCurrent - orderedClientOffsetStart;
					inc orderedClientOffsetCurrent;
				}
				if(inc windowCurrent < windowWall){
					jmp addExistingClientLoop;
				}
			}
		}
		clientWall = clientStart + clientAllocated;
		calculateViewableWindowSizes();
		drawWallpaper();
		drawAllClients();
	}









	eventLoop:{
		xcb_flush(connection);
		free(event0);
		event0 = NULL;
		jmp waitForEventLoop;
	}
	waitForEventLoop:{
		if((event0 = xcb_wait_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		jmp eventLoop;
	}
	switchEvents:{
		#define XCB_ONE /*-*/ (1)
		switch (*event0).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unexpectedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp unexpectedEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp unexpectedEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp unexpectedEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp unexpectedEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;

			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
#ifdef a
			to XCB_VISIBILITY_NOTIFY: /*-*/ fprintf(stdout, "visibility notify\n"); jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ fprintf(stdout, "create notify\n"); jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ fprintf(stdout, "destroy notify\n"); jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ fprintf(stdout, "unmap notify\n"); jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ fprintf(stdout, "map notify\n"); jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ fprintf(stdout, "reparent notify\n"); jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ fprintf(stdout, "configure notify\n"); jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ fprintf(stdout, "circulate notify\n"); jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ fprintf(stdout, "property notify\n"); jmp propertyNotifyEvent;
#endif
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp unexpectedEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	extensionEvent:{
		if(((*event0).response_type & ~b(10000000)) == damageBaseEvent + XCB_DAMAGE_NOTIFY){
			jmp damageNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseEvent + XCB_RANDR_SCREEN_CHANGE_NOTIFY){
			jmp randrNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == damageBaseError + XCB_DAMAGE_BAD_DAMAGE){
			jmp badDamageError;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseError){
			jmp randrNotifyError;
		}
		jmp unexpectedEvent;
	}
	visibilityNotifyEvent:{
		#define event0 /*-*/ ((xcb_visibility_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			if((*event0).state == XCB_VISIBILITY_FULLY_OBSCURED){
				unmapWindow(client);
			}else{
				mapWindow(client);
			}
			calculateViewableWindowSizes();
			drawWallpaper();
			jmp drawRegion;
		}
		jmp eventLoop;
		#undef  event0
	}
	createNotifyEvent:{
		#define event0 /*-*/ ((xcb_create_notify_event_t *)event0)
		queryTree();
		{
			Client *const client = findClient((*event0).window);
			if(!client){
				if(addClient((*event0).window, event0)){
					updateOrder();
					calculateViewableWindowSizes();
					drawWallpaper();
				}
			}
		}
		jmp eventLoop;
		#undef  event0
	}
	destroyNotifyEvent:{
		#define event0 /*-*/ ((xcb_destroy_notify_event_t *)event0)
		queryTree();
		{
			Client *const client = findClient((*event0).window);
			if(client){
				removeClient(client);
				updateOrder();
				calculateViewableWindowSizes();
				drawWallpaper();
			}
		}
		jmp eventLoop;
		#undef  event0
	}
	unmapNotifyEvent:{
		#define event0 /*-*/ ((xcb_unmap_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			unmapWindow(client);
			calculateViewableWindowSizes();
			drawWallpaper();
		}
		jmp drawRegion;
		#undef  event0
	}
	mapNotifyEvent:{
		#define event0 /*-*/ ((xcb_map_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			mapWindow(client);
			calculateViewableWindowSizes();
			drawWallpaper();
		}
		jmp eventLoop;
		#undef  event0
	}
	reparentNotifyEvent:{
		#define event0 /*-*/ ((xcb_reparent_notify_event_t *)event0)
		queryTree();
		{
			Client *const client = findClient((*event0).window);



			/*! could maybe draw something here */



			if((*event0).parent == (*screen).root){
				if(!client){
					if(addClient((*event0).window, NULL)){
						updateOrder();
						calculateViewableWindowSizes();
						drawWallpaper();
					}
				}
				jmp eventLoop;
			}
			if(client){



				/*! causes errors here */



				fprintf(stdout, "reparent2\n");
				removeClient(client);
				updateOrder();
				calculateViewableWindowSizes();
				drawWallpaper();
			}
		}
		jmp eventLoop;
		#undef  event0
	}
	configureNotifyEvent:{
		#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if((*event0).window == overlayWindow){
			fprintf(stdout, "\n\n\noverlay in configure event?\n\n\n\n");
			jmp eventLoop;
		}
		if(!client){
			jmp eventLoop;
		}
		configureClient(client);
		updateOrder();
		calculateViewableWindowSizes();
		drawWallpaper();
		jmp eventLoop;
		#undef  event0
	}
	circulateNotifyEvent:{
		#define event0 /*-*/ ((xcb_circulate_notify_event_t *)event0)



		/*! maybe draw somewhere here but i don't have anything given to me to draw */



		updateOrder();
		calculateViewableWindowSizes();
		drawWallpaper();
		jmp eventLoop;
		#undef  event0
	}
	propertyNotifyEvent:{
		#define event0 /*-*/ ((xcb_property_notify_event_t *)event0)



		/*!
			xcb_get_atom_name_reply_t *reply = xcb_get_atom_name_reply(connection, xcb_get_atom_name(connection, (*event0).atom), NULL);
			if(reply){
				int length = xcb_get_atom_name_name_length(reply);
				printf("atom name: %.*s\n", length, xcb_get_atom_name_name(reply));
				free(reply);
			}
		*/



		if((*event0).atom == rootPixmapAtom and rootPixmapAtom){
			createWallpaper();
			drawWallpaper();
		}
		jmp eventLoop;
		#undef  event0
	}
	damageNotifyEvent:{
		#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
		const xcb_window_t window = (*event0).drawable;
		Client *const client = findClient(window);
		xcb_rectangle_t *geometry;
		if(window == (*screen).root){
			fprintf(stdout, "root damaged\n");
		}
		if(window == overlayWindow){
			fprintf(stdout, "overlay damaged\n");
		}
		if(!client or !(*client).mapped or !(*client).viewable){
			jmp eventLoop;
		}
		geometry = &(*event0).geometry;



		{
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region(connection, region, 1, geometry);
			/*! xcb_damage_subtract(connection, (*client).damage, XCB_NONE, XCB_NONE); */
			xcb_damage_subtract(connection, (*client).damage, XCB_NONE, region);
			xcb_xfixes_destroy_region(connection, region);
		}



		{
			const uint amount = getClientIntersectingRectangles(client, (*geometry).x, (*geometry).y, (*geometry).x + (*geometry).width, (*geometry).y + (*geometry).height);
			if(amount){
				const xcb_xfixes_region_t region = xcb_generate_id(connection);
				xcb_xfixes_create_region(connection, region, amount, rectangleStart);
				{
					xcb_xfixes_set_picture_clip_region(connection, (*client).picture, region, 0, 0);
					xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, (*geometry).x, (*geometry).y, (*geometry).width, (*geometry).height);
				}
				xcb_xfixes_destroy_region(connection, region);
			}
		}



		jmp drawRegion;
		#undef  event0
	}
	drawRegion:{



		if(bufferRegion){
			xcb_xfixes_set_picture_clip_region(connection, bufferPicture, bufferRegion, 0, 0);
			xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
			xcb_xfixes_destroy_region(connection, bufferRegion);
			bufferRegion = XCB_NONE;
		}



		jmp eventLoop;
	}
	errorEvent:{
		genericError = (void *)event0;
		printXCBError();
		genericError = NULL;
		jmp eventLoop;
	}
	unexpectedEvent:{
		jmp eventLoop;
	}
	badDamageError:{
		fprintf(stdout, "%s: bad damage error\n", programName);
		jmp eventLoop;
	}
	randrNotifyEvent:{
		fprintf(stdout, "%s: randr notify event\n", programName);



		/*! maybe not update wallpaper here? */

		xcb_render_free_picture(connection, rootPicture);
		xcb_render_free_picture(connection, bufferPicture);
		xcb_free_pixmap(connection, bufferPixmap);
		bufferPixmap = xcb_generate_id(connection);
		bufferPicture = xcb_generate_id(connection);
		rootPicture = xcb_generate_id(connection);
		xcb_create_pixmap(connection, (*screen).root_depth, bufferPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_render_create_picture(connection, bufferPicture, bufferPixmap, rootFormat, XCB_NONE, NULL);
		xcb_render_create_picture(connection, rootPicture, overlayWindow, rootFormat, XCB_NONE, NULL);



		jmp eventLoop;
	}
	randrNotifyError:{
		fprintf(stdout, "%s: randr notify error\n", programName);
		jmp eventLoop;
	}
	eventLoopExit:{
		free(event0);
		event0 = NULL;
		jmp mainEmergencyExit;
	}
	mainEmergencyExit:{



		free(visualStart);
		free(orderedClientOffsetStart);
		free(clientStart);



		xcb_render_free_picture(connection, wallpaperPicture);
		xcb_free_pixmap(connection, wallpaperPixmap);



		xcb_render_free_picture(connection, rootPicture);
		xcb_render_free_picture(connection, bufferPicture);
		xcb_free_pixmap(connection, bufferPixmap);



		xcb_composite_unredirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);



		xcb_disconnect(connection);
		connection = NULL;
		ret 0;
	}
}



























CREATEINTERSECTINGRECTANGLE(){
	int  rightX0 = leftX0 +  width0;
	int  rightX1 = leftX1 +  width1;
	int bottomY0 =  topY0 + height0;
	int bottomY1 =  topY1 + height1;
	if(leftX1 < rightX0 and rightX1 > leftX0 and topY1 < bottomY0 and bottomY1 > topY0){
		*retX =    leftX0 >   leftX1?   leftX0 :   leftX1;
		*retY =     topY0 >    topY1?    topY0 :    topY1;
		*retW = ( rightX0 <  rightX1?  rightX0 :  rightX1) - *retX;
		*retH = (bottomY0 < bottomY1? bottomY0 : bottomY1) - *retY;
		ret true;
	}
	ret false;
}
SPLITRECTANGLE(){
	xcb_rectangle_t *current;
	if(*allocated + 4 >= *size){
		void *temp;
		*size += RECTANGLE_BLOCK_SIZE;
		if(!(temp = realloc(*rectangle, *size * sizeof(xcb_rectangle_t)))){
			jmp emergencyExit;
		}
		*rectangle = temp;
	}
	current = *rectangle + *allocated;
	if(interY > y){
		(*current).x = x;
		(*current).y = y;
		(*current).width = w;
		(*current).height = interY - y;
		inc current;
	}
	if(interY + interH < y + h){
		(*current).x = x;
		(*current).y = interY + interH;
		(*current).width = w;
		(*current).height = y + h - interY - interH;
		inc current;
	}
	if(interX > x){
		(*current).x = x;
		(*current).y = interY;
		(*current).width = interX - x;
		(*current).height = interH;
		inc current;
	}
	if(interX + interW < x + w){
		(*current).x = interX + interW;
		(*current).y = interY;
		(*current).width = x + w - interX - interW;
		(*current).height = interH;
		inc current;
	}
	*allocated = current - *rectangle;
	ret;
	emergencyExit:{



		/*! realloc will eventually fail. what do? */



		*size = RECTANGLE_BLOCK_SIZE;
		*allocated = 0;
		free(*rectangle);
		*rectangle = NULL;
		ret;
	}
}
CALCULATEVIEWABLEWINDOWSIZES(){



	/*! update this ffs */



	const uint *belowCurrent = orderedClientOffsetStart - 1;
	const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
	jmp resetClientRectangle;
	resetClientRectangle:{
		Client *client = clientStart;
		jmp resetClientRectangleLoop;
		resetClientRectangleLoop:{
			if(client < clientWall){
				xcb_rectangle_t *rectangle = (*client).rectangle;
				if(rectangle){
					(*rectangle).x = (*client).x;
					(*rectangle).y = (*client).y;
					(*rectangle).width = (*client).w;
					(*rectangle).height = (*client).h;
					(*client).allocated = 1;
				}
				inc client;
				jmp resetClientRectangleLoop;
			}
		}
		jmp belowClientLoop;
	}
	belowClientLoop:{
		if(inc belowCurrent < offsetWall){
			Client *below = clientStart + *belowCurrent;
			const uint *aboveCurrent;
			if(*belowCurrent == (uint)-1 or !(*below).mapped or !(*below).viewable){
				jmp belowClientLoop;
			}
			aboveCurrent = belowCurrent;
			jmp aboveClientLoop;
			aboveClientLoop:{
				if(inc aboveCurrent < offsetWall){
					Client *const above = clientStart + *aboveCurrent;
					int x;
					int y;
					int w;
					int h;
					if(*aboveCurrent == (uint)-1 or !(*above).mapped or !(*above).viewable){
						jmp aboveClientLoop;
					}
					if(createIntersectingRectangle((*above).x, (*above).y, (*above).w, (*above).h, (*below).x, (*below).y, (*below).w, (*below).h, &x, &y, &w, &h)){
						xcb_rectangle_t *rectangle = (*below).rectangle;
						if(rectangle){
							xcb_rectangle_t *rectangleWall = rectangle + (*below).allocated;
							uint size = RECTANGLE_BLOCK_SIZE;
							uint allocated = 0;
							xcb_rectangle_t *newRectangle = malloc(size * sizeof(xcb_rectangle_t));
							if(!newRectangle){
								fprintf(stdout, "\n\n\nproblem1\n\n\n\n");
								ret;
							}
							jmp splitRectanglesLoop;
							splitRectanglesLoop:{
								if(rectangle < rectangleWall){
									if(createIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, (*above).x, (*above).y, (*above).w, (*above).h, &x, &y, &w, &h)){
										splitRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, x, y, w, h, &size, &allocated, &newRectangle);
									}else{
										if(allocated == size){
											void *temp;
											size += RECTANGLE_BLOCK_SIZE;
											if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){
												ret;
											}
											newRectangle = temp;
										}
										*(newRectangle + allocated) = *rectangle;
										inc allocated;
									}
									inc rectangle;
									jmp splitRectanglesLoop;
								}
							}
							free((*below).rectangle);
							(*below).size = size;
							(*below).allocated = allocated;
							(*below).rectangle = newRectangle;
						}
					}
					jmp aboveClientLoop;
				}
			}
			jmp belowClientLoop;
		}
	}









	/*! {
		uint *current = orderedClientOffsetStart;
		uint *wall = orderedClientOffsetStart + clientAllocated;
		uint i = 0;
		while(current < wall){
			if(*current != -1){
				Client *client = clientStart + *current;
				if((*client).mapped and (*client).viewable){
					xcb_rectangle_t *rectangle = (*client).rectangle;
					xcb_rectangle_t *wall = (*client).rectangle + (*client).allocated;
					fprintf(stdout, "\tclient %u:\n", i);
					inc i;
					while(rectangle < wall){
						fprintf(stdout, "\t\t%i %i %i %i\n", (*rectangle).x, (*rectangle).y, (*rectangle).widthidth, (*rectangle).heighteight);
						inc rectangle;
					}
				}
			}
			inc current;
		}
		fprintf(stdout, "\n\n\n");
	} */



	ret;
}
CREATEWALLPAPER(){
	{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		xcb_rectangle_t rectangle;
		rectangle.x = 0;
		rectangle.y = 0;
		rectangle.width = (*screen).width_in_pixels;
		rectangle.height = (*screen).height_in_pixels;
		xcb_create_gc(connection, gc, wallpaperPixmap, XCB_NONE, NULL);
		xcb_poly_fill_rectangle(connection, wallpaperPixmap, gc, 1, &rectangle);
		xcb_free_gc(connection, gc);
	}
	if(rootPixmapAtom and pixmapAtom){
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL);
		if(reply){
			if((*reply).type != pixmapAtom){
				fprintf(stdout, "%s: root pixmap is not of type pixmap\n", programName);
			}else{
				const xcb_pixmap_t pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
				const xcb_get_geometry_cookie_t cookie = xcb_get_geometry_unchecked(connection, pixmap);
				const xcb_gcontext_t gc = xcb_generate_id(connection);
				xcb_get_geometry_reply_t *geometryReply;
				uint width = (*screen).width_in_pixels;
				uint height = (*screen).height_in_pixels;
				xcb_create_gc(connection, gc, pixmap, XCB_NONE, NULL);
				if((geometryReply = xcb_wait_for_reply(connection, cookie, NULL))){
					width = (*geometryReply).width;
					height = (*geometryReply).height;
					free(geometryReply);
				}
				xcb_copy_area(connection, pixmap, wallpaperPixmap, gc, 0, 0, 0, 0, width, height);
				xcb_free_gc(connection, gc);
			}
			free(reply);
		}
	}
	ret;
}
DRAWWALLPAPER(){
	rootClient.x = 0;
	rootClient.y = 0;
	rootClient.w = (*screen).width_in_pixels;
	rootClient.h = (*screen).height_in_pixels;
	rootClient.size = RECTANGLE_BLOCK_SIZE;
	rootClient.allocated = 0;
	if(!rootClient.rectangle){
		rootClient.rectangle = malloc(RECTANGLE_BLOCK_SIZE * sizeof(xcb_rectangle_t));
	}
	{
		xcb_rectangle_t *rectangle = rootClient.rectangle;
		if(rectangle){
			(*rectangle).x = rootClient.x;
			(*rectangle).y = rootClient.y;
			(*rectangle).width = rootClient.w;
			(*rectangle).height = rootClient.h;
			rootClient.allocated = 1;
		}
	}



	{
		const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
		const uint *aboveCurrent = orderedClientOffsetStart - 1;
		jmp aboveClientLoop;
		aboveClientLoop:{
			if(inc aboveCurrent < offsetWall){
				Client *const above = clientStart + *aboveCurrent;
				int x;
				int y;
				int w;
				int h;
				if(*aboveCurrent == (uint)-1 or !(*above).mapped or !(*above).viewable){
					jmp aboveClientLoop;
				}
				if(createIntersectingRectangle((*above).x, (*above).y, (*above).w, (*above).h, rootClient.x, rootClient.y, rootClient.w, rootClient.h, &x, &y, &w, &h)){
					xcb_rectangle_t *rectangle = rootClient.rectangle;
					if(rectangle){
						xcb_rectangle_t *rectangleWall = rectangle + rootClient.allocated;
						uint size = RECTANGLE_BLOCK_SIZE;
						uint allocated = 0;



						/*! create a buffer to switch with the buffer on a given client */



						xcb_rectangle_t *newRectangle = malloc(size * sizeof(xcb_rectangle_t));
						if(!newRectangle){
							fprintf(stdout, "\n\n\nproblem1\n\n\n\n");
							ret;
						}
						jmp splitRectanglesLoop;
						splitRectanglesLoop:{
							if(rectangle < rectangleWall){
								if(createIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, (*above).x, (*above).y, (*above).w, (*above).h, &x, &y, &w, &h)){
									splitRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, x, y, w, h, &size, &allocated, &newRectangle);
								}else{
									if(allocated == size){
										void *temp;
										size += RECTANGLE_BLOCK_SIZE;
										if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){
											ret;
										}
										newRectangle = temp;
									}
									*(newRectangle + allocated) = *rectangle;
									inc allocated;
								}
								inc rectangle;
								jmp splitRectanglesLoop;
							}
						}
						free(rootClient.rectangle);
						rootClient.size = size;
						rootClient.allocated = allocated;
						rootClient.rectangle = newRectangle;
					}
				}
				jmp aboveClientLoop;
			}
		}
	}
	if(rootClient.allocated){
		const xcb_xfixes_region_t region = xcb_generate_id(connection);
		xcb_xfixes_create_region(connection, region, rootClient.allocated, rootClient.rectangle);
		copyToBuffer(region, wallpaperPicture);
	}



	ret;
}
COPYTOBUFFER(){
	xcb_xfixes_set_picture_clip_region(connection, picture, region, 0, 0);
	xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, picture, XCB_NONE, bufferPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
	if(!bufferRegion){
		bufferRegion = region;
		ret;
	}
	xcb_xfixes_union_region(connection, region, bufferRegion, bufferRegion);
	xcb_xfixes_destroy_region(connection, region);
	ret;
}
ADDCLIENT(){
	#define event /*-*/ ((xcb_create_notify_event_t *)event)
	xcb_get_window_attributes_cookie_t attributesCookie;
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_get_window_attributes_reply_t *attributesReply;
	xcb_get_geometry_reply_t *geometryReply = NULL;
	Client *client;
	if(window == overlayWindow){
		ret false;
	}
	attributesCookie = xcb_get_window_attributes_unchecked(connection, window);
	if(!event){
		geometryCookie = xcb_get_geometry_unchecked(connection, window);
	}
	attributesReply = xcb_wait_for_reply(connection, attributesCookie, NULL);
	if(!event){
		geometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
	}



	/*! error somewhere when reparenting the discord window */









	/*! even if some shit fails, add the client with defaults */



	if(!attributesReply or (!event and !geometryReply)){
		fprintf(stdout, "could not add client %x due to replies\n", window);
		jmp emergencyExit;
	}



	if(clientAllocated == clientSize){
		void *temp;
		void *temp1;
		clientSize += CLIENT_BLOCK_SIZE;
		if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
			jmp emergencyExit;
		}
		clientStart = temp;
		if(!(temp1 = realloc(orderedClientOffsetStart, clientSize * sizeof(uint)))){
			jmp emergencyExit;
		}
		orderedClientOffsetStart = temp1;
	}
	client = clientStart + clientAllocated;









	if(event){
		(*client).x = (*event).x;
		(*client).y = (*event).y;
		(*client).w = (*event).width + 2 * (*event).border_width;
		(*client).h = (*event).height + 2 * (*event).border_width;
	}elif(geometryReply){
		(*client).x = (*geometryReply).x;
		(*client).y = (*geometryReply).y;
		(*client).w = (*geometryReply).width + 2 * (*geometryReply).border_width;
		(*client).h = (*geometryReply).height + 2 * (*geometryReply).border_width;
	}else{
		(*client).x = (*screen).width_in_pixels;
		(*client).y = (*screen).height_in_pixels;
		(*client).w = 0;
		(*client).h = 0;
	}
	(*client).rightX = (*client).x + (*client).w;
	(*client).bottomY = (*client).y + (*client).h;



	(*client).window = window;
	(*client).visual = (*attributesReply).visual;
	(*client).format = findFormat((*client).visual);
	(*client).damage = XCB_NONE;
	(*client).picture = XCB_NONE;



	(*client).mapped = (*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED;
	(*client).viewable = !((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels);



	(*client).size = RECTANGLE_BLOCK_SIZE;
	(*client).allocated = 0;
	(*client).rectangle = malloc((*client).size * sizeof(xcb_rectangle_t));



	xcb_change_window_attributes(connection, window, XCB_CW_EVENT_MASK, &windowValueList);



	if((*attributesReply)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
		(*client).damage = xcb_generate_id(connection);
		(*client).picture = xcb_generate_id(connection);
		xcb_damage_create(connection, (*client).damage, window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);



		/*! absolute bastard. why? */

		xcb_render_create_picture_checked(connection, (*client).picture, window, (*client).format, XCB_NONE, NULL);
	}



	(*client).useSpecialEffect = false;



	free(attributesReply);
	free(geometryReply);



	inc clientAllocated;
	inc clientWall;
	ret true;



	emergencyExit:{
		free(attributesReply);
		free(geometryReply);
		ret false;
	}
	#undef  event
}
UPDATEORDER(){
	if(treeReply){



		/*! optimize this */



		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
		uint *orderedClientOffsetCurrent = orderedClientOffsetStart;
		jmp findClientWindowLoop;
		findClientWindowLoop:{
			Client *const client = findClient(*windowCurrent);
			if(client){
				*orderedClientOffsetCurrent = client - clientStart;
			}else{
				*orderedClientOffsetCurrent = -1;
				if(*windowCurrent == overlayWindow){
					dec orderedClientOffsetCurrent;
				}
			}
			if(inc windowCurrent < windowWall){
				inc orderedClientOffsetCurrent;
				jmp findClientWindowLoop;
			}
		}
	}
	ret;
}









local bool createIntersectingRectangle1(const int leftX0, const int topY0, const int rightX0, const int bottomY0, const int leftX1, const int topY1, const int rightX1, const int bottomY1, xcb_rectangle_t *const rectangle){
	if(leftX1 < rightX0 and rightX1 > leftX0 and topY1 < bottomY0 and bottomY1 > topY0){
		(*rectangle).x      =    leftX0 >   leftX1?   leftX0 :   leftX1;
		(*rectangle).y      =     topY0 >    topY1?    topY0 :    topY1;
		(*rectangle).width  = ( rightX0 <  rightX1?  rightX0 :  rightX1) - (*rectangle).x;
		(*rectangle).height = (bottomY0 < bottomY1? bottomY0 : bottomY1) - (*rectangle).y;
		ret true;
	}
	ret false;
}
GETCLIENTINTERSECTINGRECTANGLES(){
	if(!rectangleStart){
		ret 0;
	}
	{
		const xcb_rectangle_t *rectangle = (*client).rectangle;
		const xcb_rectangle_t *const wall = rectangle + (*client).allocated;
		xcb_rectangle_t *rectangleCurrent = rectangleStart;
		jmp createIntersectingRectangleLoop;
		createIntersectingRectangleLoop:{
			if(rectangle < wall){
				rectangleCurrent += createIntersectingRectangle1((*rectangle).x, (*rectangle).y, (*rectangle).x + (*rectangle).width, (*rectangle).y + (*rectangle).height, eventLeftX, eventTopY, eventRightX, eventBottomY, rectangleCurrent);
				inc rectangle;
				jmp createIntersectingRectangleLoop;
			}
			ret rectangleCurrent - rectangleStart;
		}
	}
}
UNMAPWINDOW(){
	(*client).mapped = false;
	drawBelowClient(client);
	ret;
}
CONFIGURECLIENT(){
	#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)



	/*! doesn't do anything because no windows seem to be beneath this one */

	drawBelowClient(client);



	if((*client).picture){
		xcb_render_free_picture(connection, (*client).picture);
		(*client).picture = xcb_generate_id(connection);
		xcb_render_create_picture(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL);
	}
	(*client).x = (*event0).x;
	(*client).y = (*event0).y;
	(*client).w = (*event0).width + 2 * (*event0).border_width;
	(*client).h = (*event0).height + 2 * (*event0).border_width;
	(*client).rightX = (*client).x + (*client).w;
	(*client).bottomY = (*client).y + (*client).h;
	(*client).viewable = !((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels);
	ret;
	#undef  event0
}
DRAWBELOWCLIENT(){



	/*! can be theoretically much slower for high amount of overlapping windows but who cares honestly */



	const uint *offsetCurrent = orderedClientOffsetStart;
	const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
	const uint eventX = (*client).x;
	const uint eventY = (*client).y;
	const uint eventW = (*client).w;
	const uint eventH = (*client).h;
	xcb_xfixes_region_t localRegion = XCB_NONE;
	jmp loop;
	loop:{
		if(offsetCurrent < offsetWall){
			const Client *const current = clientStart + *offsetCurrent;
			int x;
			int y;
			int w;
			int h;
			if((*current).mapped and (*current).viewable and current != client and createIntersectingRectangle((*current).x, (*current).y, (*current).w, (*current).h, eventX, eventY, eventW, eventH, &x, &y, &w, &h)){
				const uint amount = getClientIntersectingRectangles(current, x, y, x + w, y + h);
				if(amount){
					const xcb_xfixes_region_t region = xcb_generate_id(connection);
					xcb_xfixes_create_region(connection, region, amount, rectangleStart);
					{
						xcb_xfixes_set_picture_clip_region(connection, (*current).picture, region, 0, 0);
						xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*current).picture, XCB_NONE, bufferPicture, x - (*current).x, y - (*current).y, 0, 0, x, y, w, h);
					}
					if(!localRegion){
						localRegion = region;
					}else{
						xcb_xfixes_union_region(connection, region, localRegion, localRegion);
						xcb_xfixes_destroy_region(connection, region);
					}
				}
			}
			inc offsetCurrent;
			jmp loop;
		}
	}
	if(localRegion){
		xcb_xfixes_set_picture_clip_region(connection, bufferPicture, localRegion, 0, 0);
		xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, eventX, eventY, 0, 0, eventX, eventY, eventW, eventH);
		xcb_xfixes_destroy_region(connection, localRegion);
	}
	ret;
}
MAPWINDOW(){
	(*client).mapped = true;
	{
		const uint amount = getClientIntersectingRectangles(client, (*client).x, (*client).y, (*client).rightX, (*client).bottomY);
		if(amount){
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region(connection, region, amount, rectangleStart);
			{
				xcb_xfixes_set_picture_clip_region(connection, (*client).picture, region, 0, 0);
				xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).w, (*client).h);
			}
			xcb_xfixes_destroy_region(connection, region);
		}
	}
	ret;
}
DRAWALLCLIENTS(){



	/*! verify it works properly */

	/*! change XCB_RENDER_PICT_OP_SRC to XCB_RENDER_PICT_OP_OVER later */

	const uint *offsetCurrent = orderedClientOffsetStart;
	const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
	xcb_xfixes_region_t localRegion = XCB_NONE;
	jmp loop;
	loop:{
		if(offsetCurrent < offsetWall){
			const Client *const current = clientStart + *offsetCurrent;
			if((*current).mapped and (*current).viewable){
				const xcb_xfixes_region_t region = xcb_generate_id(connection);
				xcb_rectangle_t rectangle;
				rectangle.x = (*current).x;
				rectangle.y = (*current).y;
				rectangle.width = (*current).w;
				rectangle.height = (*current).h;
				xcb_xfixes_create_region(connection, region, 1, &rectangle);
				{
					xcb_xfixes_set_picture_clip_region(connection, (*current).picture, region, 0, 0);
					xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*current).picture, XCB_NONE, bufferPicture, 0, 0, 0, 0, (*current).x, (*current).y, (*current).w, (*current).h);
				}
				if(!localRegion){
					localRegion = region;
				}else{
					xcb_xfixes_union_region(connection, region, localRegion, localRegion);
					xcb_xfixes_destroy_region(connection, region);
				}
			}
			inc offsetCurrent;
			jmp loop;
		}
	}
	if(localRegion){
		xcb_xfixes_set_picture_clip_region(connection, bufferPicture, localRegion, 0, 0);
		xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_xfixes_destroy_region(connection, localRegion);
	}
	ret;
}



























FINDFORMAT(){
	const xcb_render_pictvisual_t *current = visualStart;
	jmp findVisualLoop;
	findVisualLoop:{
		if(current < visualWall){
			if((*current).visual == visual){
				ret (*current).format;
			}
			inc current;
			jmp findVisualLoop;
		}
		ret XCB_NONE;
	}
}
QUERYTREE(){
	const xcb_query_tree_cookie_t cookie = xcb_query_tree_unchecked(connection, (*screen).root);
	if(treeReply){
		free(treeReply);
	}
	treeReply = xcb_wait_for_reply(connection, cookie, NULL);
	ret;
}
FINDCLIENT(){
	const uint8 *const firstWindow = (void *)&(*clientStart).window;
	const uint8 *current = firstWindow;
	jmp findClientLoop;
	findClientLoop:{
		if(*(xcb_window_t *)current == window){
			ret (void *)(current - (firstWindow - (uint8 *)clientStart));
		}
		if((current += sizeof(Client)) < (uint8 *)clientWall){
			jmp findClientLoop;
		}
		ret NULL;
	}
}
REMOVECLIENT(){

	/*! both free functions below can free something that shouldn't be getting free'd, fucking somehow */


	if((*client).damage){
		xcb_damage_destroy_checked(connection, (*client).damage);
	}
	if((*client).picture){
		xcb_render_free_picture_checked(connection, (*client).picture);
	}
	*client = *(dec clientWall);
	dec clientAllocated;
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		fprintf(errorStream, "%s: %s\n", programName, string);
		closeErrorStream();
	}
	ret;
}
OPENERRORSTREAM(){
	ret !mustOpenErrorStream or (errorStream = fopen(errorPath, "a"));
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		errorStream = NULL;
	}
	ret;
}
PRINTCONNECTIONERROR(){
	if(openErrorStream()){
		#define PRINTCONNECTIONERROR_ERROR /*--*/ xcb_connection_has_error(connection)
		#define PRINTCONNECTIONERROR_STREAM /*-*/ errorStream
		#include "xcb/printConnectionError.hold"
		closeErrorStream();
	}
	ret;
}
PRINTXCBERROR(){
	if(openErrorStream()){
		#define PRINTXCBERROR_ERROR /*--*/ genericError
		#define PRINTXCBERROR_STREAM /*-*/ errorStream
		#include "xcb/printXCBError.hold"
		closeErrorStream();
	}
	ret;
}
