/*!
	fix all kinds of issues that can be safely called basic and then move onto 32 bit window handling.

	basic includes faultless composition at idle-tier speeds where all windows are treated as 24 bit.
	then deal with how the wallpaper works and then deal with 32 bit windows.
*/

/*!
	check for monitor change issues
*/

/*!
	rectangle splitting can create rectangles that can be combined into one (yikes)
*/

/*!
	windows that move will leave a trail until the below window is updated.
*/

/*!
	findClient() should be used only after a fastFindClient() is used.

	fastFindClient() should hold the n, say 5, last seen windows.

	maybe implement a mappedFindClient()
*/

/*!
	consider getting up to n events from the loop and doing them at the same time
*/

/*!
	keep non-input-output windows?
*/

/*!
	store windows each client is intersecting with?
*/

/*!
	something that is actively moving, namely the i3 bar between windows, will prevent drawing everything else
*/

/*!
	some bug causes endless unrecognized errors with no more drawing on screen, at least for the window the bug happens on.
*/

/*!
	on creating a window and mapping it we get a flash on the monitor that shouldn't be there
*/

/*!
	microsound has been observed to be completely black when the compositor is already running and then microsound is run

	then again microsound has just been observed to be black
*/

/*!
	some of the events received seem to be double the ones we expect. changing event mask on windows obtained fixes the event problem but introduces the unmapped-but-still-drawn visual artifact.
*/

/*!
	steam username and notification button causing issues (misplaced window + it's often just white)
*/

/*!
	weird artifacting when window is in nvidia monitor...? probably the fact multiple xcb_render_composite() calls are made to composite a single result.
*/

/*!
	program can still crash
*/



#ifdef a
xcb_window_t fastFindWindowList[5] = {
	  XCB_NONE
	, XCB_NONE
	, XCB_NONE
	, XCB_NONE
	, XCB_NONE
};

uint startWindowOffset = 0;
uint endWindowOffset = 0;

local void fastFindWindow(const xcb_window_t window){
	uint currentOffset = startWindowOffset;
	while(currentOffset < endWindowOffset)



		a



	}
	ret;
}
#endif



























/*! microcompositor.cold

MIT License

Copyright (C) 2023 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#include <stdint.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <xcb/composite.h>
	#include <xcb/damage.h>
	#include <xcb/randr.h>
	#include <xcb/render.h>
	#include <xcb/shape.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include "cold/cold.hold"
/*!}*/

/*!user_defines:{*/
	#define DefaultErrorStream /*-------------*/ (stderr)
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------*/ (true)

	#define _EMPTY_MACRO /*----------------------*/

	#define FINDCLIENT() /*----------------------*/ local Client                  *findClient(const xcb_window_t window)
	#define UNMAPCLIENT() /*---------------------*/ local void                     unmapClient(Client *const client)
	#define DRAWBELOWCLIENT() /*-----------------*/ local void                     drawBelowClient(const Client *const client)
	#define MAPCLIENT() /*-----------------------*/ local void                     mapClient(Client *const client)
	#define ADDCLIENT() /*-----------------------*/ local bool                     addClient(const xcb_window_t window)
	#define CONFIGURECLIENT() /*-----------------*/ local void                     configureClient(Client *const client)
	#define QUERYTREE() /*-----------------------*/ local void                     queryTree(void)
	#define UPDATEORDER() /*---------------------*/ local void                     updateOrder(void)
	#define CREATEINTERSECTINGRECTANGLE() /*-----*/ local bool                     createIntersectingRectangle(int leftX0, int topY0, int width0, int height0, int leftX1, int topY1, int width1, int height1, int *retX, int *retY, int *retW, int *retH)
	#define SPLITRECTANGLE() /*------------------*/ local void                     splitRectangle(const int x, const int y, const int w, const int h, int interX, int interY, int interW, int interH, uint *size, uint *allocated, xcb_rectangle_t **rectangle)
	#define CALCULATEVIEWABLEWINDOWSIZES() /*----*/ local void                     calculateViewableWindowSizes(void)
	#define SETWALLPAPER() /*--------------------*/ local void                     setWallpaper(void)
	#define CREATEWALLPAPER() /*-----------------*/ local void                     createWallpaper(void)
	#define DRAWWALLPAPER() /*-------------------*/ local void                     drawWallpaper(void)
	#define FINDFORMAT() /*----------------------*/ local xcb_render_pictformat_t  findFormat(const xcb_visualid_t visual, const uint8 depth)
	#define GETCLIENTINTERSECTINGRECTANGLES() /*-*/ local uint                     getClientIntersectingRectangles(const Client *const client, const int leftX0, const int topY0, const int rightX0, const int bottomY0)
	#define DRAWALLCLIENTS() /*------------------*/ local void                     drawAllClients(void)
	#define DESTROYCLIENT() /*-------------------*/ local void                     destroyClient(Client *const client)
	#define CIRCULATECLIENTS() /*----------------*/ local void                     circulateClients(void)
	#define DAMAGECLIENT() /*--------------------*/ local void                     damageClient(Client *const client)
	#define DRAWCLIENT() /*----------------------*/ local void                     drawClient(Client *const client)
	#define CREATEROOTPICTURE() /*---------------*/ local void                     createRootPicture(void)



	#define PRINTERROR() /*----------------------*/ local void    printError(const char *const string)
	#define OPENERRORSTREAM() /*-----------------*/ local bool    openErrorStream(void)
	#define CLOSEERRORSTREAM() /*----------------*/ local void    closeErrorStream(void)
	#define PRINTCONNECTIONERROR() /*------------*/ local void    printConnectionError(void)
	#define PRINTXCBERROR() /*-------------------*/ local void    printXCBError(void)

	#define xcb_wait_for_reply(a, b, c) /*-------*/ (xcb_wait_for_reply(a, (b).sequence, c))

	#define LITERAL_LENGTH(l) /*-----------------*/ (sizeof(l) - 1)

	#define _b(d, b) /*--------------------------*/ (d > (sizeof(#b) - 1)? 0 : ((*(#b + (sizeof(#b) - 1) - d) - 48) == 1) * ((uint64)1 << (d - 1)))

	#define b(b) /*------------------------------*/ ( \
		  _b( 1, b) + _b( 2, b) + _b( 3, b) + _b( 4, b) + _b( 5, b) + _b( 6, b) + _b( 7, b) + _b( 8, b) \
		+ _b( 9, b) + _b(10, b) + _b(11, b) + _b(12, b) + _b(13, b) + _b(14, b) + _b(15, b) + _b(16, b) \
		+ _b(17, b) + _b(18, b) + _b(19, b) + _b(20, b) + _b(21, b) + _b(22, b) + _b(23, b) + _b(24, b) \
		+ _b(25, b) + _b(26, b) + _b(27, b) + _b(28, b) + _b(29, b) + _b(30, b) + _b(31, b) + _b(32, b) \
		+ _b(33, b) + _b(34, b) + _b(35, b) + _b(36, b) + _b(37, b) + _b(38, b) + _b(39, b) + _b(40, b) \
		+ _b(41, b) + _b(42, b) + _b(43, b) + _b(44, b) + _b(45, b) + _b(46, b) + _b(47, b) + _b(48, b) \
		+ _b(49, b) + _b(50, b) + _b(51, b) + _b(52, b) + _b(53, b) + _b(54, b) + _b(55, b) + _b(56, b) \
		+ _b(57, b) + _b(58, b) + _b(59, b) + _b(60, b) + _b(61, b) + _b(62, b) + _b(63, b) + _b(64, b) \
	)

	#define VISUAL_FORMAT_PAIR_BLOCK_SIZE /*-----*/ (4)
	#define RECTANGLE_BLOCK_SIZE /*--------------*/ (8)
	#define CLIENT_BLOCK_SIZE /*-----------------*/ (128)

	#define NONE_MAP_INFO /*---------------------*/ (0)
	#define MAPPED_MAP_INFO /*-------------------*/ (1 << 0)
	#define VIEWABLE_MAP_INFO /*-----------------*/ (1 << 1)
/*!}*/

/*!defs:{*/
	def struct{
		uint32 /*------------------*/ size;
		uint32 /*------------------*/ allocated;
		xcb_rectangle_t * /*-------*/ rectangle;

		xcb_window_t /*------------*/ window;
		xcb_damage_damage_t /*-----*/ damage;
		xcb_render_pictformat_t /*-*/ format;
		xcb_render_picture_t /*----*/ picture;

		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		int32 /*-------------------*/ w;
		int32 /*-------------------*/ h;
		int32 /*-------------------*/ rightX;
		int32 /*-------------------*/ bottomY;

		bool /*--------------------*/ shaped;
		uint8 /*-------------------*/ mapInfo;
		uint8 /*-------------------*/ depth;
		bool /*--------------------*/ useSpecialEffect;

		uint8 /*-------------------*/ pad0[4];
	} Client;

	def struct{
		uint16 /*------------------*/ x;
		uint16 /*------------------*/ y;
		uint16 /*------------------*/ w;
		uint16 /*------------------*/ h;
	} Monitor;
/*!}*/

/*!globals:{*/
	const char * /*----------*/ programName;
	const char * /*----------*/ errorPath;
	const char * /*----------*/ connectionName;
	const xcb_screen_t * /*--*/ screen;
	const char * /*----------*/ quitMessage;
	bool /*------------------*/ mustOpenErrorStream;
	FILE * /*----------------*/ errorStream;
	xcb_connection_t * /*----*/ connection;
	xcb_generic_error_t * /*-*/ genericError;
	xcb_generic_event_t * /*-*/ event0;



	const uint32 windowValueList = XCB_EVENT_MASK_VISIBILITY_CHANGE;
	uint damageBaseEvent;
	uint damageBaseError;
	uint renderBaseEvent;
	uint renderBaseError;
	uint randrBaseEvent;
	uint randrBaseError;



	Client                  rootClient;
	xcb_atom_t              pixmapAtom;
	xcb_atom_t              rootPixmapAtom;
	xcb_render_pictformat_t rootFormat;
	xcb_pixmap_t            wallpaperPixmap;
	xcb_render_picture_t    wallpaperPicture;
	xcb_pixmap_t            bufferPixmap;
	xcb_render_picture_t    bufferPicture;
	xcb_render_picture_t    rootPicture;
	xcb_xfixes_region_t     globalRegion;



	uint visualSize;
	uint visualAllocated;
	xcb_render_pictvisual_t *visualStart;
	xcb_render_pictvisual_t *visualWall;
	uint defaultOpaqueVisualOffset;
	uint defaultTransparentVisualOffset;



	uint clientSize;
	uint clientAllocated;
	Client *clientStart;
	Client *clientWall;



	uint monitorAmount;
	void *monitorData;
	Monitor *monitorStart;
	Monitor *monitorWall;



	uint *orderedClientOffsetStart;
	xcb_window_t overlayWindow;
	xcb_rectangle_t *rectangleStart;
	xcb_query_tree_reply_t *treeReply;
/*!}*/

/*!functions:{*/
	FINDCLIENT();
	UNMAPCLIENT();
	DRAWBELOWCLIENT();
	MAPCLIENT();
	ADDCLIENT();
	QUERYTREE();
	UPDATEORDER();
	CREATEINTERSECTINGRECTANGLE();
	SPLITRECTANGLE();
	CALCULATEVIEWABLEWINDOWSIZES();
	SETWALLPAPER();
	CREATEWALLPAPER();
	FINDFORMAT();
	CONFIGURECLIENT();
	GETCLIENTINTERSECTINGRECTANGLES();
	DRAWWALLPAPER();
	DRAWALLCLIENTS();
	DESTROYCLIENT();
	CIRCULATECLIENTS();
	DAMAGECLIENT();
	DRAWCLIENT();
	CREATEROOTPICTURE();

	PRINTERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
	PRINTCONNECTIONERROR();
	PRINTXCBERROR();
/*!}*/

int main(const int argumentAmount, const char *const *argument){
	(void)argumentAmount;
	jmp setPrimaryGlobals;
	setPrimaryGlobals:{
		programName /*----------*/ = *argument;
		errorPath /*------------*/ = NULL;
		connectionName /*-------*/ = NULL;
		mustOpenErrorStream /*--*/ = false;
		errorStream /*----------*/ = DefaultErrorStream;
		connection /*-----------*/ = NULL;
		genericError /*---------*/ = NULL;
		event0 /*---------------*/ = NULL;
		quitMessage /*----------*/ = NULL;
		treeReply /*------------*/ = NULL;



		rootClient.rectangle /*-*/ = NULL;
		rectangleStart /*-------*/ = NULL;
		clientSize /*-----------*/ = CLIENT_BLOCK_SIZE;
		clientAllocated /*------*/ = 0;

		bufferPixmap /*---------*/ = XCB_NONE;
		rootPicture /*----------*/ = XCB_NONE;
		bufferPicture /*--------*/ = XCB_NONE;

		wallpaperPixmap /*------*/ = XCB_NONE;
		wallpaperPicture /*-----*/ = XCB_NONE;

		globalRegion /*---------*/ = XCB_NONE;



		jmp establishServerConnection;
	}
	establishServerConnection:{
		#define ESTABLISHSERVERCONNECTION_CONNECTION /*-----*/ connection
		#define ESTABLISHSERVERCONNECTION_CONNECTIONNAME /*-*/ connectionName
		#define ESTABLISHSERVERCONNECTION_SCREEN /*---------*/ screen
		#include "xcb/establishServerConnection.hold"
		switch xcb_connection_has_error(connection) over
			to XCB_NONE: /*------------*/ /*-----------------------------------------------------------------*/ brk;
			to XCB_CONN_CLOSED_PARSE_ERR: printError(connectionName? "invalid server name" : "no server name"); jmp mainEmergencyExit;
			off: /*--------------------*/ printConnectionError(); /*-----------------------------------------*/ jmp mainEmergencyExit;
		end
	}



	{
		xcb_grab_server(connection);
	}



	damageBaseEvent = 0;
	damageBaseError = 0;
	renderBaseEvent = 0;
	renderBaseError = 0;
	randrBaseEvent = 0;
	randrBaseError = 0;
	{
		const xcb_query_extension_cookie_t compositeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("Composite"), "Composite");
		const xcb_query_extension_cookie_t damageCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("DAMAGE"), "DAMAGE");
		const xcb_query_extension_cookie_t randrCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RANDR"), "RANDR");
		const xcb_query_extension_cookie_t renderCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RENDER"), "RENDER");
		const xcb_query_extension_cookie_t xfixesCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("XFIXES"), "XFIXES");
		const xcb_query_extension_cookie_t shapeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("SHAPE"), "SHAPE");
		xcb_query_extension_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_query_extension_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_query_extension_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_query_extension_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_query_extension_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_query_extension_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(!compositeReply or !(*compositeReply).present){
			fprintf(stdout, "composite extension not available\n");
		}else{
			free(compositeReply);
		}
		if(!damageReply or !(*damageReply).present){
			fprintf(stdout, "damage extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_damage_id);
			if(reply and (*reply).present){
				damageBaseEvent = (*reply).first_event;
				damageBaseError = (*reply).first_error;
			}
			free(damageReply);
		}
		if(!randrReply or !(*randrReply).present){
			fprintf(stdout, "randr extension not available\n");
		}else{
			free(randrReply);
		}
		if(!renderReply or !(*renderReply).present){
			fprintf(stdout, "render extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_render_id);
			if(reply and (*reply).present){
				renderBaseEvent = (*reply).first_event;
				renderBaseError = (*reply).first_error;
			}
			free(renderReply);
		}
		if(!xfixesReply or !(*xfixesReply).present){
			fprintf(stdout, "xfixes extension not available\n");
		}else{
			free(xfixesReply);
		}
		if(!shapeReply or !(*shapeReply).present){
			fprintf(stdout, "shape extension not available\n");
		}else{
			free(shapeReply);
		}
	}
	{
		const xcb_damage_query_version_cookie_t compositeCookie = xcb_damage_query_version_unchecked(connection, XCB_COMPOSITE_MAJOR_VERSION, XCB_COMPOSITE_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t damageCookie = xcb_damage_query_version_unchecked(connection, XCB_DAMAGE_MAJOR_VERSION, XCB_DAMAGE_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t renderCookie = xcb_damage_query_version_unchecked(connection, XCB_RENDER_MAJOR_VERSION, XCB_RENDER_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t randrCookie = xcb_damage_query_version_unchecked(connection, XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
		const xcb_xfixes_query_version_cookie_t xfixesCookie = xcb_xfixes_query_version_unchecked(connection, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION);
		const xcb_xfixes_query_version_cookie_t shapeCookie = xcb_xfixes_query_version_unchecked(connection, XCB_SHAPE_MAJOR_VERSION, XCB_SHAPE_MINOR_VERSION);
		xcb_damage_query_version_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_damage_query_version_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_damage_query_version_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_damage_query_version_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_xfixes_query_version_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_xfixes_query_version_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(compositeReply){
			free(compositeReply);
		}else{
			fprintf(stdout, "%s: could not query composite extension\n", programName);
		}
		if(damageReply){
			free(damageReply);
		}else{
			fprintf(stdout, "%s: could not query damage extension\n", programName);
		}
		if(renderReply){
			free(renderReply);
		}else{
			fprintf(stdout, "%s: could not query render extension\n", programName);
		}
		if(randrReply){
			free(randrReply);
		}else{
			fprintf(stdout, "%s: could not query randr extension\n", programName);
		}
		if(xfixesReply){
			free(xfixesReply);
		}else{
			fprintf(stdout, "%s: could not query xfixes extension\n", programName);
		}
		if(shapeReply){
			free(shapeReply);
		}else{
			fprintf(stdout, "%s: could not query shape extension\n", programName);
		}
	}



	{
		const uint32 stackMode = XCB_STACK_MODE_BELOW;
		xcb_composite_get_overlay_window_reply_t *const overlay = xcb_wait_for_reply(connection, xcb_composite_get_overlay_window_unchecked(connection, (*screen).root), NULL);
		if(overlay){
			overlayWindow = (*overlay).overlay_win;
			free(overlay);
		}
		xcb_configure_window(connection, overlayWindow, XCB_CONFIG_WINDOW_STACK_MODE, &stackMode);
	}



	{
		xcb_intern_atom_reply_t *reply;
		pixmapAtom = XCB_NONE;
		if((reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("PIXMAP"), "PIXMAP"), NULL))){
			pixmapAtom = (*reply).atom;
			free(reply);
		}
		rootPixmapAtom = XCB_NONE;
		if((reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("_XROOTPMAP_ID"), "_XROOTPMAP_ID"), NULL))){
			rootPixmapAtom = (*reply).atom;
			free(reply);
		}
	}



	{
		xcb_composite_redirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}



	jmp storeMonitors;
	storeMonitors:{
		void *reply;
		Monitor *monitorCurrent;
		xcb_randr_monitor_info_iterator_t iterator;
		if(!(reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL))){
			monitorAmount = 1;
			jmp storeMonitorsExit;
		}
		monitorAmount = (*(xcb_randr_get_monitors_reply_t *)reply).nMonitors;
		if(!(monitorData = malloc(monitorAmount * sizeof(Monitor)))){
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorStart = monitorData;
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAmount;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const uint x = (*data).x;
				const uint y = (*data).y;
				const uint w = (*data).width;
				const uint h = (*data).height;
				if(monitorCurrent > monitorStart){
					const Monitor *const wall = monitorCurrent;
					const Monitor *current = monitorStart;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).x == x and (*current).y == y and (*current).w == w and (*current).h == h){
								dec monitorAmount;
								dec monitorWall;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).x = x;
				(*monitorCurrent).y = y;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				xcb_randr_monitor_info_next(&iterator);
				inc monitorCurrent;
				jmp storeMonitorLoop;
			}
			jmp trimMonitorMemory;
		}
		trimMonitorMemory:{
			void *temp;
			if(!(temp = realloc(monitorData, monitorAmount * sizeof(Monitor)))){
				free(reply);
				jmp storeMonitorsExit;
			}
			monitorData = temp;
		}
		monitorStart = monitorData;
		monitorWall = monitorStart + monitorAmount;
		free(reply);
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{}



	{
		if(!(clientStart = malloc(clientSize * sizeof(Client)))){
			fprintf(stdout, "no clientStart\n");
		}
		clientWall = clientStart + clientAllocated;



		if(!(orderedClientOffsetStart = malloc(clientSize * sizeof(uint)))){
			fprintf(stdout, "no orderedClientOffsetStart\n");
		}



		if(!(rectangleStart = malloc(128 * sizeof(xcb_rectangle_t)))){
			fprintf(stdout, "no rectangleStart\n");
		}



		visualSize = VISUAL_FORMAT_PAIR_BLOCK_SIZE;
		visualAllocated = 0;
		if(!(visualStart = malloc(visualSize * sizeof(xcb_render_pictvisual_t)))){
			fprintf(stdout, "no visualStart\n");
			visualSize = 0;
		}
		defaultOpaqueVisualOffset = 0;
		defaultTransparentVisualOffset = 0;
	}



	jmp matchVisualFormat;
	matchVisualFormat:{
		xcb_render_query_pict_formats_reply_t *const formats = xcb_wait_for_reply(connection, xcb_render_query_pict_formats_unchecked(connection), NULL);
		if(formats){
			xcb_render_pictscreen_iterator_t pictscreenIterator = xcb_render_query_pict_formats_screens_iterator(formats);
			xcb_render_pictvisual_t *current = visualStart;
			while(pictscreenIterator.rem){
				xcb_render_pictdepth_iterator_t pictdepth = xcb_render_pictscreen_depths_iterator(pictscreenIterator.data);
				while(pictdepth.rem){
					xcb_render_pictvisual_t *const pictvisual = xcb_render_pictdepth_visuals(pictdepth.data);
					if(visualAllocated == visualSize){
						void *temp;
						visualSize += VISUAL_FORMAT_PAIR_BLOCK_SIZE;
						if(!(temp = realloc(visualStart, visualSize * sizeof(xcb_rectangle_t)))){
							jmp matchVisualFormatExit;
						}
						visualStart = temp;
					}
					if((*pictvisual).visual and (*pictvisual).format){
						const uint8 depth = (*pictdepth.data).depth;
						*current = *pictvisual;
						if(depth == 24){
							if(!defaultOpaqueVisualOffset){
								defaultOpaqueVisualOffset = current - visualStart;
							}
						}elif(depth == 32){
							if(!defaultTransparentVisualOffset){
								defaultTransparentVisualOffset = current - visualStart;
							}
						}
						inc current;
						inc visualAllocated;
					}
					xcb_render_pictdepth_next(&pictdepth);
				}
				xcb_render_pictscreen_next(&pictscreenIterator);
			}
			free(formats);
		}
		jmp matchVisualFormatExit;
	}
	matchVisualFormatExit:{
		visualWall = visualStart + visualAllocated;
	}



	{
		rootFormat = findFormat((*screen).root_visual, (*screen).root_depth);
		createRootPicture();
		createWallpaper();
		setWallpaper();
	}



	{
		const uint32 valueList = XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_change_window_attributes(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
	}



	{
		queryTree();
		if(treeReply){
			const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
			const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
			uint *orderedClientOffsetCurrent = orderedClientOffsetStart;
			addExistingClientLoop:{
				if(addClient(*windowCurrent)){
					*orderedClientOffsetCurrent = orderedClientOffsetCurrent - orderedClientOffsetStart;
					inc orderedClientOffsetCurrent;
				}
				if(inc windowCurrent < windowWall){
					jmp addExistingClientLoop;
				}
			}
		}
		clientWall = clientStart + clientAllocated;
		calculateViewableWindowSizes();
		drawAllClients();
		drawWallpaper();
	}



	{
		xcb_ungrab_server(connection);
	}









	eventLoop:{



		if(globalRegion){
			xcb_xfixes_set_picture_clip_region(connection, bufferPicture, globalRegion, 0, 0);
			xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
			xcb_xfixes_destroy_region(connection, globalRegion);
			globalRegion = XCB_NONE;
		}



		xcb_flush(connection);
		free(event0);
		event0 = NULL;
		jmp waitForEventLoop;
	}
	waitForEventLoop:{
		if((event0 = xcb_wait_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		jmp eventLoop;
	}
	switchEvents:{
		#define XCB_ONE /*-*/ (1)
		switch (*event0).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unexpectedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp unexpectedEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp unexpectedEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp unexpectedEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp unexpectedEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
#ifdef a
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
#endif
			to XCB_VISIBILITY_NOTIFY: /*-*/ fprintf(stdout, "visibility notify\n"); jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ fprintf(stdout, "create notify\n"); jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ fprintf(stdout, "destroy notify\n"); jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ fprintf(stdout, "unmap notify\n"); jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ fprintf(stdout, "map notify\n"); jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ fprintf(stdout, "reparent notify\n"); jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ fprintf(stdout, "configure notify\n"); jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ fprintf(stdout, "circulate notify\n"); jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ fprintf(stdout, "property notify\n"); jmp propertyNotifyEvent;

			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp unexpectedEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	extensionEvent:{
		if(((*event0).response_type & ~b(10000000)) == damageBaseEvent + XCB_DAMAGE_NOTIFY){
			jmp damageNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseEvent + XCB_RANDR_SCREEN_CHANGE_NOTIFY){
			jmp randrNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == damageBaseError + XCB_DAMAGE_BAD_DAMAGE){
			jmp badDamageError;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseError){
			jmp randrNotifyError;
		}
		jmp unexpectedEvent;
	}
	visibilityNotifyEvent:{
		#define event0 /*-*/ ((xcb_visibility_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			if((*event0).state != XCB_VISIBILITY_FULLY_OBSCURED){
				mapClient(client);
				jmp eventLoop;
			}
			unmapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	createNotifyEvent:{
		#define event0 /*-*/ ((xcb_create_notify_event_t *)event0)
		Client *client;
		queryTree();
		if(!(client = findClient((*event0).window))){
			addClient((*event0).window);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	destroyNotifyEvent:{
		#define event0 /*-*/ ((xcb_destroy_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((client = findClient((*event0).window))){
			destroyClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	unmapNotifyEvent:{
		#define event0 /*-*/ ((xcb_unmap_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			unmapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	mapNotifyEvent:{
		#define event0 /*-*/ ((xcb_map_notify_event_t *)event0)
		Client *const client = findClient((*event0).window);
		if(client){
			mapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	reparentNotifyEvent:{
		#define event0 /*-*/ ((xcb_reparent_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((*event0).parent == (*screen).root){
			if(!(client = findClient((*event0).window))){
				addClient((*event0).window);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if((client = findClient((*event0).window))){
			destroyClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	configureNotifyEvent:{
		#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((client = findClient((*event0).window))){
			configureClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	circulateNotifyEvent:{
		#define event0 /*-*/ ((xcb_circulate_notify_event_t *)event0)
		queryTree();
		circulateClients();
		jmp eventLoop;
		#undef  event0
	}
	propertyNotifyEvent:{
		#define event0 /*-*/ ((xcb_property_notify_event_t *)event0)
		if((*event0).atom == rootPixmapAtom and rootPixmapAtom){
			setWallpaper();
			drawWallpaper();
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	damageNotifyEvent:{
		#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
		Client *const client = findClient((*event0).drawable);
		if(client){
			damageClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	errorEvent:{
		genericError = (void *)event0;
		printXCBError();
		genericError = NULL;
		jmp eventLoop;
	}
	unexpectedEvent:{
		jmp eventLoop;
	}
	badDamageError:{
		fprintf(stdout, "%s: bad damage error\n", programName);
		jmp eventLoop;
	}
	randrNotifyEvent:{
		fprintf(stdout, "%s: randr notify event\n", programName);
		calculateViewableWindowSizes();
		createRootPicture();
		createWallpaper();
		setWallpaper();
		drawWallpaper();
		jmp eventLoop;
	}
	randrNotifyError:{
		fprintf(stdout, "%s: randr notify error\n", programName);
		jmp eventLoop;
	}
	eventLoopExit:{
		free(event0);
		event0 = NULL;
		jmp mainEmergencyExit;
	}
	mainEmergencyExit:{









		/*! update all this eventually */

		free(visualStart);
		free(orderedClientOffsetStart);
		free(clientStart);



		xcb_render_free_picture(connection, wallpaperPicture);
		xcb_free_pixmap(connection, wallpaperPixmap);



		xcb_render_free_picture(connection, rootPicture);
		xcb_render_free_picture(connection, bufferPicture);
		xcb_free_pixmap(connection, bufferPixmap);



		xcb_composite_unredirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);









		xcb_disconnect(connection);
		ret 0;
	}
}
MAPCLIENT(){
	(*client).mapInfo |= MAPPED_MAP_INFO;
	if(!(*client).picture){
		(*client).picture = xcb_generate_id(connection);
		xcb_render_create_picture_checked(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL); /*! annoying on discord tray window create, match error */
	}
	calculateViewableWindowSizes();
	drawClient(client);
	ret;
}
UNMAPCLIENT(){
	(*client).mapInfo &= ~MAPPED_MAP_INFO;
	if((*client).picture){
		xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on discord tray icon window delete */
		(*client).picture = XCB_NONE;
	}
	calculateViewableWindowSizes();
	drawBelowClient(client);
	drawWallpaper();
	ret;
}
DESTROYCLIENT(){
	if((*client).mapInfo & MAPPED_MAP_INFO){
		unmapClient(client);
	}
	{
		if((*client).damage){
			xcb_damage_destroy_checked(connection, (*client).damage); /*! annoying on window deleting */
		}
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on window deleting */
		}
		*client = *(dec clientWall);
		dec clientAllocated;
	}
	updateOrder();
	ret;
}
CIRCULATECLIENTS(){
	updateOrder();
	calculateViewableWindowSizes();
	drawAllClients();
	drawWallpaper();
	ret;
}
DAMAGECLIENT(){
	#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
	if(((*client).mapInfo & (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)) == (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)){
		const xcb_rectangle_t *const geometry = &(*event0).geometry;
		const int x = (*geometry).x;
		const int y = (*geometry).y;
		const int w = (*geometry).width;
		const int h = (*geometry).height;
		xcb_damage_subtract(connection, (*client).damage, XCB_NONE, XCB_NONE);
		{
			const uint amount = getClientIntersectingRectangles(client, x, y, x + w, y + h);
			if(amount){
				const xcb_xfixes_region_t region = xcb_generate_id(connection);
				xcb_xfixes_create_region(connection, region, amount, rectangleStart);
				{
					xcb_xfixes_set_picture_clip_region(connection, (*client).picture, region, 0, 0);
					xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, x, y, w, h);
				}
				xcb_xfixes_destroy_region(connection, region);
			}
		}
	}
	ret;
	#undef  event0
}



























ADDCLIENT(){
	/*!
		(*client).size = 0;
		(*client).allocated = 0;
		(*client).rectangle = NULL;

		(*client).window = window;
		(*client).damage = XCB_NONE;
		(*client).format = XCB_NONE;
		(*client).picture = XCB_NONE;

		(*client).x = 0;
		(*client).y = 0;
		(*client).w = 0;
		(*client).h = 0;
		(*client).rightX = 0;
		(*client).bottomY = 0;

		(*client).shaped = false;
		(*client).mapInfo = NONE_MAP_INFO;
		(*client).depth = 24;
		(*client).useSpecialEffect = false;
	*/



	xcb_get_window_attributes_cookie_t attributesCookie;
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_get_window_attributes_reply_t *attributesReply;
	xcb_get_geometry_reply_t *geometryReply;
	Client *client;
	if(window == overlayWindow){
		ret false;
	}
	attributesCookie = xcb_get_window_attributes_unchecked(connection, window);
	geometryCookie = xcb_get_geometry_unchecked(connection, window);
	attributesReply = xcb_wait_for_reply(connection, attributesCookie, NULL);
	geometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);



	/*! error somewhere when reparenting the discord window */









	/*! even if some shit fails, add the client with defaults */



	if(!attributesReply or !geometryReply){
		fprintf(stdout, "could not add client %x due to replies\n", window);
		jmp emergencyExit;
	}



	if(clientAllocated == clientSize){
		void *temp;
		void *temp1;
		clientSize += CLIENT_BLOCK_SIZE;
		if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
			jmp emergencyExit;
		}
		clientStart = temp;
		if(!(temp1 = realloc(orderedClientOffsetStart, clientSize * sizeof(uint)))){
			jmp emergencyExit;
		}
		orderedClientOffsetStart = temp1;
	}
	client = clientStart + clientAllocated;
	*(orderedClientOffsetStart + clientAllocated) = client - clientStart;









	if(geometryReply){
		(*client).x = (*geometryReply).x;
		(*client).y = (*geometryReply).y;
		(*client).w = (*geometryReply).width + 2 * (*geometryReply).border_width;
		(*client).h = (*geometryReply).height + 2 * (*geometryReply).border_width;
	}else{
		(*client).x = (*screen).width_in_pixels;
		(*client).y = (*screen).height_in_pixels;
		(*client).w = 0;
		(*client).h = 0;
	}
	(*client).rightX = (*client).x + (*client).w;
	(*client).bottomY = (*client).y + (*client).h;



	(*client).window = window;
	(*client).format = findFormat((*attributesReply).visual, (*geometryReply).depth);
	(*client).damage = XCB_NONE;
	(*client).picture = XCB_NONE;



	(*client).mapInfo = NONE_MAP_INFO;
	if((*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED){
		(*client).mapInfo |= MAPPED_MAP_INFO;
	}
	if(!((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels)){
		(*client).mapInfo |= VIEWABLE_MAP_INFO;
	}



	(*client).useSpecialEffect = false;



	(*client).size = RECTANGLE_BLOCK_SIZE;
	(*client).allocated = 0;
	(*client).rectangle = malloc((*client).size * sizeof(xcb_rectangle_t));



	xcb_change_window_attributes(connection, window, XCB_CW_EVENT_MASK, &windowValueList);



	if((*attributesReply)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
		(*client).damage = xcb_generate_id(connection);
		xcb_damage_create(connection, (*client).damage, window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
		if((*client).mapInfo & MAPPED_MAP_INFO){
			(*client).picture = xcb_generate_id(connection);
			xcb_render_create_picture(connection, (*client).picture, window, (*client).format, XCB_NONE, NULL);
		}
	}



	free(attributesReply);
	free(geometryReply);



	inc clientAllocated;
	inc clientWall;
	ret true;



	emergencyExit:{
		free(attributesReply);
		free(geometryReply);
		ret false;
	}
}
CONFIGURECLIENT(){
	#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
	const uint8 mapped = (*client).mapInfo & MAPPED_MAP_INFO;
	(*client).mapInfo &= ~MAPPED_MAP_INFO;



	/*! use this before drawBelowClient()? */
	/*! calculateViewableWindowSizes(); */



	drawBelowClient(client);
	(*client).mapInfo |= mapped;
	{
		(*client).x = (*event0).x;
		(*client).y = (*event0).y;
		(*client).w = (*event0).width + 2 * (*event0).border_width;
		(*client).h = (*event0).height + 2 * (*event0).border_width;
		(*client).rightX = (*client).x + (*client).w;
		(*client).bottomY = (*client).y + (*client).h;
		(*client).mapInfo &= ~VIEWABLE_MAP_INFO;
		if(!((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels)){
			(*client).mapInfo |= VIEWABLE_MAP_INFO;
		}
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on window delete */
			(*client).picture = xcb_generate_id(connection);
			xcb_render_create_picture_checked(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL); /*! annoying on window delete */
		}
	}
	updateOrder();
	calculateViewableWindowSizes();
	drawClient(client);
	drawWallpaper();
	ret;
	#undef  event0
}



























DRAWBELOWCLIENT(){



	/*! should be much slower for high amount of overlapping windows */



	const uint *offsetCurrent = orderedClientOffsetStart - 1;
	const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
	const uint eventX = (*client).x;
	const uint eventY = (*client).y;
	const uint eventW = (*client).w;
	const uint eventH = (*client).h;
	xcb_xfixes_region_t localRegion = XCB_NONE;
	jmp loop;
	loop:{
		if(inc offsetCurrent < offsetWall){
			const Client *const current = clientStart + *offsetCurrent;
			int x;
			int y;
			int w;
			int h;
			if(*offsetCurrent == (uint)-1 or ((*current).mapInfo & (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)) != (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO) or current == client){
				jmp loop;
			}
			if(createIntersectingRectangle((*current).x, (*current).y, (*current).w, (*current).h, eventX, eventY, eventW, eventH, &x, &y, &w, &h)){
				const xcb_xfixes_region_t region = xcb_generate_id(connection);
				xcb_rectangle_t rectangle;
				rectangle.x = x;
				rectangle.y = y;
				rectangle.width = w;
				rectangle.height = h;
				xcb_xfixes_create_region_checked(connection, region, 1, &rectangle);
				{
					xcb_xfixes_set_picture_clip_region_checked(connection, (*current).picture, region, 0, 0);
					xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*current).picture, XCB_NONE, rootPicture, x - (*current).x, y - (*current).y, 0, 0, x, y, w, h);
				}
				xcb_xfixes_destroy_region_checked(connection, region);
/*!
				if(!localRegion){
					localRegion = region;
				}else{
					xcb_xfixes_union_region_checked(connection, localRegion, region, localRegion);
					xcb_xfixes_destroy_region_checked(connection, region);
				}
*/
			}
			jmp loop;
		}
	}
	if(localRegion){
		xcb_xfixes_set_picture_clip_region(connection, bufferPicture, localRegion, 0, 0);
		xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, eventX, eventY, eventW, eventH);
		xcb_xfixes_destroy_region(connection, localRegion);
	}
	ret;
}
CREATEINTERSECTINGRECTANGLE(){
	const int  rightX0 = leftX0 +  width0;
	const int  rightX1 = leftX1 +  width1;
	const int bottomY0 =  topY0 + height0;
	const int bottomY1 =  topY1 + height1;
	if(leftX1 < rightX0 and rightX1 > leftX0 and topY1 < bottomY0 and bottomY1 > topY0){
		*retX =    leftX0 >   leftX1?   leftX0 :   leftX1;
		*retY =     topY0 >    topY1?    topY0 :    topY1;
		*retW = ( rightX0 <  rightX1?  rightX0 :  rightX1) - *retX;
		*retH = (bottomY0 < bottomY1? bottomY0 : bottomY1) - *retY;
		ret true;
	}
	ret false;
}
SPLITRECTANGLE(){
	xcb_rectangle_t *current;
	if(*allocated + 4 >= *size){
		void *temp;
		*size += RECTANGLE_BLOCK_SIZE;
		if(!(temp = realloc(*rectangle, *size * sizeof(xcb_rectangle_t)))){
			jmp emergencyExit;
		}
		*rectangle = temp;
	}
	current = *rectangle + *allocated;
	if(interY > y){
		(*current).x = x;
		(*current).y = y;
		(*current).width = w;
		(*current).height = interY - y;
		inc current;
	}
	if(interY + interH < y + h){
		(*current).x = x;
		(*current).y = interY + interH;
		(*current).width = w;
		(*current).height = y + h - interY - interH;
		inc current;
	}
	if(interX > x){
		(*current).x = x;
		(*current).y = interY;
		(*current).width = interX - x;
		(*current).height = interH;
		inc current;
	}
	if(interX + interW < x + w){
		(*current).x = interX + interW;
		(*current).y = interY;
		(*current).width = x + w - interX - interW;
		(*current).height = interH;
		inc current;
	}
	*allocated = current - *rectangle;
	ret;
	emergencyExit:{



		/*! realloc will eventually fail. what do? */



		*size = RECTANGLE_BLOCK_SIZE;
		*allocated = 0;
		free(*rectangle);
		*rectangle = NULL;
		ret;
	}
}
CALCULATEVIEWABLEWINDOWSIZES(){



	/*! update this ffs */



	{
		rootClient.x = 0;
		rootClient.y = 0;
		rootClient.w = (*screen).width_in_pixels;
		rootClient.h = (*screen).height_in_pixels;
		rootClient.size = RECTANGLE_BLOCK_SIZE;
		rootClient.allocated = 0;
		if(!rootClient.rectangle){
			rootClient.rectangle = malloc(RECTANGLE_BLOCK_SIZE * sizeof(xcb_rectangle_t));
		}
		{
			xcb_rectangle_t *rectangle = rootClient.rectangle;
			if(rectangle){
				(*rectangle).x = rootClient.x;
				(*rectangle).y = rootClient.y;
				(*rectangle).width = rootClient.w;
				(*rectangle).height = rootClient.h;
				rootClient.allocated = 1;
			}
		}
	}
	{
		const uint *belowCurrent = orderedClientOffsetStart - 1;
		const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
		bool useRoot = true;
		jmp resetClientRectangle;
		resetClientRectangle:{
			Client *client = clientStart;
			jmp resetClientRectangleLoop;
			resetClientRectangleLoop:{
				if(client < clientWall){
					xcb_rectangle_t *rectangle = (*client).rectangle;
					if(rectangle){
						(*rectangle).x = (*client).x;
						(*rectangle).y = (*client).y;
						(*rectangle).width = (*client).w;
						(*rectangle).height = (*client).h;
						(*client).allocated = 1;
					}
					inc client;
					jmp resetClientRectangleLoop;
				}
			}
			jmp belowClientLoop;
		}
		belowClientLoop:{
			if(inc belowCurrent < offsetWall){
				const uint *aboveCurrent = belowCurrent;
				Client *below;
				if(useRoot){
					below = &rootClient;
					dec belowCurrent;
					useRoot = false;
				}else{
					below = clientStart + *belowCurrent;
					if(*belowCurrent == (uint)-1 or ((*below).mapInfo & (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)) != (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)){
						jmp belowClientLoop;
					}
				}
				jmp aboveClientLoop;
				aboveClientLoop:{
					if(inc aboveCurrent < offsetWall){
						Client *const above = clientStart + *aboveCurrent;
						int x;
						int y;
						int w;
						int h;
						if(*aboveCurrent == (uint)-1 or ((*above).mapInfo & (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)) != (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)){
							jmp aboveClientLoop;
						}
						if(createIntersectingRectangle((*above).x, (*above).y, (*above).w, (*above).h, (*below).x, (*below).y, (*below).w, (*below).h, &x, &y, &w, &h)){
							xcb_rectangle_t *rectangle = (*below).rectangle;
							if(rectangle){
								xcb_rectangle_t *rectangleWall = rectangle + (*below).allocated;
								uint size = RECTANGLE_BLOCK_SIZE;
								uint allocated = 0;
								xcb_rectangle_t *newRectangle = malloc(size * sizeof(xcb_rectangle_t));
								if(!newRectangle){
									ret;
								}
								jmp splitRectanglesLoop;
								splitRectanglesLoop:{
									if(rectangle < rectangleWall){
										if(createIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, (*above).x, (*above).y, (*above).w, (*above).h, &x, &y, &w, &h)){
											splitRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, x, y, w, h, &size, &allocated, &newRectangle);
										}else{
											if(allocated == size){
												void *temp;
												size += RECTANGLE_BLOCK_SIZE;
												if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){
													ret;
												}
												newRectangle = temp;
											}
											*(newRectangle + allocated) = *rectangle;
											inc allocated;
										}
										inc rectangle;
										jmp splitRectanglesLoop;
									}
								}
								free((*below).rectangle);
								(*below).size = size;
								(*below).allocated = allocated;
								(*below).rectangle = newRectangle;
							}
						}
						jmp aboveClientLoop;
					}
				}
				jmp belowClientLoop;
			}
		}
	}









	/*! {
		uint *current = orderedClientOffsetStart;
		uint *wall = orderedClientOffsetStart + clientAllocated;
		uint i = 0;
		while(current < wall){
			if(*current != (uint)-1){
				Client *client = clientStart + *current;
				if(((*client).mapInfo & (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)) == (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)){
					xcb_rectangle_t *rectangle = (*client).rectangle;
					xcb_rectangle_t *wall = (*client).rectangle + (*client).allocated;
					fprintf(stdout, "\tclient %u:\n", i);
					inc i;
					while(rectangle < wall){
						fprintf(stdout, "\t\t%i %i %i %i\n", (*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height);
						inc rectangle;
					}
				}
			}
			inc current;
		}
		fprintf(stdout, "\n\n\n");
	} */



	ret;
}
UPDATEORDER(){
	if(treeReply){
		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);









		/*! optimize this */



		uint *orderedClientOffsetCurrent = orderedClientOffsetStart;
		jmp findClientWindowLoop;
		findClientWindowLoop:{
			Client *const client = findClient(*windowCurrent);
			if(client){
				*orderedClientOffsetCurrent = client - clientStart;
			}else{
				*orderedClientOffsetCurrent = -1;
				if(*windowCurrent == overlayWindow){
					dec orderedClientOffsetCurrent;
				}else{



					fprintf(stdout, "\n\n\ninvalid client offset\n\n\n\n");



				}
			}
			if(inc windowCurrent < windowWall){
				inc orderedClientOffsetCurrent;
				jmp findClientWindowLoop;
			}
		}









	}
	ret;
}
GETCLIENTINTERSECTINGRECTANGLES(){
	if(!rectangleStart){
		ret 0;
	}
	{
		const xcb_rectangle_t *rectangle = (*client).rectangle;
		const xcb_rectangle_t *const wall = rectangle + (*client).allocated;
		xcb_rectangle_t *rectangleCurrent = rectangleStart;
		jmp createIntersectingRectangleLoop;
		createIntersectingRectangleLoop:{
			if(rectangle < wall){
				const int leftX1 = (*rectangle).x;
				const int topY1 = (*rectangle).y;
				const int rightX1 = leftX1 + (*rectangle).width;
				const int bottomY1 = topY1 + (*rectangle).height;
				if(leftX0 < rightX1 and rightX0 > leftX1 and topY0 < bottomY1 and bottomY0 > topY1){
					(*rectangleCurrent).x      =    leftX1 >   leftX0?   leftX1 :   leftX0;
					(*rectangleCurrent).y      =     topY1 >    topY0?    topY1 :    topY0;
					(*rectangleCurrent).width  = ( rightX1 <  rightX0?  rightX1 :  rightX0) - (*rectangleCurrent).x;
					(*rectangleCurrent).height = (bottomY1 < bottomY0? bottomY1 : bottomY0) - (*rectangleCurrent).y;
					inc rectangleCurrent;
				}
				inc rectangle;
				jmp createIntersectingRectangleLoop;
			}
			ret rectangleCurrent - rectangleStart;
		}
	}
}



























DRAWALLCLIENTS(){
	const uint *offsetCurrent = orderedClientOffsetStart - 1;
	const uint *const offsetWall = orderedClientOffsetStart + clientAllocated;
	jmp drawClientLoop;
	drawClientLoop:{
		if(inc offsetCurrent < offsetWall){
			const Client *const current = clientStart + *offsetCurrent;
			if(*offsetCurrent != (uint)-1 and ((*current).mapInfo & (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)) == (MAPPED_MAP_INFO | VIEWABLE_MAP_INFO)){
				const xcb_xfixes_region_t region = xcb_generate_id(connection);
				xcb_rectangle_t rectangle;
				rectangle.x = (*current).x;
				rectangle.y = (*current).y;
				rectangle.width = (*current).w;
				rectangle.height = (*current).h;
				xcb_xfixes_create_region_checked(connection, region, 1, &rectangle);
				{
					xcb_xfixes_set_picture_clip_region_checked(connection, (*current).picture, region, 0, 0);
					xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*current).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, (*current).x, (*current).y, (*current).w, (*current).h);
				}
				xcb_xfixes_destroy_region_checked(connection, region);
			}
			jmp drawClientLoop;
		}
	}
	ret;
}
CREATEROOTPICTURE(){
	if(rootPicture){
		xcb_render_free_picture(connection, rootPicture);
	}
	if(bufferPicture){
		xcb_render_free_picture(connection, bufferPicture);
	}
	if(bufferPixmap){
		xcb_free_pixmap(connection, bufferPixmap);
	}
	bufferPixmap = xcb_generate_id(connection);
	bufferPicture = xcb_generate_id(connection);
	rootPicture = xcb_generate_id(connection);
	xcb_create_pixmap(connection, (*screen).root_depth, bufferPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
	xcb_render_create_picture(connection, bufferPicture, bufferPixmap, rootFormat, XCB_NONE, NULL);
	xcb_render_create_picture(connection, rootPicture, overlayWindow, rootFormat, XCB_NONE, NULL);
	ret;
}
CREATEWALLPAPER(){
	if(wallpaperPicture){
		xcb_render_free_picture(connection, wallpaperPicture);
	}
	if(wallpaperPixmap){
		xcb_free_pixmap(connection, wallpaperPixmap);
	}
	wallpaperPixmap = xcb_generate_id(connection);
	wallpaperPicture = xcb_generate_id(connection);
	xcb_create_pixmap(connection, (*screen).root_depth, wallpaperPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
	xcb_render_create_picture(connection, wallpaperPicture, wallpaperPixmap, rootFormat, XCB_NONE, NULL);
	ret;
}
SETWALLPAPER(){
	{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		const uint32 valueList = 0xFF000000;
		xcb_rectangle_t rectangle;
		rectangle.x = 0;
		rectangle.y = 0;
		rectangle.width = (*screen).width_in_pixels;
		rectangle.height = (*screen).height_in_pixels;
		xcb_create_gc(connection, gc, wallpaperPixmap, XCB_GC_FOREGROUND, &valueList);
		xcb_poly_fill_rectangle(connection, wallpaperPixmap, gc, 1, &rectangle);
		xcb_free_gc(connection, gc);
	}
	if(rootPixmapAtom and pixmapAtom){
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL);
		if(!reply){
			ret;
		}
		if((*reply).type != pixmapAtom){
			fprintf(stdout, "%s: root pixmap is not of type pixmap\n", programName);
		}else{
			const xcb_pixmap_t pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
			const xcb_get_geometry_cookie_t cookie = xcb_get_geometry_unchecked(connection, pixmap);
			const xcb_gcontext_t gc = xcb_generate_id(connection);
			xcb_get_geometry_reply_t *geometryReply;
			uint width = (*screen).width_in_pixels;
			uint height = (*screen).height_in_pixels;
			xcb_create_gc(connection, gc, pixmap, XCB_NONE, NULL);
			if((geometryReply = xcb_wait_for_reply(connection, cookie, NULL))){
				width = (*geometryReply).width;
				height = (*geometryReply).height;
				free(geometryReply);
			}
			xcb_copy_area(connection, pixmap, wallpaperPixmap, gc, 0, 0, 0, 0, width, height);
			xcb_free_gc(connection, gc);
		}
		free(reply);
	}
	ret;
}
DRAWWALLPAPER(){
	if(rootClient.allocated){
		const xcb_xfixes_region_t region = xcb_generate_id(connection);
		xcb_xfixes_create_region(connection, region, rootClient.allocated, rootClient.rectangle);
		{
			xcb_xfixes_set_picture_clip_region(connection, wallpaperPicture, region, 0, 0);
			xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, wallpaperPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
		}
		xcb_xfixes_destroy_region_checked(connection, region);
	}
	ret;
}
DRAWCLIENT(){
	const uint amount = getClientIntersectingRectangles(client, (*client).x, (*client).y, (*client).rightX, (*client).bottomY);
	if(amount){
		const xcb_xfixes_region_t region = xcb_generate_id(connection);
		xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
		{
			xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
			xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).w, (*client).h);
		}
		xcb_xfixes_destroy_region_checked(connection, region);
	}
	ret;
}
FINDFORMAT(){
	const xcb_render_pictvisual_t *current = visualStart;
	jmp findVisualLoop;
	findVisualLoop:{
		if(current < visualWall){
			if((*current).visual == visual){
				ret (*current).format;
			}
			inc current;
			jmp findVisualLoop;
		}
		if(depth == 32){
			ret (*(visualStart + defaultTransparentVisualOffset)).format;
		}
		ret (*(visualStart + defaultOpaqueVisualOffset)).format;
	}
}
QUERYTREE(){
	const xcb_query_tree_cookie_t cookie = xcb_query_tree_unchecked(connection, (*screen).root);
	if(treeReply){
		free(treeReply);
	}
	treeReply = xcb_wait_for_reply(connection, cookie, NULL);
	ret;
}
FINDCLIENT(){
	const uint8 *const firstWindow = (void *)&(*clientStart).window;
	const uint8 *current = firstWindow;
	jmp findClientLoop;
	findClientLoop:{
		if(*(xcb_window_t *)current == window){
			ret (void *)(current - (firstWindow - (uint8 *)clientStart));
		}
		if((current += sizeof(Client)) < (uint8 *)clientWall){
			jmp findClientLoop;
		}
		ret NULL;
	}
}
PRINTERROR(){
	if(openErrorStream()){
		fprintf(errorStream, "%s: %s\n", programName, string);
		closeErrorStream();
	}
	ret;
}
OPENERRORSTREAM(){
	ret !mustOpenErrorStream or (errorStream = fopen(errorPath, "a"));
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		errorStream = NULL;
	}
	ret;
}
PRINTCONNECTIONERROR(){
	if(openErrorStream()){
		#define PRINTCONNECTIONERROR_ERROR /*--*/ xcb_connection_has_error(connection)
		#define PRINTCONNECTIONERROR_STREAM /*-*/ errorStream
		#include "xcb/printConnectionError.hold"
		closeErrorStream();
	}
	ret;
}
PRINTXCBERROR(){
	if(openErrorStream()){
		#define PRINTXCBERROR_ERROR /*--*/ genericError
		#define PRINTXCBERROR_STREAM /*-*/ errorStream
		#include "xcb/printXCBError.hold"
		closeErrorStream();
	}
	ret;
}
