/*!
	fix all kinds of issues that can be safely called basic and then move onto 32 bit window handling.

	basic includes faultless composition at idle-tier speeds where all windows are treated as 24 bit.
	then deal with how the wallpaper works and then deal with 32 bit windows.
*/

/*!
	check for monitor change issues
*/

/*!
	rectangle splitting can create rectangles that can be combined into one (yikes)
*/



























/*! microcompositor.cold

MIT License

Copyright (C) 2023 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#include <stdint.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <xcb/composite.h>
	#include <xcb/damage.h>
	#include <xcb/randr.h>
	#include <xcb/render.h>
	#include <xcb/shape.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include "cold/cold.hold"
/*!}*/

/*!user_defines:{*/
	#define DefaultErrorStream /*-------------*/ (stderr)
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------*/ (true)

	#define _EMPTY_MACRO /*----------------------*/

	#define FINDCLIENT() /*----------------------*/ local Client                  *findClient(const xcb_window_t window)
	#define FINDMAPPEDCLIENT() /*----------------*/ local Client                  *findMappedClient(const xcb_window_t window)
	#define UNMAPCLIENT() /*---------------------*/ local void                     unmapClient(Client *const client)
	#define DRAWBELOWCLIENT() /*-----------------*/ local void                     drawBelowClient(const Client *const client, const int eventX, const int eventY, const int eventW, const int eventH)
	#define MAPCLIENT() /*-----------------------*/ local void                     mapClient(Client *const client)
	#define ADDCLIENT() /*-----------------------*/ local void                     addClient(const xcb_window_t window)
	#define CONFIGURECLIENT() /*-----------------*/ local void                     configureClient(Client *const client)
	#define QUERYTREE() /*-----------------------*/ local void                     queryTree(void)
	#define UPDATEORDER() /*---------------------*/ local void                     updateOrder(void)
	#define GETINTERSECTINGRECTANGLE() /*--------*/ local bool                     getIntersectingRectangle(int leftX0, int topY0, int width0, int height0, int leftX1, int topY1, int width1, int height1, int *retX, int *retY, int *retW, int *retH)
	#define SPLITRECTANGLE() /*------------------*/ local void                     splitRectangle(const int x, const int y, const int w, const int h, int interX, int interY, int interW, int interH, uint *size, uint *allocated, xcb_rectangle_t **rectangle)
	#define CALCULATEVIEWABLEWINDOWSIZES() /*----*/ local void                     calculateViewableWindowSizes(void)
	#define SETWALLPAPER() /*--------------------*/ local void                     setWallpaper(void)
	#define CREATEWALLPAPER() /*-----------------*/ local void                     createWallpaper(void)
	#define DRAWWALLPAPER() /*-------------------*/ local void                     drawWallpaper(void)
	#define FINDFORMAT() /*----------------------*/ local xcb_render_pictformat_t  findFormat(const xcb_visualid_t visual, const uint8 depth)
	#define GETCLIENTINTERSECTINGRECTANGLES() /*-*/ local uint                     getClientIntersectingRectangles(const Client *const client, const int leftX0, const int topY0, const int rightX0, const int bottomY0)
	#define DRAWALLCLIENTS() /*------------------*/ local void                     drawAllClients(void)
	#define DESTROYCLIENT() /*-------------------*/ local void                     destroyClient(Client *const client)
	#define CIRCULATECLIENTS() /*----------------*/ local void                     circulateClients(void)
	#define DAMAGECLIENT() /*--------------------*/ local void                     damageClient(Client *const client)
	#define DRAWCLIENT() /*----------------------*/ local void                     drawClient(Client *const client)
	#define CREATEROOTPICTURE() /*---------------*/ local void                     createRootPicture(void)



	#define PRINTERROR() /*----------------------*/ local void    printError(const char *const string)
	#define OPENERRORSTREAM() /*-----------------*/ local bool    openErrorStream(void)
	#define CLOSEERRORSTREAM() /*----------------*/ local void    closeErrorStream(void)
	#define PRINTCONNECTIONERROR() /*------------*/ local void    printConnectionError(void)
	#define PRINTXCBERROR() /*-------------------*/ local void    printXCBError(void)

	#define xcb_wait_for_reply(a, b, c) /*-------*/ (xcb_wait_for_reply(a, (b).sequence, c))

	#define LITERAL_LENGTH(l) /*-----------------*/ (sizeof(l) - 1)

	#define _b(d, b) /*--------------------------*/ (d > (sizeof(#b) - 1)? 0 : ((*(#b + (sizeof(#b) - 1) - d) - 48) == 1) * ((uint64)1 << (d - 1)))

	#define b(b) /*------------------------------*/ ( \
		  _b( 1, b) + _b( 2, b) + _b( 3, b) + _b( 4, b) + _b( 5, b) + _b( 6, b) + _b( 7, b) + _b( 8, b) \
		+ _b( 9, b) + _b(10, b) + _b(11, b) + _b(12, b) + _b(13, b) + _b(14, b) + _b(15, b) + _b(16, b) \
		+ _b(17, b) + _b(18, b) + _b(19, b) + _b(20, b) + _b(21, b) + _b(22, b) + _b(23, b) + _b(24, b) \
		+ _b(25, b) + _b(26, b) + _b(27, b) + _b(28, b) + _b(29, b) + _b(30, b) + _b(31, b) + _b(32, b) \
		+ _b(33, b) + _b(34, b) + _b(35, b) + _b(36, b) + _b(37, b) + _b(38, b) + _b(39, b) + _b(40, b) \
		+ _b(41, b) + _b(42, b) + _b(43, b) + _b(44, b) + _b(45, b) + _b(46, b) + _b(47, b) + _b(48, b) \
		+ _b(49, b) + _b(50, b) + _b(51, b) + _b(52, b) + _b(53, b) + _b(54, b) + _b(55, b) + _b(56, b) \
		+ _b(57, b) + _b(58, b) + _b(59, b) + _b(60, b) + _b(61, b) + _b(62, b) + _b(63, b) + _b(64, b) \
	)

	#define VISUAL_FORMAT_PAIR_BLOCK_SIZE /*-----*/ (4)
	#define RECTANGLE_BLOCK_SIZE /*--------------*/ (8)
	#define CLIENT_BLOCK_SIZE /*-----------------*/ (128)

	#define NONE_MAP_INFO /*---------------------*/ (0)
	#define MAPPED_MAP_INFO /*-------------------*/ (1 << 0)
	#define VIEWABLE_MAP_INFO /*-----------------*/ (1 << 1)
/*!}*/

/*!defs:{*/
	def struct{
		uint32 /*------------------*/ size;
		uint32 /*------------------*/ allocated;
		xcb_rectangle_t * /*-------*/ rectangle;

		xcb_window_t /*------------*/ window;
		xcb_damage_damage_t /*-----*/ damage;
		xcb_render_pictformat_t /*-*/ format;
		xcb_render_picture_t /*----*/ picture;

		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		int32 /*-------------------*/ w;
		int32 /*-------------------*/ h;
		int32 /*-------------------*/ rightX;
		int32 /*-------------------*/ bottomY;

		bool /*--------------------*/ shaped;
		uint8 /*-------------------*/ mapInfo;
		uint8 /*-------------------*/ depth;
		bool /*--------------------*/ useSpecialEffect;

		uint8 /*-------------------*/ pad0[4];
	} Client;

	def struct{
		uint16 /*------------------*/ x;
		uint16 /*------------------*/ y;
		uint16 /*------------------*/ w;
		uint16 /*------------------*/ h;
	} Monitor;
/*!}*/

/*!globals:{*/
	const char * /*----------*/ programName;
	const char * /*----------*/ errorPath;
	const char * /*----------*/ connectionName;
	const xcb_screen_t * /*--*/ screen;
	const char * /*----------*/ quitMessage;
	bool /*------------------*/ mustOpenErrorStream;
	FILE * /*----------------*/ errorStream;
	xcb_connection_t * /*----*/ connection;
	xcb_generic_error_t * /*-*/ genericError;
	xcb_generic_event_t * /*-*/ event0;



	const uint32 windowValueList = XCB_EVENT_MASK_VISIBILITY_CHANGE;
	uint damageBaseEvent;
	uint damageBaseError;
	uint renderBaseEvent;
	uint renderBaseError;
	uint randrBaseEvent;
	uint randrBaseError;



	Client                  rootClient;
	xcb_atom_t              pixmapAtom;
	xcb_atom_t              rootPixmapAtom;
	xcb_render_pictformat_t rootFormat;
	xcb_pixmap_t            wallpaperPixmap;
	xcb_render_picture_t    wallpaperPicture;
	xcb_render_picture_t    rootPicture;
	xcb_xfixes_region_t     globalRegion;



	uint visualSize;
	uint visualAllocated;
	xcb_render_pictvisual_t *visualStart;
	xcb_render_pictvisual_t *visualWall;
	xcb_render_pictformat_t defaultOpaqueFormat;
	xcb_render_pictformat_t defaultTransparentFormat;



	uint clientSize;
	uint clientAllocated;
	uint orderedMappedClientAllocated;
	Client *clientStart;
	Client *clientWall;
	Client *lastClient;
	uint *orderedMappedClientOffsetStart;
	uint *orderedMappedClientOffsetWall;



	uint monitorAmount;
	void *monitorData;
	Monitor *monitorStart;
	Monitor *monitorWall;



	xcb_window_t overlayWindow;
	xcb_rectangle_t *rectangleStart;
	xcb_query_tree_reply_t *treeReply;
/*!}*/

/*!functions:{*/
	FINDCLIENT();
	FINDMAPPEDCLIENT();
	UNMAPCLIENT();
	DRAWBELOWCLIENT();
	MAPCLIENT();
	ADDCLIENT();
	QUERYTREE();
	UPDATEORDER();
	GETINTERSECTINGRECTANGLE();
	SPLITRECTANGLE();
	CALCULATEVIEWABLEWINDOWSIZES();
	SETWALLPAPER();
	CREATEWALLPAPER();
	FINDFORMAT();
	CONFIGURECLIENT();
	GETCLIENTINTERSECTINGRECTANGLES();
	DRAWWALLPAPER();
	DRAWALLCLIENTS();
	DESTROYCLIENT();
	CIRCULATECLIENTS();
	DAMAGECLIENT();
	DRAWCLIENT();
	CREATEROOTPICTURE();

	PRINTERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
	PRINTCONNECTIONERROR();
	PRINTXCBERROR();
/*!}*/

int main(const int argumentAmount, const char *const *argument){
	(void)argumentAmount;
	jmp setPrimaryGlobals;
	setPrimaryGlobals:{
		programName /*-----------*/ = *argument;
		errorPath /*-------------*/ = NULL;
		connectionName /*--------*/ = NULL;
		mustOpenErrorStream /*---*/ = false;
		errorStream /*-----------*/ = DefaultErrorStream;
		connection /*------------*/ = NULL;
		genericError /*----------*/ = NULL;
		event0 /*----------------*/ = NULL;
		quitMessage /*-----------*/ = NULL;
		treeReply /*-------------*/ = NULL;



		rootClient.rectangle /*--*/ = NULL;
		rectangleStart /*--------*/ = NULL;
		clientSize /*------------*/ = CLIENT_BLOCK_SIZE;
		clientAllocated /*-------*/ = 0;
		orderedMappedClientAllocated /*-*/ = 0;

		rootPicture /*-----------*/ = XCB_NONE;

		wallpaperPixmap /*-------*/ = XCB_NONE;
		wallpaperPicture /*------*/ = XCB_NONE;

		globalRegion /*----------*/ = XCB_NONE;



		jmp establishServerConnection;
	}
	establishServerConnection:{
		#define ESTABLISHSERVERCONNECTION_CONNECTION /*-----*/ connection
		#define ESTABLISHSERVERCONNECTION_CONNECTIONNAME /*-*/ connectionName
		#define ESTABLISHSERVERCONNECTION_SCREEN /*---------*/ screen
		#include "xcb/establishServerConnection.hold"
		switch xcb_connection_has_error(connection) over
			to XCB_NONE: /*------------*/ /*-----------------------------------------------------------------*/ brk;
			to XCB_CONN_CLOSED_PARSE_ERR: printError(connectionName? "invalid server name" : "no server name"); jmp mainEmergencyExit;
			off: /*--------------------*/ printConnectionError(); /*-----------------------------------------*/ jmp mainEmergencyExit;
		end
	}



	{
		xcb_grab_server(connection);
	}



	damageBaseEvent = 0;
	damageBaseError = 0;
	renderBaseEvent = 0;
	renderBaseError = 0;
	randrBaseEvent = 0;
	randrBaseError = 0;
	{
		const xcb_query_extension_cookie_t compositeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("Composite"), "Composite");
		const xcb_query_extension_cookie_t damageCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("DAMAGE"), "DAMAGE");
		const xcb_query_extension_cookie_t randrCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RANDR"), "RANDR");
		const xcb_query_extension_cookie_t renderCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("RENDER"), "RENDER");
		const xcb_query_extension_cookie_t xfixesCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("XFIXES"), "XFIXES");
		const xcb_query_extension_cookie_t shapeCookie = xcb_query_extension_unchecked(connection, LITERAL_LENGTH("SHAPE"), "SHAPE");
		xcb_query_extension_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_query_extension_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_query_extension_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_query_extension_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_query_extension_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_query_extension_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(!compositeReply or !(*compositeReply).present){
			fprintf(stdout, "composite extension not available\n");
		}else{
			free(compositeReply);
		}
		if(!damageReply or !(*damageReply).present){
			fprintf(stdout, "damage extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_damage_id);
			if(reply and (*reply).present){
				damageBaseEvent = (*reply).first_event;
				damageBaseError = (*reply).first_error;
			}
			free(damageReply);
		}
		if(!randrReply or !(*randrReply).present){
			fprintf(stdout, "randr extension not available\n");
		}else{
			free(randrReply);
		}
		if(!renderReply or !(*renderReply).present){
			fprintf(stdout, "render extension not available\n");
		}else{
			const xcb_query_extension_reply_t *const reply = xcb_get_extension_data(connection, &xcb_render_id);
			if(reply and (*reply).present){
				renderBaseEvent = (*reply).first_event;
				renderBaseError = (*reply).first_error;
			}
			free(renderReply);
		}
		if(!xfixesReply or !(*xfixesReply).present){
			fprintf(stdout, "xfixes extension not available\n");
		}else{
			free(xfixesReply);
		}
		if(!shapeReply or !(*shapeReply).present){
			fprintf(stdout, "shape extension not available\n");
		}else{
			free(shapeReply);
		}
	}
	{
		const xcb_damage_query_version_cookie_t compositeCookie = xcb_damage_query_version_unchecked(connection, XCB_COMPOSITE_MAJOR_VERSION, XCB_COMPOSITE_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t damageCookie = xcb_damage_query_version_unchecked(connection, XCB_DAMAGE_MAJOR_VERSION, XCB_DAMAGE_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t renderCookie = xcb_damage_query_version_unchecked(connection, XCB_RENDER_MAJOR_VERSION, XCB_RENDER_MINOR_VERSION);
		const xcb_damage_query_version_cookie_t randrCookie = xcb_damage_query_version_unchecked(connection, XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
		const xcb_xfixes_query_version_cookie_t xfixesCookie = xcb_xfixes_query_version_unchecked(connection, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION);
		const xcb_xfixes_query_version_cookie_t shapeCookie = xcb_xfixes_query_version_unchecked(connection, XCB_SHAPE_MAJOR_VERSION, XCB_SHAPE_MINOR_VERSION);
		xcb_damage_query_version_reply_t *const compositeReply = xcb_wait_for_reply(connection, compositeCookie, NULL);
		xcb_damage_query_version_reply_t *const damageReply = xcb_wait_for_reply(connection, damageCookie, NULL);
		xcb_damage_query_version_reply_t *const renderReply = xcb_wait_for_reply(connection, renderCookie, NULL);
		xcb_damage_query_version_reply_t *const randrReply = xcb_wait_for_reply(connection, randrCookie, NULL);
		xcb_xfixes_query_version_reply_t *const xfixesReply = xcb_wait_for_reply(connection, xfixesCookie, NULL);
		xcb_xfixes_query_version_reply_t *const shapeReply = xcb_wait_for_reply(connection, shapeCookie, NULL);
		if(compositeReply){
			free(compositeReply);
		}else{
			fprintf(stdout, "%s: could not query composite extension\n", programName);
		}
		if(damageReply){
			free(damageReply);
		}else{
			fprintf(stdout, "%s: could not query damage extension\n", programName);
		}
		if(renderReply){
			free(renderReply);
		}else{
			fprintf(stdout, "%s: could not query render extension\n", programName);
		}
		if(randrReply){
			free(randrReply);
		}else{
			fprintf(stdout, "%s: could not query randr extension\n", programName);
		}
		if(xfixesReply){
			free(xfixesReply);
		}else{
			fprintf(stdout, "%s: could not query xfixes extension\n", programName);
		}
		if(shapeReply){
			free(shapeReply);
		}else{
			fprintf(stdout, "%s: could not query shape extension\n", programName);
		}
	}



	{
		const uint32 stackMode = XCB_STACK_MODE_BELOW;
		xcb_composite_get_overlay_window_reply_t *const overlay = xcb_wait_for_reply(connection, xcb_composite_get_overlay_window_unchecked(connection, (*screen).root), NULL);
		if(overlay){
			overlayWindow = (*overlay).overlay_win;
			free(overlay);
		}
		xcb_configure_window(connection, overlayWindow, XCB_CONFIG_WINDOW_STACK_MODE, &stackMode);
	}



	{
		xcb_intern_atom_reply_t *reply;
		pixmapAtom = XCB_NONE;
		if((reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("PIXMAP"), "PIXMAP"), NULL))){
			pixmapAtom = (*reply).atom;
			free(reply);
		}
		rootPixmapAtom = XCB_NONE;
		if((reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, LITERAL_LENGTH("_XROOTPMAP_ID"), "_XROOTPMAP_ID"), NULL))){
			rootPixmapAtom = (*reply).atom;
			free(reply);
		}
	}



	{
		xcb_composite_redirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}



	jmp storeMonitors;
	storeMonitors:{
		void *reply;
		Monitor *monitorCurrent;
		xcb_randr_monitor_info_iterator_t iterator;
		if(!(reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL))){
			monitorAmount = 1;
			jmp storeMonitorsExit;
		}
		monitorAmount = (*(xcb_randr_get_monitors_reply_t *)reply).nMonitors;
		if(!(monitorData = malloc(monitorAmount * sizeof(Monitor)))){
			free(reply);
			jmp storeMonitorsExit;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorStart = monitorData;
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAmount;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const uint x = (*data).x;
				const uint y = (*data).y;
				const uint w = (*data).width;
				const uint h = (*data).height;
				if(monitorCurrent > monitorStart){
					const Monitor *const wall = monitorCurrent;
					const Monitor *current = monitorStart;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).x == x and (*current).y == y and (*current).w == w and (*current).h == h){
								dec monitorAmount;
								dec monitorWall;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).x = x;
				(*monitorCurrent).y = y;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				xcb_randr_monitor_info_next(&iterator);
				inc monitorCurrent;
				jmp storeMonitorLoop;
			}
			jmp trimMonitorMemory;
		}
		trimMonitorMemory:{
			void *temp;
			if(!(temp = realloc(monitorData, monitorAmount * sizeof(Monitor)))){
				free(reply);
				jmp storeMonitorsExit;
			}
			monitorData = temp;
		}
		monitorStart = monitorData;
		monitorWall = monitorStart + monitorAmount;
		free(reply);
		jmp storeMonitorsExit;
	}
	storeMonitorsExit:{}



	{
		if(!(clientStart = malloc(clientSize * sizeof(Client)))){
			fprintf(stdout, "no clientStart\n");
		}
		clientWall = clientStart + clientAllocated;



		if(!(orderedMappedClientOffsetStart = malloc(clientSize * sizeof(uint)))){
			fprintf(stdout, "no orderedMappedClientOffsetStart\n");
		}
		orderedMappedClientOffsetWall = orderedMappedClientOffsetStart + orderedMappedClientAllocated;



		if(!(rectangleStart = malloc(128 * sizeof(xcb_rectangle_t)))){
			fprintf(stdout, "no rectangleStart\n");
		}



		visualSize = VISUAL_FORMAT_PAIR_BLOCK_SIZE;
		visualAllocated = 0;
		if(!(visualStart = malloc(visualSize * sizeof(xcb_render_pictvisual_t)))){
			fprintf(stdout, "no visualStart\n");
			visualSize = 0;
		}
		defaultOpaqueFormat = XCB_NONE;
		defaultTransparentFormat = XCB_NONE;
		jmp matchVisualFormat;
	}
	matchVisualFormat:{
		xcb_render_query_pict_formats_reply_t *const formats = xcb_wait_for_reply(connection, xcb_render_query_pict_formats_unchecked(connection), NULL);
		if(formats){
			xcb_render_pictscreen_iterator_t pictscreenIterator = xcb_render_query_pict_formats_screens_iterator(formats);
			xcb_render_pictvisual_t *current = visualStart;
			while(pictscreenIterator.rem){
				xcb_render_pictdepth_iterator_t pictdepth = xcb_render_pictscreen_depths_iterator(pictscreenIterator.data);
				while(pictdepth.rem){
					xcb_render_pictvisual_t *const pictvisual = xcb_render_pictdepth_visuals(pictdepth.data);
					if(visualAllocated == visualSize){
						void *temp;
						visualSize += VISUAL_FORMAT_PAIR_BLOCK_SIZE;
						if(!(temp = realloc(visualStart, visualSize * sizeof(xcb_rectangle_t)))){
							jmp matchVisualFormatExit;
						}
						visualStart = temp;
					}
					if((*pictvisual).visual and (*pictvisual).format){
						*current = *pictvisual;
						switch (*pictdepth.data).depth over
							to 24:{
								if(!defaultOpaqueFormat){
									defaultOpaqueFormat = (*current).format;
								}
								brk;
							}
							to 32:{
								if(!defaultTransparentFormat){
									defaultTransparentFormat = (*current).format;
								}
								brk;
							}
							off:{
								brk;
							}
						end
						inc current;
						inc visualAllocated;
					}
					xcb_render_pictdepth_next(&pictdepth);
				}
				xcb_render_pictscreen_next(&pictscreenIterator);
			}
			free(formats);
		}
		jmp matchVisualFormatExit;
	}
	matchVisualFormatExit:{
		visualWall = visualStart + visualAllocated;
	}



	{
		rootFormat = findFormat((*screen).root_visual, (*screen).root_depth);
		createRootPicture();
		createWallpaper();
		setWallpaper();
	}



	{
		const uint32 valueList = XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_change_window_attributes(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
	}



	{
		lastClient = NULL;
		queryTree();
		if(treeReply){
			const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
			const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
			addExistingClientLoop:{
				addClient(*windowCurrent);
				if(inc windowCurrent < windowWall){
					jmp addExistingClientLoop;
				}
			}
		}
		calculateViewableWindowSizes();
		drawAllClients();
		drawWallpaper();
	}



	{
		xcb_ungrab_server(connection);
	}









	eventLoop:{
		xcb_flush(connection);
		free(event0);
		event0 = NULL;
		jmp waitForEventLoop;
	}
	waitForEventLoop:{
		if((event0 = xcb_wait_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		jmp eventLoop;
	}
	switchEvents:{
		#define XCB_ONE /*-*/ (1)
		switch (*event0).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unexpectedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp unexpectedEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp unexpectedEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp unexpectedEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp unexpectedEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
#ifdef a
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
#endif
			to XCB_VISIBILITY_NOTIFY: /*-*/ fprintf(stdout, "visibility notify\n"); jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ fprintf(stdout, "create notify\n"); jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ fprintf(stdout, "destroy notify\n"); jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ fprintf(stdout, "unmap notify\n"); jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ fprintf(stdout, "map notify\n"); jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ fprintf(stdout, "reparent notify\n"); jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ fprintf(stdout, "configure notify\n"); jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ fprintf(stdout, "circulate notify\n"); jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ fprintf(stdout, "property notify\n"); jmp propertyNotifyEvent;

			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp unexpectedEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	extensionEvent:{
		if(((*event0).response_type & ~b(10000000)) == damageBaseEvent + XCB_DAMAGE_NOTIFY){
			jmp damageNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseEvent + XCB_RANDR_SCREEN_CHANGE_NOTIFY){
			jmp randrNotifyEvent;
		}
		if(((*event0).response_type & ~b(10000000)) == damageBaseError + XCB_DAMAGE_BAD_DAMAGE){
			jmp badDamageError;
		}
		if(((*event0).response_type & ~b(10000000)) == randrBaseError){
			jmp randrNotifyError;
		}
		jmp unexpectedEvent;
	}
	visibilityNotifyEvent:{
		#define event0 /*-*/ ((xcb_visibility_notify_event_t *)event0)
		Client *client;
		if((client = findClient((*event0).window))){
			if((*event0).state != XCB_VISIBILITY_FULLY_OBSCURED){
				mapClient(client);
				jmp eventLoop;
			}
			unmapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	createNotifyEvent:{
		#define event0 /*-*/ ((xcb_create_notify_event_t *)event0)
		Client *client;
		queryTree();
		if(!(client = findClient((*event0).window))){
			addClient((*event0).window);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	destroyNotifyEvent:{
		#define event0 /*-*/ ((xcb_destroy_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((client = findClient((*event0).window))){
			destroyClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	unmapNotifyEvent:{
		#define event0 /*-*/ ((xcb_unmap_notify_event_t *)event0)
		Client *client;
		if((client = findMappedClient((*event0).window))){
			unmapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	mapNotifyEvent:{
		#define event0 /*-*/ ((xcb_map_notify_event_t *)event0)
		Client *client;
		if((client = findClient((*event0).window))){
			mapClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	reparentNotifyEvent:{
		#define event0 /*-*/ ((xcb_reparent_notify_event_t *)event0)
		Client *client;
		queryTree();
		client = findClient((*event0).window);
		if((*event0).parent == (*screen).root){
			if(!client){
				addClient((*event0).window);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(client){
			destroyClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	configureNotifyEvent:{
		#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
		Client *client;
		queryTree();
		if((client = findMappedClient((*event0).window)) or (client = findClient((*event0).window))){
			configureClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	circulateNotifyEvent:{
		#define event0 /*-*/ ((xcb_circulate_notify_event_t *)event0)
		queryTree();
		circulateClients();
		jmp eventLoop;
		#undef  event0
	}
	propertyNotifyEvent:{
		#define event0 /*-*/ ((xcb_property_notify_event_t *)event0)
		if((*event0).atom == rootPixmapAtom and rootPixmapAtom){
			setWallpaper();
			drawWallpaper();
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	damageNotifyEvent:{
		#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
		Client *client;
		if((client = findMappedClient((*event0).drawable))){
			damageClient(client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  event0
	}
	errorEvent:{
		genericError = (void *)event0;
		printXCBError();
		genericError = NULL;
		jmp eventLoop;
	}
	unexpectedEvent:{
		jmp eventLoop;
	}
	badDamageError:{
		fprintf(stdout, "%s: bad damage error\n", programName);
		jmp eventLoop;
	}
	randrNotifyEvent:{
		fprintf(stdout, "%s: randr notify event\n", programName);
		calculateViewableWindowSizes();
		createRootPicture();
		createWallpaper();
		setWallpaper();
		drawWallpaper();
		jmp eventLoop;
	}
	randrNotifyError:{
		fprintf(stdout, "%s: randr notify error\n", programName);
		jmp eventLoop;
	}
	eventLoopExit:{
		free(event0);
		event0 = NULL;
		jmp mainEmergencyExit;
	}
	mainEmergencyExit:{



		/*! update all this eventually */



		if(treeReply){
			free(treeReply);
		}



		free(visualStart);
		free(orderedMappedClientOffsetStart);
		free(clientStart);



		xcb_render_free_picture(connection, wallpaperPicture);
		xcb_free_pixmap(connection, wallpaperPixmap);



		xcb_render_free_picture(connection, rootPicture);



		xcb_composite_unredirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);



		xcb_disconnect(connection);
		ret 0;
	}
}



























MAPCLIENT(){
	(*client).mapInfo |= MAPPED_MAP_INFO;
	if(!(*client).picture){
		(*client).picture = xcb_generate_id(connection);
		xcb_render_create_picture_checked(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL); /*! annoying on discord tray window create, match error */
	}



	updateOrder(); /*! update order but do it only for the mapped windows pointer list */



	calculateViewableWindowSizes();
	drawClient(client);
	ret;
}
UNMAPCLIENT(){
	if((*client).mapInfo & MAPPED_MAP_INFO){
		(*client).mapInfo &= ~MAPPED_MAP_INFO;
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on discord tray icon window delete */
			(*client).picture = XCB_NONE;
		}



		updateOrder(); /*! update order but do it only for the mapped windows pointer list */



		calculateViewableWindowSizes();
		drawBelowClient(client, (*client).x, (*client).y, (*client).w, (*client).h);
		drawWallpaper();
	}
	ret;
}
DESTROYCLIENT(){
	unmapClient(client);
	{
		if((*client).damage){
			xcb_damage_destroy_checked(connection, (*client).damage); /*! annoying on window deleting */
		}
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on window deleting */
		}
		*client = *(dec clientWall);
		dec clientAllocated;
	}
	updateOrder();
	ret;
}
CIRCULATECLIENTS(){
	updateOrder();
	calculateViewableWindowSizes();
	drawAllClients();
	drawWallpaper();
	ret;
}
DAMAGECLIENT(){
	#define event0 /*-*/ ((xcb_damage_notify_event_t *)event0)
	if((*client).mapInfo & VIEWABLE_MAP_INFO and (*client).allocated){
		const xcb_rectangle_t *const geometry = &(*event0).geometry;
		const int x = (*geometry).x;
		const int y = (*geometry).y;
		const int w = (*geometry).width;
		const int h = (*geometry).height;
		const uint amount = getClientIntersectingRectangles(client, x, y, x + w, y + h);
		xcb_damage_subtract(connection, (*client).damage, XCB_NONE, XCB_NONE);
		if(amount){
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
			xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
			xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, x - (*client).x, y - (*client).y, 0, 0, x, y, w, h);
			xcb_xfixes_destroy_region_checked(connection, region);
		}
	}
	ret;
	#undef  event0
}



























ADDCLIENT(){
	/*!
		(*client).size = 0;
		(*client).allocated = 0;
		(*client).rectangle = NULL;

		(*client).window = window;
		(*client).damage = XCB_NONE;
		(*client).format = XCB_NONE;
		(*client).picture = XCB_NONE;

		(*client).x = 0;
		(*client).y = 0;
		(*client).w = 0;
		(*client).h = 0;
		(*client).rightX = 0;
		(*client).bottomY = 0;

		(*client).shaped = false;
		(*client).mapInfo = NONE_MAP_INFO;
		(*client).depth = 24;
		(*client).useSpecialEffect = false;
	*/



	xcb_get_window_attributes_cookie_t attributesCookie;
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_get_window_attributes_reply_t *attributesReply;
	xcb_get_geometry_reply_t *geometryReply;
	Client *client;
	if(window == overlayWindow){
		ret;
	}
	attributesCookie = xcb_get_window_attributes_unchecked(connection, window);
	geometryCookie = xcb_get_geometry_unchecked(connection, window);
	attributesReply = xcb_wait_for_reply(connection, attributesCookie, NULL);
	geometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);









	/*! even if some shit fails, add the client with defaults */



	if(!attributesReply or !geometryReply){
		fprintf(stdout, "could not add client %x due to replies\n", window);
		jmp emergencyExit;
	}



	if(clientAllocated == clientSize){
		void *temp;
		void *temp1;
		clientSize += CLIENT_BLOCK_SIZE;
		if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
			jmp emergencyExit;
		}
		clientStart = temp;
		if(!(temp1 = realloc(orderedMappedClientOffsetStart, clientSize * sizeof(uint)))){
			jmp emergencyExit;
		}
		orderedMappedClientOffsetStart = temp1;
	}
	clientWall = clientStart + clientAllocated;
	orderedMappedClientOffsetWall = orderedMappedClientOffsetStart + orderedMappedClientAllocated;

	client = clientWall;

	inc clientAllocated;
	inc clientWall;



	if(geometryReply){
		(*client).x = (*geometryReply).x;
		(*client).y = (*geometryReply).y;
		(*client).w = (*geometryReply).width + 2 * (*geometryReply).border_width;
		(*client).h = (*geometryReply).height + 2 * (*geometryReply).border_width;
	}else{
		(*client).x = (*screen).width_in_pixels;
		(*client).y = (*screen).height_in_pixels;
		(*client).w = 0;
		(*client).h = 0;
	}
	(*client).rightX = (*client).x + (*client).w;
	(*client).bottomY = (*client).y + (*client).h;



	(*client).window = window;
	(*client).format = findFormat((*attributesReply).visual, (*geometryReply).depth);
	(*client).damage = XCB_NONE;
	(*client).picture = XCB_NONE;



	(*client).mapInfo = NONE_MAP_INFO;
	if((*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED){
		(*client).mapInfo |= MAPPED_MAP_INFO;
		*orderedMappedClientOffsetWall = client - clientStart;
		inc orderedMappedClientAllocated;
		inc orderedMappedClientOffsetWall;
	}
	if(!((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels)){
		(*client).mapInfo |= VIEWABLE_MAP_INFO;
	}



	(*client).useSpecialEffect = false;



	(*client).size = RECTANGLE_BLOCK_SIZE;
	(*client).allocated = 0;
	(*client).rectangle = malloc((*client).size * sizeof(xcb_rectangle_t));



	xcb_change_window_attributes(connection, window, XCB_CW_EVENT_MASK, &windowValueList);



	if((*attributesReply)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
		(*client).damage = xcb_generate_id(connection);
		xcb_damage_create(connection, (*client).damage, window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
		if((*client).mapInfo & MAPPED_MAP_INFO){
			(*client).picture = xcb_generate_id(connection);
			xcb_render_create_picture(connection, (*client).picture, window, (*client).format, XCB_NONE, NULL);
		}
	}



	jmp emergencyExit;
	emergencyExit:{
		free(attributesReply);
		free(geometryReply);
		ret;
	}
}
CONFIGURECLIENT(){
	#define event0 /*-*/ ((xcb_configure_notify_event_t *)event0)
	const int x = (*client).x;
	const int y = (*client).y;
	const int w = (*client).w;
	const int h = (*client).h;
	{
		(*client).x = (*event0).x;
		(*client).y = (*event0).y;
		(*client).w = (*event0).width + 2 * (*event0).border_width;
		(*client).h = (*event0).height + 2 * (*event0).border_width;
		(*client).rightX = (*client).x + (*client).w;
		(*client).bottomY = (*client).y + (*client).h;
		(*client).mapInfo &= ~VIEWABLE_MAP_INFO;
		if(!((*client).rightX < 1 or (*client).x >= (*screen).width_in_pixels or (*client).bottomY < 1 or (*client).y >= (*screen).height_in_pixels)){
			(*client).mapInfo |= VIEWABLE_MAP_INFO;
		}
		if((*client).picture){
			xcb_render_free_picture_checked(connection, (*client).picture); /*! annoying on window delete */
			(*client).picture = xcb_generate_id(connection);
			xcb_render_create_picture_checked(connection, (*client).picture, (*client).window, (*client).format, XCB_NONE, NULL); /*! annoying on window delete */
		}
	}
	updateOrder();
	if((*client).mapInfo & MAPPED_MAP_INFO){
		calculateViewableWindowSizes();
		drawBelowClient(client, x, y, w, h);
		drawClient(client);
		drawWallpaper();
	}
	ret;
	#undef  event0
}
DRAWBELOWCLIENT(){
	const uint *offsetCurrent = orderedMappedClientOffsetStart;
	jmp loop;
	loop:{
		if(offsetCurrent < orderedMappedClientOffsetWall){
			const Client *const current = clientStart + *offsetCurrent;
			int x;
			int y;
			int w;
			int h;
			if(current == client){
				jmp loopExit;
			}
			if((*current).mapInfo & VIEWABLE_MAP_INFO and (*current).allocated and getIntersectingRectangle((*current).x, (*current).y, (*current).w, (*current).h, eventX, eventY, eventW, eventH, &x, &y, &w, &h)){
				xcb_rectangle_t *rectangle = (*current).rectangle;
				xcb_rectangle_t *const rectangleWall = rectangle + (*current).allocated;
				uint size = RECTANGLE_BLOCK_SIZE;
				uint allocated = 0;
				xcb_rectangle_t *newRectangle = malloc(size * sizeof(xcb_rectangle_t));
				if(newRectangle){
					jmp splitRectanglesLoop;
					splitRectanglesLoop:{
						if(rectangle < rectangleWall){
							int x1;
							int y1;
							int w1;
							int h1;
							if(getIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, x, y, w, h, &x1, &y1, &w1, &h1)){
								xcb_rectangle_t *currentRectangle;
								if(allocated == size){
									void *temp;
									size += RECTANGLE_BLOCK_SIZE;
									if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){
										jmp loopExit;
									}
									newRectangle = temp;
								}
								currentRectangle = newRectangle + allocated;
								(*currentRectangle).x = x1;
								(*currentRectangle).y = y1;
								(*currentRectangle).width = w1;
								(*currentRectangle).height = h1;
								inc allocated;
							}
							inc rectangle;
							jmp splitRectanglesLoop;
						}
					}
					if(allocated){
						const xcb_xfixes_region_t region = xcb_generate_id(connection);
						xcb_xfixes_create_region_checked(connection, region, allocated, newRectangle);
						xcb_xfixes_set_picture_clip_region_checked(connection, (*current).picture, region, 0, 0);
						xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*current).picture, XCB_NONE, rootPicture, x - (*current).x, y - (*current).y, 0, 0, x, y, w, h);
						xcb_xfixes_destroy_region_checked(connection, region);
					}
					free(newRectangle);
				}
			}
			inc offsetCurrent;
			jmp loop;
		}
	}
	loopExit:{}
	ret;
}
GETINTERSECTINGRECTANGLE(){
	const int  rightX0 = leftX0 +  width0;
	const int  rightX1 = leftX1 +  width1;
	const int bottomY0 =  topY0 + height0;
	const int bottomY1 =  topY1 + height1;
	if(leftX1 < rightX0 and rightX1 > leftX0 and topY1 < bottomY0 and bottomY1 > topY0){
		*retX =    leftX0 >   leftX1?   leftX0 :   leftX1;
		*retY =     topY0 >    topY1?    topY0 :    topY1;
		*retW = ( rightX0 <  rightX1?  rightX0 :  rightX1) - *retX;
		*retH = (bottomY0 < bottomY1? bottomY0 : bottomY1) - *retY;
		ret true;
	}
	ret false;
}
SPLITRECTANGLE(){
	xcb_rectangle_t *current;
	if(*allocated + 4 >= *size){
		void *temp;
		*size += RECTANGLE_BLOCK_SIZE;
		if(!(temp = realloc(*rectangle, *size * sizeof(xcb_rectangle_t)))){
			jmp emergencyExit;
		}
		*rectangle = temp;
	}
	current = *rectangle + *allocated;
	if(interY > y){
		(*current).x = x;
		(*current).y = y;
		(*current).width = w;
		(*current).height = interY - y;
		inc current;
	}
	if(interY + interH < y + h){
		(*current).x = x;
		(*current).y = interY + interH;
		(*current).width = w;
		(*current).height = y + h - interY - interH;
		inc current;
	}
	if(interX > x){
		(*current).x = x;
		(*current).y = interY;
		(*current).width = interX - x;
		(*current).height = interH;
		inc current;
	}
	if(interX + interW < x + w){
		(*current).x = interX + interW;
		(*current).y = interY;
		(*current).width = x + w - interX - interW;
		(*current).height = interH;
		inc current;
	}
	*allocated = current - *rectangle;
	ret;
	emergencyExit:{



		/*! realloc will eventually fail. what do? */



		*size = RECTANGLE_BLOCK_SIZE;
		*allocated = 0;
		free(*rectangle);
		*rectangle = NULL;
		ret;
	}
}
CALCULATEVIEWABLEWINDOWSIZES(){
	const uint *belowCurrent = orderedMappedClientOffsetStart;
	bool useRoot = true;
	jmp resetRootClientRectangle;
	resetRootClientRectangle:{
		rootClient.x = 0;
		rootClient.y = 0;
		rootClient.w = (*screen).width_in_pixels;
		rootClient.h = (*screen).height_in_pixels;
		rootClient.size = RECTANGLE_BLOCK_SIZE;
		rootClient.allocated = 0;
		if(!rootClient.rectangle){
			rootClient.rectangle = malloc(RECTANGLE_BLOCK_SIZE * sizeof(xcb_rectangle_t));
		}
		{
			xcb_rectangle_t *rectangle = rootClient.rectangle;
			if(rectangle){
				(*rectangle).x = rootClient.x;
				(*rectangle).y = rootClient.y;
				(*rectangle).width = rootClient.w;
				(*rectangle).height = rootClient.h;
				rootClient.allocated = 1;
			}
		}
		jmp resetClientRectangle;
	}
	resetClientRectangle:{
		Client *client = clientStart;
		jmp resetClientRectangleLoop;
		resetClientRectangleLoop:{
			if(client < clientWall){
				xcb_rectangle_t *rectangle = (*client).rectangle;
				if(rectangle){
					(*rectangle).x = (*client).x;
					(*rectangle).y = (*client).y;
					(*rectangle).width = (*client).w;
					(*rectangle).height = (*client).h;
					(*client).allocated = 1;
				}
				inc client;
				jmp resetClientRectangleLoop;
			}
		}
		jmp belowClientLoop;
	}
	belowClientLoop:{
		if(belowCurrent < orderedMappedClientOffsetWall){
			const uint *aboveCurrent = belowCurrent + 1;
			Client *below;
			if(useRoot){
				below = &rootClient;
				dec belowCurrent;
				useRoot = false;
			}else{
				below = clientStart + *belowCurrent;
				if(!((*below).mapInfo & VIEWABLE_MAP_INFO) or !(*below).allocated){
					inc belowCurrent;
					jmp belowClientLoop;
				}
			}
			jmp aboveClientLoop;
			aboveClientLoop:{
				if(aboveCurrent < orderedMappedClientOffsetWall){
					Client *const above = clientStart + *aboveCurrent;
					int x;
					int y;
					int w;
					int h;
					if((*above).mapInfo & VIEWABLE_MAP_INFO and getIntersectingRectangle((*above).x, (*above).y, (*above).w, (*above).h, (*below).x, (*below).y, (*below).w, (*below).h, &x, &y, &w, &h)){
						if((*below).allocated){
							xcb_rectangle_t *rectangle = (*below).rectangle;
							xcb_rectangle_t *const rectangleWall = rectangle + (*below).allocated;
							uint size = RECTANGLE_BLOCK_SIZE;
							uint allocated = 0;
							xcb_rectangle_t *newRectangle = malloc(size * sizeof(xcb_rectangle_t));
							if(!newRectangle){
								ret;
							}
							jmp splitRectanglesLoop;
							splitRectanglesLoop:{
								if(rectangle < rectangleWall){
									if(getIntersectingRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, (*above).x, (*above).y, (*above).w, (*above).h, &x, &y, &w, &h)){
										splitRectangle((*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height, x, y, w, h, &size, &allocated, &newRectangle);
									}else{
										if(allocated == size){
											void *temp;
											size += RECTANGLE_BLOCK_SIZE;
											if(!(temp = realloc(newRectangle, size * sizeof(xcb_rectangle_t)))){
												ret;
											}
											newRectangle = temp;
										}
										*(newRectangle + allocated) = *rectangle;
										inc allocated;
									}
									inc rectangle;
									jmp splitRectanglesLoop;
								}
							}
							free((*below).rectangle);
							(*below).size = size;
							(*below).allocated = allocated;
							(*below).rectangle = newRectangle;
						}
					}
					inc aboveCurrent;
					jmp aboveClientLoop;
				}
			}
			inc belowCurrent;
			jmp belowClientLoop;
		}
	}









	/*! {
		uint *current = orderedMappedClientOffsetStart;
		uint i = 0;
		while(current < orderedMappedClientOffsetWall){
			Client *client = clientStart + *current;
			if((*client).mapInfo & VIEWABLE_MAP_INFO){
				xcb_rectangle_t *rectangle = (*client).rectangle;
				xcb_rectangle_t *wall = (*client).rectangle + (*client).allocated;
				fprintf(stdout, "\tclient %u:\n", i);
				inc i;
				while(rectangle < wall){
					fprintf(stdout, "\t\t%i %i %i %i\n", (*rectangle).x, (*rectangle).y, (*rectangle).width, (*rectangle).height);
					inc rectangle;
				}
			}
			inc current;
		}
		fprintf(stdout, "\n\n\n");
	} */



	ret;
}
UPDATEORDER(){
	if(treeReply){
		const xcb_window_t *windowCurrent = xcb_query_tree_children(treeReply);
		const xcb_window_t *const windowWall = windowCurrent + xcb_query_tree_children_length(treeReply);
		const uint8 *const firstClientStartWindow = (void *)&(*clientStart).window;
		Client *startingClient = clientStart;
		uint *orderedMappedClientOffsetCurrent = orderedMappedClientOffsetStart;
		lastClient = NULL;
		jmp findClientWindowLoop;
		findClientWindowLoop:{
			const xcb_window_t window = *windowCurrent;
			Client *client;
			{
				const uint8 *const firstWindow = (void *)&(*startingClient).window;
				const uint8 *current = firstWindow;
				jmp findClientLoop;
				findClientLoop:{
					if(*(xcb_window_t *)current == window){
						client = (void *)(current - (firstClientStartWindow - (uint8 *)clientStart));
						if(client == startingClient){
							inc startingClient;
						}
						jmp quitLooking;
					}
					if((current += sizeof(Client)) < (uint8 *)clientWall){
						jmp findClientLoop;
					}
					client = NULL;
				}
			}
			quitLooking:{}
			if(client){
				if((*client).mapInfo & MAPPED_MAP_INFO){
					*orderedMappedClientOffsetCurrent = client - clientStart;
					inc orderedMappedClientOffsetCurrent;
				}
			}else{
				if(*windowCurrent != overlayWindow){



					fprintf(stdout, "\n\n\ninvalid client offset\n\n\n\n");



				}
			}
			if(inc windowCurrent < windowWall){
				jmp findClientWindowLoop;
			}
		}
		orderedMappedClientAllocated = orderedMappedClientOffsetCurrent - orderedMappedClientOffsetStart;
		orderedMappedClientOffsetWall = orderedMappedClientOffsetCurrent;
	}
	ret;
}
GETCLIENTINTERSECTINGRECTANGLES(){
	const xcb_rectangle_t *rectangle = (*client).rectangle;
	const xcb_rectangle_t *const wall = rectangle + (*client).allocated;
	xcb_rectangle_t *rectangleCurrent = rectangleStart;
	jmp getIntersectingRectangleLoop;
	getIntersectingRectangleLoop:{
		if(rectangle < wall){
			const int leftX1 = (*rectangle).x;
			const int topY1 = (*rectangle).y;
			const int rightX1 = leftX1 + (*rectangle).width;
			const int bottomY1 = topY1 + (*rectangle).height;
			if(leftX0 < rightX1 and rightX0 > leftX1 and topY0 < bottomY1 and bottomY0 > topY1){
				(*rectangleCurrent).x      =    leftX1 >   leftX0?   leftX1 :   leftX0;
				(*rectangleCurrent).y      =     topY1 >    topY0?    topY1 :    topY0;
				(*rectangleCurrent).width  = ( rightX1 <  rightX0?  rightX1 :  rightX0) - (*rectangleCurrent).x;
				(*rectangleCurrent).height = (bottomY1 < bottomY0? bottomY1 : bottomY0) - (*rectangleCurrent).y;
				inc rectangleCurrent;
			}
			inc rectangle;
			jmp getIntersectingRectangleLoop;
		}
		ret rectangleCurrent - rectangleStart;
	}
}




























DRAWALLCLIENTS(){
	const uint *offsetCurrent = orderedMappedClientOffsetStart;
	jmp drawClientLoop;
	drawClientLoop:{
		if(offsetCurrent < orderedMappedClientOffsetWall){
			const Client *const client = clientStart + *offsetCurrent;
			if((*client).mapInfo & VIEWABLE_MAP_INFO and (*client).allocated){
				const uint amount = getClientIntersectingRectangles(client, (*client).x, (*client).y, (*client).rightX, (*client).bottomY);
				if(amount){
					const xcb_xfixes_region_t region = xcb_generate_id(connection);
					xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
					xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
					xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).w, (*client).h);
					xcb_xfixes_destroy_region_checked(connection, region);
				}
			}
			inc offsetCurrent;
			jmp drawClientLoop;
		}
	}
	ret;
}
CREATEROOTPICTURE(){
	if(rootPicture){
		xcb_render_free_picture(connection, rootPicture);
	}
	rootPicture = xcb_generate_id(connection);
	xcb_render_create_picture(connection, rootPicture, overlayWindow, rootFormat, XCB_NONE, NULL);
	ret;
}
CREATEWALLPAPER(){
	if(wallpaperPicture){
		xcb_render_free_picture(connection, wallpaperPicture);
	}
	if(wallpaperPixmap){
		xcb_free_pixmap(connection, wallpaperPixmap);
	}
	wallpaperPixmap = xcb_generate_id(connection);
	wallpaperPicture = xcb_generate_id(connection);
	xcb_create_pixmap(connection, (*screen).root_depth, wallpaperPixmap, (*screen).root, (*screen).width_in_pixels, (*screen).height_in_pixels);
	xcb_render_create_picture(connection, wallpaperPicture, wallpaperPixmap, rootFormat, XCB_NONE, NULL);
	ret;
}
SETWALLPAPER(){
	{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		const uint32 valueList = 0xFF000000;
		xcb_rectangle_t rectangle;
		rectangle.x = 0;
		rectangle.y = 0;
		rectangle.width = (*screen).width_in_pixels;
		rectangle.height = (*screen).height_in_pixels;
		xcb_create_gc(connection, gc, wallpaperPixmap, XCB_GC_FOREGROUND, &valueList);
		xcb_poly_fill_rectangle(connection, wallpaperPixmap, gc, 1, &rectangle);
		xcb_free_gc(connection, gc);
	}
	if(rootPixmapAtom and pixmapAtom){
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL);
		if(!reply){
			ret;
		}
		if((*reply).type != pixmapAtom){
			fprintf(stdout, "%s: root pixmap is not of type pixmap\n", programName);
		}else{
			const xcb_pixmap_t pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
			const xcb_get_geometry_cookie_t cookie = xcb_get_geometry_unchecked(connection, pixmap);
			const xcb_gcontext_t gc = xcb_generate_id(connection);
			xcb_get_geometry_reply_t *geometryReply;
			uint width = (*screen).width_in_pixels;
			uint height = (*screen).height_in_pixels;
			xcb_create_gc(connection, gc, pixmap, XCB_NONE, NULL);
			if((geometryReply = xcb_wait_for_reply(connection, cookie, NULL))){
				width = (*geometryReply).width;
				height = (*geometryReply).height;
				free(geometryReply);
			}
			xcb_copy_area(connection, pixmap, wallpaperPixmap, gc, 0, 0, 0, 0, width, height);
			xcb_free_gc(connection, gc);
		}
		free(reply);
	}
	ret;
}
DRAWWALLPAPER(){
	if(rootClient.allocated){
		const xcb_xfixes_region_t region = xcb_generate_id(connection);
		xcb_xfixes_create_region_checked(connection, region, rootClient.allocated, rootClient.rectangle);
		xcb_xfixes_set_picture_clip_region_checked(connection, wallpaperPicture, region, 0, 0);
		xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, wallpaperPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, (*screen).width_in_pixels, (*screen).height_in_pixels);
		xcb_xfixes_destroy_region_checked(connection, region);
	}
	ret;
}
DRAWCLIENT(){
	if((*client).allocated){
		const uint amount = getClientIntersectingRectangles(client, (*client).x, (*client).y, (*client).rightX, (*client).bottomY);
		if(amount){
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region_checked(connection, region, amount, rectangleStart);
			xcb_xfixes_set_picture_clip_region_checked(connection, (*client).picture, region, 0, 0);
			xcb_render_composite_checked(connection, XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, rootPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).w, (*client).h);
			xcb_xfixes_destroy_region_checked(connection, region);
		}
	}
	ret;
}



























FINDFORMAT(){
	const xcb_render_pictvisual_t *current = visualStart;
	jmp findVisualLoop;
	findVisualLoop:{
		if(current < visualWall){
			if((*current).visual == visual){
				ret (*current).format;
			}
			inc current;
			jmp findVisualLoop;
		}
		if(depth == 32){
			ret defaultTransparentFormat;
		}
		ret defaultOpaqueFormat;
	}
}
QUERYTREE(){
	const xcb_query_tree_cookie_t cookie = xcb_query_tree_unchecked(connection, (*screen).root);
	if(treeReply){
		free(treeReply);
	}
	treeReply = xcb_wait_for_reply(connection, cookie, NULL);
	ret;
}
FINDCLIENT(){
	const uint8 *firstWindow;
	const uint8 *current;
	jmp checkLastClient;
	checkLastClient:{
		if(lastClient and (*lastClient).window == window){
			ret lastClient;
		}
		firstWindow = (void *)&(*clientStart).window;
		current = firstWindow;
		jmp findClientLoop;
	}
	findClientLoop:{
		if(*(xcb_window_t *)current == window){
			lastClient = (void *)(current - (firstWindow - (uint8 *)clientStart));
			ret lastClient;
		}
		if((current += sizeof(Client)) < (uint8 *)clientWall){
			jmp findClientLoop;
		}
		ret NULL;
	}
}
FINDMAPPEDCLIENT(){
	const uint *offsetCurrent;
	jmp checkLastClient;
	checkLastClient:{
		if(lastClient and (*lastClient).window == window and (*lastClient).mapInfo & MAPPED_MAP_INFO){
			ret lastClient;
		}
		offsetCurrent = orderedMappedClientOffsetStart;
		jmp findMappedClientLoop;
	}
	findMappedClientLoop:{
		if(offsetCurrent < orderedMappedClientOffsetWall){
			Client *const current = clientStart + *offsetCurrent;
			if((*current).window == window){
				lastClient = current;
				ret lastClient;
			}
			inc offsetCurrent;
			jmp findMappedClientLoop;
		}
		ret NULL;
	}
}
PRINTERROR(){
	if(openErrorStream()){
		fprintf(errorStream, "%s: %s\n", programName, string);
		closeErrorStream();
	}
	ret;
}
OPENERRORSTREAM(){
	ret !mustOpenErrorStream or (errorStream = fopen(errorPath, "a"));
}
CLOSEERRORSTREAM(){
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		errorStream = NULL;
	}
	ret;
}
PRINTCONNECTIONERROR(){
	if(openErrorStream()){
		#define PRINTCONNECTIONERROR_ERROR /*--*/ xcb_connection_has_error(connection)
		#define PRINTCONNECTIONERROR_STREAM /*-*/ errorStream
		#include "xcb/printConnectionError.hold"
		closeErrorStream();
	}
	ret;
}
PRINTXCBERROR(){
	if(openErrorStream()){
		#define PRINTXCBERROR_ERROR /*--*/ genericError
		#define PRINTXCBERROR_STREAM /*-*/ errorStream
		#include "xcb/printXCBError.hold"
		closeErrorStream();
	}
	ret;
}
