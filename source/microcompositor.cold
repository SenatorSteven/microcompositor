/*!
	monitor changes to overlay window, correct them if need be and adjust to permanent changes
*/

/*!
	update z-order code in events (many) code
*/

/*!
	write down how to deal with the final frame drawing + which windows to draw
*/

/*!
	make sure that, no matter what the monitor setup, no work is being done for something that lies outside what the user sees
*/

/*!
	update configure notify. nothing new is mapped or unmapped so use the pointers to mapped windows for changes
*/

/*!
	calculateWallpaperStrips() will need a serious update to conform with weird monitor setups
*/

/*!
	setup mechanism for wasteless drawing, such that front windows are handled before back windows

	note: draw 24 bit windows first and then 32 bit
*/

/*!
	program *probably* crashes entire server when monitor setup changes
*/

/*!
	review all request failures etc. replies and use appropriate placeholder values and responses
*/

/*!
	update stacking order logic on create notify. who says it goes on the very top of the stacking order?
*/

/*!
	bug causes window to appear at (0, 0) when window is created. sometimes, probably when the clientAllocated counter goes up. querying root stacking order, which is the slow method, works fine.
*/

/*!
	consider drawing frame after each event due to the fact that many events could arrive at the same time

	consider multithreading which blocks execution of frame drawing when data is changed via event
*/



























/*! microcompositor.cold

MIT License

Copyright (C) 2023 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#include <stdint.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <xcb/randr.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include <xcb/composite.h>
	#include "cold/cold.hold"
/*!}*/

/*!user_defines:{*/
	#define DefaultErrorStream /*---------*/ (stderr)
/*!}*/

/*!defines:{*/
	#define DEBUG /*----------------------*/ (true)

	#define _EMPTY_MACRO /*---------------*/

	#if DEBUG
		#define _PRINTEVENT_DEC /*-------------*/ local void printEvent(void)
		#define _PRINTUNEXPECTEDEVENT_DEC /*---*/ local void printUnexpectedEvent(void)
		#define _printEvent(void) /*-----------*/ (printEvent())
		#define _printUnexpectedEvent(void) /*-*/ (printUnexpectedEvent())
	#else
		#define _PRINTEVENT_DEC /*-------------*/ def void dA
		#define _PRINTUNEXPECTEDEVENT_DEC /*---*/ def void a2
		#define _printEvent(void) /*-----------*/ _EMPTY_MACRO
		#define _printUnexpectedEvent(void) /*-*/ _EMPTY_MACRO
	#endif

	#define PRINTERROR_DEC /*-------------*/ local void printError(const char *const string)
	#define OPENERRORSTREAM_DEC /*--------*/ local bool openErrorStream(void)
	#define CLOSEERRORSTREAM_DEC /*-------*/ local void closeErrorStream(void)
	#define PRINTCONNECTIONERROR_DEC /*---*/ local void printConnectionError(void)
	#define PRINTEVENT_DEC /*-------------*/ _PRINTEVENT_DEC
	#define PRINTXCBERROR_DEC /*----------*/ local void printXCBError(void)
	#define PRINTUNEXPECTEDEVENT_DEC /*---*/ _PRINTUNEXPECTEDEVENT_DEC

	#define printEvent(void) /*-----------*/ _printEvent()
	#define printUnexpectedEvent(void) /*-*/ _printUnexpectedEvent()

	#define xcb_wait_for_reply(a, b, c) /*-*/ (xcb_wait_for_reply(a, (b).sequence, c))

	#define consumeRepeatingEvent(e0, e1, name) /*-*/ { \
		consumeRepeating##name:{ \
			if(((e1) = xcb_poll_for_event(connection))){ \
				if((*(e1)).response_type == name){ \
					free(e0); \
					(e0) = (e1); \
					jmp consumeRepeating##name; \
				} \
			}elif(xcb_connection_has_error(connection)){ \
				printConnectionError(); \
				jmp consumeRepeating##name##Exit; \
			} \
		} \
		consumeRepeating##name##Exit:{} \
	}
/*!}*/

/*!globals:{*/
	#define xScreen /*-------*/ xcb_screen_t
	#define xConnection /*---*/ xcb_connection_t
	#define xGenericError /*-*/ xcb_generic_error_t
	#define xVisual /*-------*/ xcb_visualid_t
	#define xDepth /*--------*/ uint8
	const char * /*----*/ programName;
	const char * /*----*/ errorPath;
	const char * /*----*/ connectionName;
	const xScreen * /*-*/ screen;
	const char * /*----*/ quitMessage;
	bool /*------------*/ mustOpenErrorStream;
	FILE * /*----------*/ errorStream;
	xConnection * /*---*/ connection;
	xGenericError * /*-*/ genericError;
	xcb_generic_event_t * /*-*/ event0;
	xcb_generic_event_t * /*-*/ event1;
	void * /*----------*/ agp0;
	uint32 /*----------*/ foreground;
	uint32 /*----------*/ background;
	xVisual /*---------*/ visual;
	xDepth /*----------*/ depth;
	#undef  xGenericEvent
	#undef  xGenericError
	#undef  xConnection
	#undef  xScreen
/*!}*/

/*!functions:{*/
	PRINTERROR_DEC;
	OPENERRORSTREAM_DEC;
	CLOSEERRORSTREAM_DEC;
	PRINTCONNECTIONERROR_DEC;
	PRINTEVENT_DEC;
	PRINTXCBERROR_DEC;
	PRINTUNEXPECTEDEVENT_DEC;
/*!}*/

#define CLIENT_BLOCK_SIZE /*----------*/ (25)
#define MAPPED_CLIENT_BLOCK_SIZE /*---*/ (10)
#define WALLPAPER_STRIP_BLOCK_SIZE /*-*/ (1024)

def struct{
	xcb_window_t /*-*/ window;

	int32 /*--------*/ x;
	int32 /*--------*/ y;
	int32 /*--------*/ width;
	int32 /*--------*/ height;

	int32 /*--------*/ imageX;
	int32 /*--------*/ imageY;

	int32 /*--------*/ viewableX;
	int32 /*--------*/ viewableY;
	int32 /*--------*/ viewableWidth;
	int32 /*--------*/ viewableHeight;

	uint16 /*-------*/ index;
	int16 /*--------*/ mappedIndex;
} Client;

def struct{
	uint16 /*-------*/ x;
	uint16 /*-------*/ y;
	uint16 /*-------*/ w;
	uint16 /*-------*/ h;
} Monitor;

def struct{
	uint32 /*-------*/ start;
	uint32 /*-------*/ wall;
} WallpaperStrip;

Client *clientStart;
Client *clientWall;
uint clientSize = CLIENT_BLOCK_SIZE;
uint clientAllocated = 0;
uint *mappedClientStart;
uint mappedClientSize = MAPPED_CLIENT_BLOCK_SIZE;
uint mappedClientAllocated = 0;
WallpaperStrip *wallpaperStripStart;
uint wallpaperStripSize = WALLPAPER_STRIP_BLOCK_SIZE;
uint wallpaperStripAllocated;
xcb_pixmap_t wallpaperPixmap;
int width;
int height;
uint32 *data;
xcb_gcontext_t overlaygc;
xcb_window_t overlayWindow;
xcb_get_image_cookie_t *frameCookieStart;
int64 minClock = 100000;
int64 maxClock = 0;
int64 avgClock = 0;
uint avgClockCounter = 0;
uint monitorAmount;
void *monitorData;
Monitor *monitorStart;
Monitor *monitorWall;
bool *wallpaperTruthTableStart;
uint pixelsToDraw;
uint32 *pixmapData;
xcb_atom_t rootPixmapAtom;
const uint32 windowValueList = XCB_EVENT_MASK_VISIBILITY_CHANGE | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_STRUCTURE_NOTIFY;

local Client *findWindow(const xcb_window_t w);
local void unmapWindow(Client *const client);
local void mapWindow(Client *const client);
local void calculateWallpaperStrips(void);
local void printWallpaper(void);

int main(const int argumentAmount, const char *const *argument){
	(void)argumentAmount;
	jmp main;
	main:{
		foreground = 0xFFE5E5E3;
		background = 0xFF292929;
		jmp setPrimaryGlobals;
	}
	setPrimaryGlobals:{
		programName /*---------*/ = *argument;
		errorPath /*-----------*/ = NULL;
		connectionName /*------*/ = NULL;
		mustOpenErrorStream /*-*/ = false;
		errorStream /*---------*/ = DefaultErrorStream;
		connection /*----------*/ = NULL;
		genericError /*--------*/ = NULL;
		event0 /*--------------*/ = NULL;
		event1 /*--------------*/ = NULL;
		agp0 /*----------------*/ = NULL;
		quitMessage /*---------*/ = NULL;



		pixmapData /*----------*/ = NULL;



		clientStart = malloc(clientSize * sizeof(Client));
		clientWall = clientStart + clientAllocated;
		mappedClientStart = malloc(clientSize * sizeof(uint));

#ifdef a
		wallpaperRectangleStart = malloc(wallpaperRectangleSize * sizeof(WallpaperRectangle));
#endif

		wallpaperStripStart = malloc(wallpaperStripSize * sizeof(WallpaperStrip));



		frameCookieStart = malloc(100 * sizeof(xcb_get_image_cookie_t));



		jmp establishServerConnection;
	}
	establishServerConnection:{
		#define ESTABLISHSERVERCONNECTION_CONNECTION /*-----*/ connection
		#define ESTABLISHSERVERCONNECTION_CONNECTIONNAME /*-*/ connectionName
		#define ESTABLISHSERVERCONNECTION_SCREEN /*---------*/ screen
		#include "xcb/establishServerConnection.hold"
		switch xcb_connection_has_error(connection) over
			to XCB_NONE: /*------------*/ /*-----------------------------------------------------------------*/ jmp generateIDs;
			to XCB_CONN_CLOSED_PARSE_ERR: printError(connectionName? "invalid server name" : "no server name"); jmp mainEmergencyExit;
			off: /*--------------------*/ printConnectionError(); /*-----------------------------------------*/ jmp mainEmergencyExit;
		end
	}
	generateIDs:{
		jmp setupScreenProfile;
	}
	setupScreenProfile:{
		#define SETUPSCREENPROFILE_VISUAL /*-*/ visual
		#define SETUPSCREENPROFILE_DEPTH /*--*/ depth
		#include "xcb/setupScreenProfile.hold"
	}
	{
		xcb_composite_get_overlay_window_reply_t *overlay = xcb_composite_get_overlay_window_reply(connection, xcb_composite_get_overlay_window(connection, (*screen).root), NULL);
		if(overlay){
			overlayWindow = (*overlay).overlay_win;
			free(overlay);
		}
	}
	{
		const uint32 valueList = XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_change_window_attributes(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		xcb_composite_redirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}









	jmp storeMonitors;
	storeMonitors:{
		void *reply;
		Monitor *monitorCurrent;
		xcb_randr_monitor_info_iterator_t iterator;
		if(!(reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors(connection, (*screen).root, true), NULL))){
			monitorAmount = 1;
			jmp calculateOverlayWindowBooleanValues;
		}
		monitorAmount = (*(xcb_randr_get_monitors_reply_t *)reply).nMonitors;
		if(!(monitorData = malloc(monitorAmount * sizeof(Monitor)))){
			free(reply);
			jmp calculateOverlayWindowBooleanValues;
		}
		iterator = xcb_randr_get_monitors_monitors_iterator(reply);
		monitorStart = monitorData;
		monitorCurrent = monitorStart;
		monitorWall = monitorStart + monitorAmount;
		storeMonitorLoop:{
			if(monitorCurrent < monitorWall){
				const xcb_randr_monitor_info_t *const data = iterator.data;
				const uint x = (*data).x;
				const uint y = (*data).y;
				const uint w = (*data).width;
				const uint h = (*data).height;
				if(monitorCurrent > monitorStart){
					const Monitor *const wall = monitorCurrent;
					const Monitor *current = monitorStart;
					removeSameMonitorLoop:{
						if(current < wall){
							if((*current).x == x and (*current).y == y and (*current).w == w and (*current).h == h){
								dec monitorAmount;
								dec monitorWall;
								xcb_randr_monitor_info_next(&iterator);
								jmp storeMonitorLoop;
							}
							inc current;
							jmp removeSameMonitorLoop;
						}
					}
				}
				(*monitorCurrent).x = x;
				(*monitorCurrent).y = y;
				(*monitorCurrent).w = w;
				(*monitorCurrent).h = h;
				xcb_randr_monitor_info_next(&iterator);
				inc monitorCurrent;
				jmp storeMonitorLoop;
			}
			jmp trimMonitorMemory;
		}
		trimMonitorMemory:{
			void *temp;
			if(!(temp = realloc(monitorData, monitorAmount * sizeof(Monitor)))){
				free(reply);
				jmp calculateOverlayWindowBooleanValues;
			}
			monitorData = temp;
		}
		monitorStart = monitorData;
		monitorWall = monitorStart + monitorAmount;
		free(reply);
		jmp calculateOverlayWindowBooleanValues;
	}
	calculateOverlayWindowBooleanValues:{
		uint i = 0;
		uint pixelTotal = 0;
		while(i < monitorAmount){
			pixelTotal += (*(monitorStart + i)).w * (*(monitorStart + i)).h;
			inc i;
		}
		pixelsToDraw = (*screen).width_in_pixels * (*screen).height_in_pixels;
		wallpaperTruthTableStart = malloc(pixelsToDraw * sizeof(bool));
		if(pixelTotal < pixelsToDraw){



			/*!
				when monitors overlap:

				1. double for loop that checks all monitors with all monitors
				2. check where the two monitors overlap and remove the area from one of the monitors

				all in all, we don't really view monitors as distinct devices that actually do something but rather just part of the single screen we draw on
			*/



			/*! pixelsToDraw = pixelTotal; */
		}
	}



	{
		overlaygc = xcb_generate_id(connection);
		width = (*screen).width_in_pixels;
		height = (*screen).height_in_pixels;
		data = malloc(width * height * sizeof(uint32));
		xcb_create_gc(connection, overlaygc, (*screen).root, XCB_NONE, NULL);
	}



	{
		xcb_intern_atom_reply_t *reply = xcb_intern_atom_reply(connection, xcb_intern_atom(connection, false, strlen("_XROOTPMAP_ID"), "_XROOTPMAP_ID"), NULL);
		rootPixmapAtom = XCB_NONE;
		if(reply){
			rootPixmapAtom = (*reply).atom;
			free(reply);
		}
		if(rootPixmapAtom){
			xcb_get_property_reply_t *reply = xcb_get_property_reply(connection, xcb_get_property(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL);
			if(reply){
				wallpaperPixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
				if(wallpaperPixmap){
					void *reply = xcb_get_image_reply(connection, xcb_get_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, wallpaperPixmap, 0, 0, width, height, -1), NULL);
					pixmapData = (void *)xcb_get_image_data(reply);
				}
				free(reply);
			}
		}
	}



	{
		const uint32 stackMode = XCB_STACK_MODE_BELOW;
		xcb_configure_window(connection, overlayWindow, XCB_CONFIG_WINDOW_STACK_MODE, &stackMode);
	}



























	{
		xcb_query_tree_reply_t *const reply = xcb_query_tree_reply(connection, xcb_query_tree(connection, (*screen).root), NULL);
		if(reply){
			const uint amount = xcb_query_tree_children_length(reply);
			const xcb_window_t *const windowStart = xcb_query_tree_children(reply);
			const xcb_window_t *windowCurrent = windowStart;
			const xcb_window_t *const windowWall = windowStart + amount;
			Client *clientCurrent = clientStart;
			xcb_get_window_attributes_reply_t *reply1;
			getWindowAttributesLoop:{
				if(*windowCurrent != overlayWindow and (reply1 = xcb_get_window_attributes_reply(connection, xcb_get_window_attributes(connection, *windowCurrent), NULL))){
					if((*reply1)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
						xcb_get_geometry_reply_t *const geometry = xcb_get_geometry_reply(connection, xcb_get_geometry(connection, *windowCurrent), NULL);
						if(clientAllocated == clientSize){
							void *temp;
							clientSize += CLIENT_BLOCK_SIZE;
							if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
								exit(1);
							}
							clientStart = temp;
							clientCurrent = clientStart + clientAllocated;
						}
						(*clientCurrent).window = *windowCurrent;
						if(geometry){
							(*clientCurrent).x = (*geometry).x;
							(*clientCurrent).y = (*geometry).y;
							(*clientCurrent).width = (*geometry).width;
							(*clientCurrent).height = (*geometry).height;
							free(geometry);
						}else{
							(*clientCurrent).x = (*screen).width_in_pixels;
							(*clientCurrent).y = (*screen).height_in_pixels;
							(*clientCurrent).width = 0;
							(*clientCurrent).height = 0;
						}
						(*clientCurrent).imageX = 0;
						(*clientCurrent).imageY = 0;
						(*clientCurrent).viewableX = (*clientCurrent).x;
						(*clientCurrent).viewableY = (*clientCurrent).y;
						(*clientCurrent).viewableWidth = (*clientCurrent).width;
						(*clientCurrent).viewableHeight = (*clientCurrent).height;
						(*clientCurrent).index = clientAllocated;
						(*clientCurrent).mappedIndex = -1;
						if((*clientCurrent).viewableX < 0){
							(*clientCurrent).imageX = -(*clientCurrent).x;
							(*clientCurrent).viewableWidth += (*clientCurrent).viewableX;
							(*clientCurrent).viewableX = 0;
						}
						if((*clientCurrent).viewableY < 0){
							(*clientCurrent).imageY = -(*clientCurrent).y;
							(*clientCurrent).viewableHeight += (*clientCurrent).viewableY;
							(*clientCurrent).viewableY = 0;
						}
						if((*clientCurrent).viewableX + (*clientCurrent).viewableWidth > width){
							(*clientCurrent).viewableWidth -= (*clientCurrent).viewableX + (*clientCurrent).viewableWidth - width;
						}
						if((*clientCurrent).viewableY + (*clientCurrent).viewableHeight > height){
							(*clientCurrent).viewableHeight -= (*clientCurrent).viewableY + (*clientCurrent).viewableHeight - height;
						}
						if((*reply1).map_state == XCB_MAP_STATE_VIEWABLE){
							(*clientCurrent).mappedIndex = mappedClientAllocated;
							if(mappedClientAllocated == mappedClientSize){
								void *temp;
								mappedClientSize += MAPPED_CLIENT_BLOCK_SIZE;
								if(!(temp = realloc(mappedClientStart, mappedClientSize * sizeof(uint)))){
									exit(1);
								}
								mappedClientStart = temp;
							}
							*(mappedClientStart + mappedClientAllocated) = clientAllocated;
							inc mappedClientAllocated;
						}
						xcb_change_window_attributes(connection, *windowCurrent, XCB_CW_EVENT_MASK, &windowValueList);
						inc clientCurrent;
						inc clientAllocated;
					}
					free(reply1);
				}
				if(inc windowCurrent < windowWall){
					jmp getWindowAttributesLoop;
				}
			}
			clientWall = clientStart + clientAllocated;
			free(reply);
		}
	}









	eventLoop:{
		xcb_flush(connection);
		free(event0);
		if(event1){
			event0 = event1;
			event1 = NULL;
			jmp switchEvents;
		}
		event0 = NULL;
		jmp waitForEventLoop;
	}
	waitForEventLoop:{
		if((event0 = xcb_poll_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		calculateWallpaperStrips();
		printWallpaper();
		jmp printFrame;
	}
	switchEvents:{
		#undef  XCB_RANDR_SCREEN_CHANGE_NOTIFY
		#define XCB_ONE /*------------------------*/ (1)
		#define XCB_RANDR_SCREEN_CHANGE_NOTIFY /*-*/ (89)
		printEvent();
		switch (*event0).response_type & ~0x80 over
			to XCB_NONE: /*-----------------------*/ jmp errorEvent;
			to XCB_ONE: /*------------------------*/ jmp unexpectedEvent;
			to XCB_KEY_PRESS: /*------------------*/ jmp unexpectedEvent;
			to XCB_KEY_RELEASE: /*----------------*/ jmp unexpectedEvent;
			to XCB_BUTTON_PRESS: /*---------------*/ jmp unexpectedEvent;
			to XCB_BUTTON_RELEASE: /*-------------*/ jmp unexpectedEvent;
			to XCB_MOTION_NOTIFY: /*--------------*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*---------------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*---------------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*-------------------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*------------------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*--------------*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*---------------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*----------*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*----------------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*----------*/ jmp visibilityNotifyEvent;
			to XCB_CREATE_NOTIFY: /*--------------*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*-------------*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*---------------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*-----------------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*----------------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*------------*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*-----------*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*----------*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*-------------*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*-------------*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*-----------*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*----------*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*------------*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*------------*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*----------*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*-----------*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*------------*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*-------------*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*-------------*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*-----------------*/ jmp unexpectedEvent;
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY: /*-*/ jmp unexpectedEvent;
			off: /*-------------------------------*/ jmp unexpectedEvent;
		end
		#undef  XCB_RANDR_SCREEN_CHANGE_NOTIFY
		#undef  XCB_ONE
	}
	visibilityNotifyEvent:{
		Client *const client = findWindow((*(xcb_visibility_notify_event_t *)event0).window);
		if(!client){
			jmp eventLoop;
		}
		if((*(xcb_visibility_notify_event_t *)event0).state == XCB_VISIBILITY_FULLY_OBSCURED){
			unmapWindow(client);
			jmp eventLoop;
		}
		mapWindow(client);
		jmp eventLoop;
	}
	createNotifyEvent:{



		/*! buggy, window shown at (0, 0) sometimes, fix immediately */



#ifdef a
		const xcb_window_t window = (*(xcb_create_notify_event_t *)event0).window;
		xcb_get_window_attributes_reply_t *reply;
		Client client;
		bool viewable = false;



		if(window == overlayWindow){
			jmp eventLoop;
		}
		if(!(reply = xcb_get_window_attributes_reply(connection, xcb_get_window_attributes(connection, window), NULL))){
			jmp eventLoop;
		}
		if((*reply)._class != XCB_WINDOW_CLASS_INPUT_OUTPUT){
			free(reply);
			jmp eventLoop;
		}
		if((*reply).map_state == XCB_MAP_STATE_VIEWABLE){
			viewable = true;
		}
		free(reply);
		xcb_change_window_attributes(connection, window, XCB_CW_EVENT_MASK, &windowValueList);



		if(clientAllocated == clientSize){
			void *temp;
			clientSize += CLIENT_BLOCK_SIZE;
			if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
				exit(1);
			}
			clientStart = temp;
			clientWall = clientStart + clientAllocated;
		}



		client.window = window;
		client.x = (*(xcb_create_notify_event_t *)event0).x;
		client.y = (*(xcb_create_notify_event_t *)event0).y;
		client.width = (*(xcb_create_notify_event_t *)event0).width;
		client.height = (*(xcb_create_notify_event_t *)event0).height;
		client.imageX = 0;
		client.imageY = 0;
		client.viewableX = client.x;
		client.viewableY = client.y;
		client.viewableWidth = client.width;
		client.viewableHeight = client.height;
		client.index = clientAllocated;
		client.mappedIndex = -1;
		if(client.viewableX < 0){
			client.imageX = -client.x;
			client.viewableWidth += client.viewableX;
			client.viewableX = 0;
		}
		if(client.viewableY < 0){
			client.imageY = -client.y;
			client.viewableHeight += client.viewableY;
			client.viewableY = 0;
		}
		if(client.viewableX + client.viewableWidth > width){
			client.viewableWidth -= client.viewableX + client.viewableWidth - width;
		}
		if(client.viewableY + client.viewableHeight > height){
			client.viewableHeight -= client.viewableY + client.viewableHeight - height;
		}
		if(viewable){
			client.mappedIndex = mappedClientAllocated;
			if(mappedClientAllocated == mappedClientSize){
				void *temp;
				mappedClientSize += MAPPED_CLIENT_BLOCK_SIZE;
				if(!(temp = realloc(mappedClientStart, mappedClientSize * sizeof(uint)))){
					exit(1);
				}
				mappedClientStart = temp;
			}
			*(mappedClientStart + mappedClientAllocated) = clientAllocated;
			inc mappedClientAllocated;
		}
		inc clientAllocated;
		inc clientWall;



		*(clientStart + clientAllocated - 1) = client;
#endif



		clientAllocated = 0;
		mappedClientAllocated = 0;
		{
			xcb_query_tree_reply_t *const reply = xcb_query_tree_reply(connection, xcb_query_tree(connection, (*screen).root), NULL);
			if(reply){
				const uint amount = xcb_query_tree_children_length(reply);
				const xcb_window_t *const windowStart = xcb_query_tree_children(reply);
				const xcb_window_t *windowCurrent = windowStart;
				const xcb_window_t *const windowWall = windowStart + amount;
				Client *clientCurrent = clientStart;
				xcb_get_window_attributes_reply_t *reply1;
				getWindowAttributes1Loop:{
					if(*windowCurrent != overlayWindow and (reply1 = xcb_get_window_attributes_reply(connection, xcb_get_window_attributes(connection, *windowCurrent), NULL))){
						if((*reply1)._class == XCB_WINDOW_CLASS_INPUT_OUTPUT){
							xcb_get_geometry_reply_t *const geometry = xcb_get_geometry_reply(connection, xcb_get_geometry(connection, *windowCurrent), NULL);
							if(clientAllocated == clientSize){
								void *temp;
								clientSize += CLIENT_BLOCK_SIZE;
								if(!(temp = realloc(clientStart, clientSize * sizeof(Client)))){
									exit(1);
								}
								clientStart = temp;
								clientCurrent = clientStart + clientAllocated;
							}
							(*clientCurrent).window = *windowCurrent;
							if(geometry){
								(*clientCurrent).x = (*geometry).x;
								(*clientCurrent).y = (*geometry).y;
								(*clientCurrent).width = (*geometry).width;
								(*clientCurrent).height = (*geometry).height;
								free(geometry);
							}else{
								(*clientCurrent).x = (*screen).width_in_pixels;
								(*clientCurrent).y = (*screen).height_in_pixels;
								(*clientCurrent).width = 0;
								(*clientCurrent).height = 0;
							}
							(*clientCurrent).imageX = 0;
							(*clientCurrent).imageY = 0;
							(*clientCurrent).viewableX = (*clientCurrent).x;
							(*clientCurrent).viewableY = (*clientCurrent).y;
							(*clientCurrent).viewableWidth = (*clientCurrent).width;
							(*clientCurrent).viewableHeight = (*clientCurrent).height;
							(*clientCurrent).index = clientAllocated;
							(*clientCurrent).mappedIndex = -1;
							if((*clientCurrent).viewableX < 0){
								(*clientCurrent).imageX = -(*clientCurrent).x;
								(*clientCurrent).viewableWidth += (*clientCurrent).viewableX;
								(*clientCurrent).viewableX = 0;
							}
							if((*clientCurrent).viewableY < 0){
								(*clientCurrent).imageY = -(*clientCurrent).y;
								(*clientCurrent).viewableHeight += (*clientCurrent).viewableY;
								(*clientCurrent).viewableY = 0;
							}
							if((*clientCurrent).viewableX + (*clientCurrent).viewableWidth > width){
								(*clientCurrent).viewableWidth -= (*clientCurrent).viewableX + (*clientCurrent).viewableWidth - width;
							}
							if((*clientCurrent).viewableY + (*clientCurrent).viewableHeight > height){
								(*clientCurrent).viewableHeight -= (*clientCurrent).viewableY + (*clientCurrent).viewableHeight - height;
							}
							if((*reply1).map_state == XCB_MAP_STATE_VIEWABLE){
								(*clientCurrent).mappedIndex = mappedClientAllocated;
								if(mappedClientAllocated == mappedClientSize){
									void *temp;
									mappedClientSize += MAPPED_CLIENT_BLOCK_SIZE;
									if(!(temp = realloc(mappedClientStart, mappedClientSize * sizeof(uint)))){
										exit(1);
									}
									mappedClientStart = temp;
								}
								*(mappedClientStart + mappedClientAllocated) = clientAllocated;
								inc mappedClientAllocated;
							}
							xcb_change_window_attributes(connection, *windowCurrent, XCB_CW_EVENT_MASK, &windowValueList);
							inc clientCurrent;
							inc clientAllocated;
						}
						free(reply1);
					}
					if(inc windowCurrent < windowWall){
						jmp getWindowAttributes1Loop;
					}
				}
				clientWall = clientStart + clientAllocated;
				free(reply);
			}
		}



		jmp eventLoop;
	}
	destroyNotifyEvent:{
		Client *const client = findWindow((*(xcb_destroy_notify_event_t *)event0).window);
		if(!client){
			jmp eventLoop;
		}
		unmapWindow(client);



		/*! remove destroyed client from list */
		{
			Client *clientCurrent = clientStart + (*client).index;
			dec clientWall;
			dec clientAllocated;
			while(clientCurrent < clientWall){
				*clientCurrent = *(clientCurrent + 1);
				dec (*clientCurrent).index;
				inc clientCurrent;
			}
		}



		/*! update mapped client indexes */
		{
			Client *clientCurrent = clientStart;
			uint *mappedClientCurrent = mappedClientStart;
			uint *mappedClientWall = mappedClientStart + mappedClientAllocated;
			while(clientCurrent < clientWall and mappedClientCurrent < mappedClientWall){
				if((*clientCurrent).mappedIndex != -1){
					*mappedClientCurrent = (*clientCurrent).index;
					inc mappedClientCurrent;
				}
				inc clientCurrent;
			}
		}



		{
			uint *mappedClientCurrent = mappedClientStart;
			uint *mappedClientWall = mappedClientStart + mappedClientAllocated;
			while(mappedClientCurrent < mappedClientWall){
				fprintf(stdout, "window %u\t\tindex %u\t\tmappedIndex %i\n", (*(clientStart + *mappedClientCurrent)).window, (*(clientStart + *mappedClientCurrent)).index, (*(clientStart + *mappedClientCurrent)).mappedIndex);
				inc mappedClientCurrent;
			}
		}



		jmp eventLoop;
	}
	unmapNotifyEvent:{
		Client *const client = findWindow((*(xcb_unmap_notify_event_t *)event0).window);
		if(client){
			unmapWindow(client);
		}
		jmp eventLoop;
	}
	mapNotifyEvent:{
		Client *const client = findWindow((*(xcb_map_notify_event_t *)event0).window);
		if(client){
			mapWindow(client);
		}
		jmp eventLoop;
	}
	reparentNotifyEvent:{
		if((*(xcb_reparent_notify_event_t *)event0).parent == (*screen).root){
			jmp createNotifyEvent;
		}
		jmp destroyNotifyEvent;
	}
	configureNotifyEvent:{
		Client *client;



		consumeRepeatingConfigureNotifyEventLoop:{
			if((event1 = xcb_poll_for_event(connection))){
				if((*event1).response_type == XCB_CONFIGURE_NOTIFY and (*(xcb_configure_notify_event_t *)event0).window == (*(xcb_configure_notify_event_t *)event1).window){
					free(event0);
					event0 = event1;
					jmp consumeRepeatingConfigureNotifyEventLoop;
				}
				jmp consumeRepeatingConfigureNotifyEventLoopExit;
			}
			if(xcb_connection_has_error(connection)){
				printConnectionError();
				jmp consumeRepeatingConfigureNotifyEventLoopExit;
			}
		}
		consumeRepeatingConfigureNotifyEventLoopExit:{}



		if(!(client = findWindow((*(xcb_configure_notify_event_t *)event0).window))){
			jmp eventLoop;
		}
		(*client).x = (*(xcb_configure_notify_event_t *)event0).x;
		(*client).y = (*(xcb_configure_notify_event_t *)event0).y;
		(*client).width = (*(xcb_configure_notify_event_t *)event0).width;
		(*client).height = (*(xcb_configure_notify_event_t *)event0).height;
		(*client).imageX = 0;
		(*client).imageY = 0;
		(*client).viewableX = (*client).x;
		(*client).viewableY = (*client).y;
		(*client).viewableWidth = (*client).width;
		(*client).viewableHeight = (*client).height;
		if((*client).viewableX < 0){
			(*client).imageX = -(*client).x;
			(*client).viewableWidth += (*client).viewableX;
			(*client).viewableX = 0;
		}
		if((*client).viewableY < 0){
			(*client).imageY = -(*client).y;
			(*client).viewableHeight += (*client).viewableY;
			(*client).viewableY = 0;
		}
		if((*client).viewableX + (*client).viewableWidth > width){
			(*client).viewableWidth -= (*client).viewableX + (*client).viewableWidth - width;
		}
		if((*client).viewableY + (*client).viewableHeight > height){
			(*client).viewableHeight -= (*client).viewableY + (*client).viewableHeight - height;
		}



		/*!
			xcb_query_tree_reply_t *const reply = xcb_query_tree_reply(connection, xcb_query_tree(connection, (*screen).root), NULL);
			if(reply){
				const uint amount = xcb_query_tree_children_length(reply);
				const xcb_window_t *const windowStart = xcb_query_tree_children(reply);
				const xcb_window_t *windowCurrent = windowStart;
				const xcb_window_t *const windowWall = windowStart + amount;
				Client *clientCurrent = clientStart;
				xcb_get_window_attributes_reply_t *reply1;
				uint counter = 0;
		*/



		/*!*/

		/*! {
			xcb_query_tree_reply_t *const reply = xcb_query_tree_reply(connection, xcb_query_tree(connection, (*screen).root), NULL);
			if(reply){
				const xcb_window_t *const windowStart = xcb_query_tree_children(reply);
				const xcb_window_t *const windowWall = windowStart + xcb_query_tree_children_length(reply);
				const xcb_window_t *windowCurrent = windowStart;



				while(windowCurrent < windowWall){



					inc windowCurrent;
				}



				free(reply);
			}
		} */



		{
			Client *clientCurrent = clientStart;
			while(clientCurrent < clientWall){
				if((*clientCurrent).window == (*(xcb_configure_notify_event_t *)event0).window){
					inc clientCurrent;
					if((*clientCurrent).window != (*(xcb_configure_notify_event_t *)event0).above_sibling){



						fprintf(stdout, "\n\n\n");



						fprintf(stdout, "z order changed\n");



						fprintf(stdout, "\n\n\n");



					}
					brk;
				}
				inc clientCurrent;
			}
		}



		jmp eventLoop;
	}
	propertyNotifyEvent:{
		if((*(xcb_property_notify_event_t *)event0).atom == rootPixmapAtom){
			if(rootPixmapAtom){
				xcb_get_property_reply_t *reply = xcb_get_property_reply(connection, xcb_get_property(connection, false, (*screen).root, rootPixmapAtom, XCB_ATOM_PIXMAP, 0, 1), NULL);
				if(reply){
					wallpaperPixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
					if(wallpaperPixmap){
						void *reply = xcb_get_image_reply(connection, xcb_get_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, wallpaperPixmap, 0, 0, width, height, -1), NULL);
						pixmapData = (void *)xcb_get_image_data(reply);
					}
					free(reply);
				}
			}
		}
		jmp eventLoop;
	}
	errorEvent:{
		genericError = (void *)event0;
		printXCBError();
		genericError = NULL;
		jmp eventLoop;
	}
	unexpectedEvent:{
		printUnexpectedEvent();
		jmp eventLoop;
	}
	printFrame:{
		clock_t t = clock();
		uint *mappedClientCurrent = mappedClientStart;
		uint *mappedClientWall = mappedClientStart + mappedClientAllocated;
		xcb_get_image_cookie_t *frameCookieCurrent = frameCookieStart;
		getImageCookieLoop:{
			const Client *const c = clientStart + *mappedClientCurrent;
			*frameCookieCurrent = xcb_get_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*c).window, (*c).imageX, (*c).imageY, (*c).viewableWidth, (*c).viewableHeight, -1);
			if(inc mappedClientCurrent < mappedClientWall){
				inc frameCookieCurrent;
				jmp getImageCookieLoop;
			}
			mappedClientCurrent = mappedClientStart;
			frameCookieCurrent = frameCookieStart;
			jmp drawWindowsLoop;
		}
		drawWindowsLoop:{
			xcb_get_image_reply_t *const reply = xcb_get_image_reply(connection, *frameCookieCurrent, NULL);
			if(reply){
				const Client *const c = clientStart + *mappedClientCurrent;
				const int clientWidth = (*c).viewableWidth;
				const int clientHeight = (*c).viewableHeight;
				if(clientWidth > 0 and clientHeight > 0){
					uint32 *sourceData = (void *)xcb_get_image_data(reply);
					uint32 *destinationData = data + (*c).viewableY * width + (*c).viewableX;
					uint32 *dStart = destinationData;
					uint32 *sStart = sourceData;
					uint32 *dWall = destinationData + width * clientHeight;
					uint32 *dW = dStart + clientWidth;
					switch (*reply).depth over
						to 24:{
							while(dStart < dWall){
								uint32 *dCurrent = dStart;
								uint32 *sCurrent = sStart;
								while(dCurrent < dW){
									*dCurrent = *sCurrent;
									inc dCurrent;
									inc sCurrent;
								}
								dStart += width;
								sStart += clientWidth;
								dW += width;
							}
							brk;
						}
						to 32:{
							while(dStart < dWall){
								uint32 *dCurrent = dStart;
								uint32 *sCurrent = sStart;
								while(dCurrent < dW){
									const uint32 alpha = *sCurrent & 0xFF000000;
									if(alpha == 0xFF000000){
										*dCurrent = *sCurrent;
									}elif(alpha){
										const uint32 a0 = alpha >> 24;
										const uint32 a1 = 0xFF - a0;
										const uint32 r = a0 * (*sCurrent & 0x00FF0000) + a1 * (*dCurrent & 0x00FF0000);
										const uint32 g = a0 * (*sCurrent & 0x0000FF00) + a1 * (*dCurrent & 0x0000FF00);
										const uint32 b = a0 * (*sCurrent & 0x000000FF) + a1 * (*dCurrent & 0x000000FF);
										*dCurrent = ((r & 0xFF000000) + (g & 0x00FF0000) + (b & 0x0000FF00)) >> 8 | 0xFF000000;
									}
									inc dCurrent;
									inc sCurrent;
								}
								dStart += width;
								sStart += clientWidth;
								dW += width;
							}
							brk;
						}
						off:{
							brk;
						}
					end
				}
				free(reply);
			}
			if(inc mappedClientCurrent < mappedClientWall){
				inc frameCookieCurrent;
				jmp drawWindowsLoop;
			}
		}
		xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, overlayWindow, overlaygc, width, height, 0, 0, 0, 24, width * height * sizeof(uint32), (void *)data);
		xcb_flush(connection);



		t = clock() - t;
		avgClock += t;
		if(t < minClock){
			minClock = t;
		}
		if(t > maxClock){
			maxClock = t;
		}
		inc avgClockCounter;
		if(!avgClockCounter){
			avgClock = t;
			avgClockCounter = 1;
		}
		fprintf(stdout, "took %lu\t\tmin %lu\t\tmax %lu\t\tavg %lu\n", t, minClock, maxClock, avgClock / avgClockCounter);



		if((event0 = xcb_poll_for_event(connection))){
			jmp switchEvents;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp eventLoopExit;
		}
		jmp printFrame;
	}
	eventLoopExit:{
		free(event0);
		event0 = NULL;
		free(event1);
		event1 = NULL;
		jmp mainEmergencyExit;
	}
	mainEmergencyExit:{
		xcb_disconnect(connection);
		connection = NULL;
		ret 0;
	}
}
local Client *findWindow(const xcb_window_t w){
	Client *clientCurrent = clientStart;
	jmp findClientLoop;
	findClientLoop:{
		if((*clientCurrent).window == w){
			ret clientCurrent;
		}
		if(inc clientCurrent < clientWall){
			jmp findClientLoop;
		}
		ret NULL;
	}
}
local void unmapWindow(Client *const client){
	if((*client).mappedIndex != -1){
		uint *mappedClientCurrent = mappedClientStart + (*client).mappedIndex;
		uint *mappedClientWall = mappedClientStart + dec mappedClientAllocated;
		while(mappedClientCurrent < mappedClientWall){
			Client *const c = clientStart + *(mappedClientCurrent + 1);
			*mappedClientCurrent = (*c).index;
			dec (*c).mappedIndex;
			inc mappedClientCurrent;
		}
		(*client).mappedIndex = -1;
	}
	ret;
}
local void mapWindow(Client *const client){
	if((*client).mappedIndex != -1){
		ret;
	}
	if(mappedClientAllocated == mappedClientSize){
		void *temp;
		mappedClientSize += MAPPED_CLIENT_BLOCK_SIZE;
		if(!(temp = realloc(mappedClientStart, mappedClientSize * sizeof(uint)))){
			exit(1);
		}
		mappedClientStart = temp;
	}
	{
		uint *current = mappedClientStart + mappedClientAllocated;
		uint *currentCopy = current;
		uint index = (*client).index;
		while(current > mappedClientStart and (*(clientStart + *(current - 1))).index > index){
			Client *const c = clientStart + *(current - 1);
			*current = (*c).index;
			inc (*c).mappedIndex;
			dec current;
		}
		(*client).mappedIndex = mappedClientAllocated - (currentCopy - current);
		*current = (*client).index;
		inc mappedClientAllocated;
	}
	ret;
}
local void calculateWallpaperStrips(void){
	{
		bool *wallpaperTruthTableCurrent = wallpaperTruthTableStart;
		bool *wallpaperTruthTableWall = wallpaperTruthTableStart + pixelsToDraw;
		while(wallpaperTruthTableCurrent < wallpaperTruthTableWall){
			*wallpaperTruthTableCurrent = false;
			inc wallpaperTruthTableCurrent;
		}
	}
	{
		uint *mappedClientCurrent = mappedClientStart;
		uint *mappedClientWall = mappedClientStart + mappedClientAllocated;
		fillWallpaperTruthTableStartLoop:{
			const Client *const c = clientStart + *mappedClientCurrent;
			const int viewableWidth = (*c).viewableWidth;
			const int viewableHeight = (*c).viewableHeight;
			if(viewableWidth > 0 and viewableHeight > 0){
				const int viewableX = (*c).viewableX;
				const int viewableY = (*c).viewableY;
				int x;
				int y;
				bool *wallpaperTruthTableCurrent = wallpaperTruthTableStart + viewableY * width + viewableX;
				for(y = 0; y < viewableHeight; inc y){
					for(x = 0; x < viewableWidth; inc x){
						*wallpaperTruthTableCurrent = true;
						inc wallpaperTruthTableCurrent;
					}
					wallpaperTruthTableCurrent += width - viewableWidth;
				}
			}
			if(inc mappedClientCurrent < mappedClientWall){
				jmp fillWallpaperTruthTableStartLoop;
			}
		}
	}
	{
		bool *current = wallpaperTruthTableStart;
		bool *wall = wallpaperTruthTableStart + pixelsToDraw;
		WallpaperStrip *wallpaperStripCurrent = wallpaperStripStart;
		bool *sStart = NULL;
		wallpaperStripAllocated = 0;
		fillLoop:{
			if(!*current){
				if(!sStart){
					sStart = current;
				}
			}else{
				if(sStart){
					addWallpaperStrip:{
						if(wallpaperStripAllocated == wallpaperStripSize){
							void *temp;
							wallpaperStripSize += WALLPAPER_STRIP_BLOCK_SIZE;
							if(!(temp = realloc(wallpaperStripStart, wallpaperStripSize * sizeof(WallpaperStrip)))){
								exit(1);
							}
							wallpaperStripCurrent = (WallpaperStrip *)temp + (wallpaperStripCurrent - wallpaperStripStart);
							wallpaperStripStart = temp;
						}
						(*wallpaperStripCurrent).start = sStart - wallpaperTruthTableStart;
						(*wallpaperStripCurrent).wall = current - wallpaperTruthTableStart;
						inc wallpaperStripCurrent;
						inc wallpaperStripAllocated;
						sStart = NULL;
					}
				}
			}
			if(inc current < wall){
				jmp fillLoop;
			}
			if(sStart){
				jmp addWallpaperStrip;
			}
		}
	}
	ret;
}
local void printWallpaper(void){
	WallpaperStrip *wallpaperStripCurrent = wallpaperStripStart;
	WallpaperStrip *wallpaperStripWall = wallpaperStripStart + wallpaperStripAllocated;
	printWallpaperLoop:{
		if(wallpaperStripCurrent < wallpaperStripWall){
			const uint32 *const dWall = data + (*wallpaperStripCurrent).wall;
			uint32 *d = data + (*wallpaperStripCurrent).start;
			uint32 *s = pixmapData + (*wallpaperStripCurrent).start;
			while(d < dWall){
				*d = *s;
				inc d;
				inc s;
			}
			inc wallpaperStripCurrent;
			jmp printWallpaperLoop;
		}
	}
	ret;
}
PRINTERROR_DEC{
	if(openErrorStream()){
		fprintf(errorStream, "%s: %s\n", programName, string);
		closeErrorStream();
	}
	ret;
}
OPENERRORSTREAM_DEC{
	ret !mustOpenErrorStream or (errorStream = fopen(errorPath, "a"));
}
CLOSEERRORSTREAM_DEC{
	if(mustOpenErrorStream and errorStream){
		fclose(errorStream);
		errorStream = NULL;
	}
	ret;
}
PRINTCONNECTIONERROR_DEC{
	if(openErrorStream()){
		#define PRINTCONNECTIONERROR_ERROR /*--*/ xcb_connection_has_error(connection)
		#define PRINTCONNECTIONERROR_STREAM /*-*/ errorStream
		#include "xcb/printConnectionError.hold"
		closeErrorStream();
	}
	ret;
}
#if DEBUG
PRINTEVENT_DEC{
	#define PRINTEVENT_EVENT /*--*/ event0
	#define PRINTEVENT_STREAM /*-*/ stdout
	#include "xcb/printEvent.hold"
	ret;
}
#endif
PRINTXCBERROR_DEC{
	if(openErrorStream()){
		#define PRINTXCBERROR_ERROR /*--*/ genericError
		#define PRINTXCBERROR_STREAM /*-*/ errorStream
		#include "xcb/printXCBError.hold"
		closeErrorStream();
	}
	ret;
}
#if DEBUG
PRINTUNEXPECTEDEVENT_DEC{
	if(openErrorStream()){
		#define PRINTUNEXPECTEDEVENT_EVENT /*--*/ event0
		#define PRINTUNEXPECTEDEVENT_STREAM /*-*/ errorStream
		#include "xcb/printUnexpectedEvent.hold"
		closeErrorStream();
	}
	ret;
}
#endif
